%{
  from gyb_syntax_support import *
  NODE_MAP = create_node_map()
  # -*- mode: Swift -*-
  # Ignore the following admonition; it applies to the resulting .swift file only
}%
//// Automatically Generated From SyntaxNodes.swift.gyb.
//// Do Not Edit Directly!
//===------------ SyntaxNodes.swift - Syntax Node definitions -------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

% for node in SYNTAX_NODES:
%   base_type = node.base_type
%   if node.is_base():
%     # Handled in SyntaxNodesBase.swift.gyb
%     pass
%   elif node.collection_element:
%     # Handled in SyntaxCollections.swift.gyb
%     pass
%   elif node.base_kind != EMIT_KIND:
%     pass
%   else:
%     # We are actually handling this node now

// MARK: - ${node.name}

%     for line in dedented_lines(node.description):
/// ${line}
%     end
public struct ${node.name}: ${node.base_type}Protocol, Hashable, Identifiable {
  public typealias ID = SyntaxIdentifier
%     # ======
%     # Cursor
%     # ======
%
%     if node.children:
  enum Cursor: Int {
%       for child in node.children:
    case ${child.swift_name}
%       end
  }
%     end

%   # ==============
%   # Initialization
%   # ==============
%
  public static func isValid(syntaxKind: SyntaxKind) -> Bool {
    Raw${node.name}.isValid(syntaxKind: syntaxKind)
  }
  public let syntax: Syntax

  /// Converts the given `Syntax` node to a `${node.name}` if possible. Returns
  /// `nil` if the conversion is not possible.
  @inlinable
  public init?<Node: SyntaxProtocol>(_ other: Node) {
    guard Self.isValid(syntaxKind: other.syntax.syntaxKind) else { return nil }
    self.init(data: other.data)
  }

  /// Creates a `${node.name}` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  /// FIXME:
  /// Initialize `${node.name}` unsafely assuming `syntax` is valid.
  @usableFromInline
  init(data: SyntaxData) {
    assert(Self.isValid(syntaxKind: data.raw.syntaxKind))
    self.syntax = Syntax(data: data)
  }
%     for child in node.children:
%       child_node = NODE_MAP.get(child.syntax_kind)
%       optional_mark = '?' if child.is_optional else ''

%       # ===================
%       # Children properties
%       # ===================
%       for line in dedented_lines(child.description):
  /// ${line}
%       end
  public var ${child.swift_name}: ${child.type_name + optional_mark} {
    get {
      let childData = data.child(at: Cursor.${child.swift_name}.rawValue)
%       if child.is_optional:
      return childData.map { ${child.type_name}(data: $0) }
%       else:
      return ${child.type_name}(data: childData!)
%       end
    }
    set(value) {
      self = with${child.name}(value)
    }
  }
%
%       # ===============
%       # Adding children
%       # ===============
%       if child_node and child_node.is_syntax_collection():
%         child_elt = child.collection_element_name
%         child_elt_type = child_node.collection_element_type
%         if not child_elt:
%           raise Exception("'collection_element_name' should be set for '%s' of '%s'" % (child.name, node.name))
%         end

  /// Adds the provided `${child_elt}` to the node's `${child.swift_name}`
  /// collection.
  /// - param element: The new `${child_elt}` to add to the node's
  ///                  `${child.swift_name}` collection.
  /// - returns: A copy of the receiver with the provided `${child_elt}`
  ///            appended to its `${child.swift_name}` collection.
  public func add${child_elt}(_ element: ${child_elt_type}) -> ${node.name} {
    var collection: RawSyntax
    if let col = raw.children[Cursor.${child.swift_name}.rawValue] {
      collection = col.appending(element.raw, arena: self.arena)
    } else {
      collection = RawSyntax.makeEmptyLayout(arena: arena, kind: .${child_node.swift_syntax_kind})
    }
    let newRaw = raw.replacingChild(at: Cursor.${child.swift_name}.rawValue,
                                     with: collection, arena: arena)
    return Self(data: data.replacingSelf(with: newRaw, arena: arena))
  }
%       end
%
  public func with${child.name}(_ newChild: ${child.type_name}?) -> Self {
    let newChildRaw = newChild?.raw
%       if not child.is_optional:
%         if child.is_token():
%           token = child.main_token()
%           tok_kind = token.swift_kind() if token else "unknown"
      ?? RawTokenSyntax.makeBlank(arena: arena, tokenKind: .${tok_kind}).raw
%         else:
      ?? Raw${child.type_name}.makeBlank(arena: arena).raw
%         end
%       end

    let newRaw = raw.replacingChild(
      at: Cursor.${child.swift_name}.rawValue, with: newChildRaw, arena: arena)
    return Self(data: data.replacingSelf(with: newRaw, arena: arena))
  }
%     end
}

extension ${node.name}: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
%     for child in node.children:
%       if child.is_optional:
      "${child.swift_name}": ${child.swift_name}.map(Syntax.init)?.asProtocol(SyntaxProtocol.self) as Any,
%       else:
      "${child.swift_name}": Syntax(${child.swift_name}).asProtocol(SyntaxProtocol.self) as Any,
%       end
%     end
    ])
  }
}
%   end
% end
