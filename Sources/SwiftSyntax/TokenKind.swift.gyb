%{
  # -*- mode: Swift -*-
  from gyb_syntax_support import *
  # Ignore the following admonition it applies to the resulting .swift file only
}%
//// Automatically Generated From TokenKind.swift.gyb.
//// Do Not Edit Directly!
//===----------------- TokenKind.swift - Token Kind Enum ------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

/// Enumerates the kinds of tokens in the Swift language.
public enum TokenKind: UInt16 {
  case eof
% for token in SYNTAX_TOKENS:
  case ${token.swift_kind()}
% end

  /// Initializes a keyword token kind from its string representation. If the
  /// given string is not a keyword, this function returns `nil`.
  public init?(keyword: StringRef) {
    switch keyword {
% for token in SYNTAX_TOKENS:
%   if token.is_keyword:
    case "${token.text}": self = .${token.swift_kind()}
%   end
% end
    default:
      return nil
    }
  }

  /// Returns `true` if the token is a Swift keyword.
  ///
  /// Keywords are reserved unconditionally for use by Swift and may not
  /// appear as identifiers in any position without being escaped. For example,
  /// `class`, `func`, or `import`.
  public var isKeyword: Bool {
    switch self {
    case .eof: return false
% for token in SYNTAX_TOKENS:
%   if token.is_keyword:
    case .${token.swift_kind()}: return true
%   else:
    case .${token.swift_kind()}: return false
%   end
% end
    }
  }

  /// Returns `true` if the token is a Swift punctuator.
  ///
  /// Punctuation tokens generally separate identifiers from each other. For
  /// example, the '<' and '>' characters in a generic parameter list, or the
  /// quote characters in a string literal.
  public var isPunctuation: Bool {
    switch self {
    case .eof: return false
% for token in SYNTAX_TOKENS:
%   if type(token).__name__ == 'Punctuator':
    case .${token.swift_kind()}: return true
%   else:
    case .${token.swift_kind()}: return false
%   end
% end
    }
  }

  var kind: String {
    switch self {
    case .eof: return "eof"
% for token in SYNTAX_TOKENS:
    case .${token.swift_kind()}: return "${token.kind}"
% end
    }
  }

  var defaultText: StringRef? {
    switch self {
% for token in SYNTAX_TOKENS:
%   if token.text:
    case .${token.swift_kind()}: return "${token.text}"
%   end
% end
    default: return nil
    }
  }
}

@available(*, deprecated, message: "Use plain TokenKind")
public enum LegacyTokenKind {
  case eof
% for token in SYNTAX_TOKENS:
%   kind = token.swift_kind()
%
%   # Tokens that don't have a set text have an associated value that
%   # contains their text.
%   if not token.text:
%     kind += '(String)'
%   end
  case ${kind}
% end
  var plain: (TokenKind, String) {
    switch self {
    case .eof: return (.eof, "")
% for token in SYNTAX_TOKENS:
%   if token.text:
    case .${token.swift_kind()}: return (.${token.swift_kind()}, "${token.text}")
%   else:
    case .${token.swift_kind()}(let text): return (.${token.swift_kind()}, text)
%   end
% end
    }
  }
}

