//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - TernaryExprSyntax

/// The ternary operator with operator precedences resolved.
/// 
/// ### Examples 
/// 
/// ```swift
/// a ? 1 : 0
/// ```
/// 
/// - Note: This node is only generated after operators are folded using the `SwiftOperators` library. 
///   Beforehand, the parser does not know the precedences of operators and thus represents the `?` and `:` by an ``UnresolvedTernaryExprSyntax``.
///
/// ### Children
/// 
///  - `condition`: ``ExprSyntax``
///  - `questionMark`: `?`
///  - `thenExpression`: ``ExprSyntax``
///  - `colon`: `:`
///  - `elseExpression`: ``ExprSyntax``
public struct TernaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable, _LeafExprSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .ternaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCondition: UnexpectedNodesSyntax? = nil,
      condition: some ExprSyntaxProtocol,
      _ unexpectedBetweenConditionAndQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .infixQuestionMarkToken(),
      _ unexpectedBetweenQuestionMarkAndThenExpression: UnexpectedNodesSyntax? = nil,
      thenExpression: some ExprSyntaxProtocol,
      _ unexpectedBetweenThenExpressionAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndElseExpression: UnexpectedNodesSyntax? = nil,
      elseExpression: some ExprSyntaxProtocol,
      _ unexpectedAfterElseExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeCondition), 
        Syntax(condition), 
        Syntax(unexpectedBetweenConditionAndQuestionMark), 
        Syntax(questionMark), 
        Syntax(unexpectedBetweenQuestionMarkAndThenExpression), 
        Syntax(thenExpression), 
        Syntax(unexpectedBetweenThenExpressionAndColon), 
        Syntax(colon), 
        Syntax(unexpectedBetweenColonAndElseExpression), 
        Syntax(elseExpression), 
        Syntax(unexpectedAfterElseExpression)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ternaryExpr,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeCondition: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var condition: ExprSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenConditionAndQuestionMark: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `?`.
  public var questionMark: TokenSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenQuestionMarkAndThenExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var thenExpression: ExprSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenThenExpressionAndColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `:`.
  public var colon: TokenSyntax {
    get {
      return Syntax(self).child(at: 7)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenColonAndElseExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var elseExpression: ExprSyntax {
    get {
      return Syntax(self).child(at: 9)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 9, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public var unexpectedAfterElseExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 10)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 10, with: Syntax(value), arena: SyntaxArena()).cast(TernaryExprSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeCondition, 
        \Self.condition, 
        \Self.unexpectedBetweenConditionAndQuestionMark, 
        \Self.questionMark, 
        \Self.unexpectedBetweenQuestionMarkAndThenExpression, 
        \Self.thenExpression, 
        \Self.unexpectedBetweenThenExpressionAndColon, 
        \Self.colon, 
        \Self.unexpectedBetweenColonAndElseExpression, 
        \Self.elseExpression, 
        \Self.unexpectedAfterElseExpression
      ])
}

// MARK: - ThenStmtSyntax

/// A statement used to indicate the produced value from an if/switch
/// expression.
/// 
///  Written as:
/// ```swift
/// then <expr>
/// ```
///
/// - Experiment: Requires experimental feature `thenStatements`.
///
/// ### Children
/// 
///  - `thenKeyword`: `then`
///  - `expression`: ``ExprSyntax``
#if compiler(>=5.8)
@_spi(ExperimentalLanguageFeatures)
#endif
public struct ThenStmtSyntax: StmtSyntaxProtocol, SyntaxHashable, _LeafStmtSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .thenStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeThenKeyword: UnexpectedNodesSyntax? = nil,
      thenKeyword: TokenSyntax = .keyword(.then),
      _ unexpectedBetweenThenKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeThenKeyword), 
        Syntax(thenKeyword), 
        Syntax(unexpectedBetweenThenKeywordAndExpression), 
        Syntax(expression), 
        Syntax(unexpectedAfterExpression)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.thenStmt,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeThenKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(ThenStmtSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `then`.
  public var thenKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(ThenStmtSyntax.self)
    }
  }
  
  public var unexpectedBetweenThenKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(ThenStmtSyntax.self)
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(ThenStmtSyntax.self)
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(ThenStmtSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeThenKeyword, 
        \Self.thenKeyword, 
        \Self.unexpectedBetweenThenKeywordAndExpression, 
        \Self.expression, 
        \Self.unexpectedAfterExpression
      ])
}

// MARK: - ThrowStmtSyntax

/// ### Children
/// 
///  - `throwKeyword`: `throw`
///  - `expression`: ``ExprSyntax``
public struct ThrowStmtSyntax: StmtSyntaxProtocol, SyntaxHashable, _LeafStmtSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .throwStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeThrowKeyword: UnexpectedNodesSyntax? = nil,
      throwKeyword: TokenSyntax = .keyword(.throw),
      _ unexpectedBetweenThrowKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeThrowKeyword), 
        Syntax(throwKeyword), 
        Syntax(unexpectedBetweenThrowKeywordAndExpression), 
        Syntax(expression), 
        Syntax(unexpectedAfterExpression)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.throwStmt,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeThrowKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(ThrowStmtSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `throw`.
  public var throwKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(ThrowStmtSyntax.self)
    }
  }
  
  public var unexpectedBetweenThrowKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(ThrowStmtSyntax.self)
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(ThrowStmtSyntax.self)
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(ThrowStmtSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeThrowKeyword, 
        \Self.throwKeyword, 
        \Self.unexpectedBetweenThrowKeywordAndExpression, 
        \Self.expression, 
        \Self.unexpectedAfterExpression
      ])
}

// MARK: - ThrowsClauseSyntax

/// ### Children
/// 
///  - `throwsSpecifier`: (`throws` | `rethrows`)
///  - `leftParen`: `(`?
///  - `type`: ``TypeSyntax``?
///  - `rightParen`: `)`?
///
/// ### Contained in
/// 
///  - ``AccessorEffectSpecifiersSyntax``.``AccessorEffectSpecifiersSyntax/throwsClause``
///  - ``DoStmtSyntax``.``DoStmtSyntax/throwsClause``
///  - ``FunctionEffectSpecifiersSyntax``.``FunctionEffectSpecifiersSyntax/throwsClause``
///  - ``TypeEffectSpecifiersSyntax``.``TypeEffectSpecifiersSyntax/throwsClause``
public struct ThrowsClauseSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .throwsClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - throwsSpecifier: The `throws` keyword.
  ///   - leftParen: The '(' to open the thrown error type specification.
  ///   - type: The thrown error type.
  ///   - rightParen: The ')' to close the thrown error type specification.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeThrowsSpecifier: UnexpectedNodesSyntax? = nil,
      throwsSpecifier: TokenSyntax,
      _ unexpectedBetweenThrowsSpecifierAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndType: UnexpectedNodesSyntax? = nil,
      type: (some TypeSyntaxProtocol)? = TypeSyntax?.none,
      _ unexpectedBetweenTypeAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeThrowsSpecifier), 
        Syntax(throwsSpecifier), 
        Syntax(unexpectedBetweenThrowsSpecifierAndLeftParen), 
        Syntax(leftParen), 
        Syntax(unexpectedBetweenLeftParenAndType), 
        Syntax(type), 
        Syntax(unexpectedBetweenTypeAndRightParen), 
        Syntax(rightParen), 
        Syntax(unexpectedAfterRightParen)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.throwsClause,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeThrowsSpecifier: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  /// The `throws` keyword.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `throws`
  ///  - `rethrows`
  public var throwsSpecifier: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  public var unexpectedBetweenThrowsSpecifierAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  /// The '(' to open the thrown error type specification.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `(`.
  public var leftParen: TokenSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  public var unexpectedBetweenLeftParenAndType: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  /// The thrown error type.
  public var type: TypeSyntax? {
    get {
      return Syntax(self).child(at: 5)?.cast(TypeSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  public var unexpectedBetweenTypeAndRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  /// The ')' to close the thrown error type specification.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `)`.
  public var rightParen: TokenSyntax? {
    get {
      return Syntax(self).child(at: 7)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(ThrowsClauseSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeThrowsSpecifier, 
        \Self.throwsSpecifier, 
        \Self.unexpectedBetweenThrowsSpecifierAndLeftParen, 
        \Self.leftParen, 
        \Self.unexpectedBetweenLeftParenAndType, 
        \Self.type, 
        \Self.unexpectedBetweenTypeAndRightParen, 
        \Self.rightParen, 
        \Self.unexpectedAfterRightParen
      ])
}

// MARK: - TryExprSyntax

/// An expression prefixed with `try`.
/// 
/// ### Examples
/// 
/// ```swift
/// try foo()
/// ```
/// 
/// ```swift
/// try? foo()
/// ```
/// 
/// ```swift
/// try! foo()
/// ```
///
/// ### Children
/// 
///  - `tryKeyword`: `try`
///  - `questionOrExclamationMark`: (`?` | `!`)?
///  - `expression`: ``ExprSyntax``
public struct TryExprSyntax: ExprSyntaxProtocol, SyntaxHashable, _LeafExprSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .tryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeTryKeyword: UnexpectedNodesSyntax? = nil,
      tryKeyword: TokenSyntax = .keyword(.try),
      _ unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeTryKeyword), 
        Syntax(tryKeyword), 
        Syntax(unexpectedBetweenTryKeywordAndQuestionOrExclamationMark), 
        Syntax(questionOrExclamationMark), 
        Syntax(unexpectedBetweenQuestionOrExclamationMarkAndExpression), 
        Syntax(expression), 
        Syntax(unexpectedAfterExpression)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tryExpr,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeTryKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TryExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `try`.
  public var tryKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TryExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `?`
  ///  - `!`
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TryExprSyntax.self)
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TryExprSyntax.self)
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TryExprSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeTryKeyword, 
        \Self.tryKeyword, 
        \Self.unexpectedBetweenTryKeywordAndQuestionOrExclamationMark, 
        \Self.questionOrExclamationMark, 
        \Self.unexpectedBetweenQuestionOrExclamationMarkAndExpression, 
        \Self.expression, 
        \Self.unexpectedAfterExpression
      ])
}

// MARK: - TupleExprSyntax

/// ### Children
/// 
///  - `leftParen`: `(`
///  - `elements`: ``LabeledExprListSyntax``
///  - `rightParen`: `)`
public struct TupleExprSyntax: ExprSyntaxProtocol, SyntaxHashable, _LeafExprSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .tupleExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? = nil,
      elements: LabeledExprListSyntax,
      _ unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeLeftParen), 
        Syntax(leftParen), 
        Syntax(unexpectedBetweenLeftParenAndElements), 
        Syntax(elements), 
        Syntax(unexpectedBetweenElementsAndRightParen), 
        Syntax(rightParen), 
        Syntax(unexpectedAfterRightParen)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tupleExpr,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TupleExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `(`.
  public var leftParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TupleExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TupleExprSyntax.self)
    }
  }
  
  public var elements: LabeledExprListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(LabeledExprListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TupleExprSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  ///
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  @available(*, deprecated, message: "Use node.elements.append(newElement) instead")
  public func addElement(_ element: LabeledExprSyntax) -> TupleExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.labeledExprList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(TupleExprSyntax.self)
  }
  
  public var unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TupleExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `)`.
  public var rightParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TupleExprSyntax.self)
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TupleExprSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeLeftParen, 
        \Self.leftParen, 
        \Self.unexpectedBetweenLeftParenAndElements, 
        \Self.elements, 
        \Self.unexpectedBetweenElementsAndRightParen, 
        \Self.rightParen, 
        \Self.unexpectedAfterRightParen
      ])
}

// MARK: - TuplePatternElementSyntax

/// An element that represents a single tuple value in ``TuplePatternElementListSyntax``.
///
/// ### Children
/// 
///  - `label`: `<identifier>`?
///  - `colon`: `:`?
///  - `pattern`: ``PatternSyntax``
///  - `trailingComma`: `,`?
///
/// ### Contained in
/// 
///  - ``TuplePatternElementListSyntax``
public struct TuplePatternElementSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .tuplePatternElement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - label: The label of the pattern.
  ///   - colon: The colon separating label and pattern.
  ///   - pattern: The value of this labeled pattern.
  ///   - trailingComma: The comma separating elements.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLabel: UnexpectedNodesSyntax? = nil,
      label: TokenSyntax? = nil,
      _ unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax? = nil,
      _ unexpectedBetweenColonAndPattern: UnexpectedNodesSyntax? = nil,
      pattern: some PatternSyntaxProtocol,
      _ unexpectedBetweenPatternAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeLabel), 
        Syntax(label), 
        Syntax(unexpectedBetweenLabelAndColon), 
        Syntax(colon), 
        Syntax(unexpectedBetweenColonAndPattern), 
        Syntax(pattern), 
        Syntax(unexpectedBetweenPatternAndTrailingComma), 
        Syntax(trailingComma), 
        Syntax(unexpectedAfterTrailingComma)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tuplePatternElement,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeLabel: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  /// The label of the pattern.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `<identifier>`.
  public var label: TokenSyntax? {
    get {
      return Syntax(self).child(at: 1)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  /// The colon separating label and pattern.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `:`.
  public var colon: TokenSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenColonAndPattern: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  /// The value of this labeled pattern.
  public var pattern: PatternSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(PatternSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenPatternAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  /// The comma separating elements.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `,`.
  public var trailingComma: TokenSyntax? {
    get {
      return Syntax(self).child(at: 7)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternElementSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeLabel, 
        \Self.label, 
        \Self.unexpectedBetweenLabelAndColon, 
        \Self.colon, 
        \Self.unexpectedBetweenColonAndPattern, 
        \Self.pattern, 
        \Self.unexpectedBetweenPatternAndTrailingComma, 
        \Self.trailingComma, 
        \Self.unexpectedAfterTrailingComma
      ])
}

// MARK: - TuplePatternSyntax

/// A pattern that contains a list of other pattern.
/// 
/// ### Examples
/// 
/// ``TuplePatternSyntax`` can be used in more complex variable declarations.
/// For example `(x, y)` in the example:
/// 
/// ```swift
/// let (x, y) = (1, 2)
/// ```
///
/// ### Children
/// 
///  - `leftParen`: `(`
///  - `elements`: ``TuplePatternElementListSyntax``
///  - `rightParen`: `)`
public struct TuplePatternSyntax: PatternSyntaxProtocol, SyntaxHashable, _LeafPatternSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .tuplePattern else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - leftParen: The parent introducing the tuple.
  ///   - rightParen: The paren closing the tuple.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? = nil,
      elements: TuplePatternElementListSyntax,
      _ unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeLeftParen), 
        Syntax(leftParen), 
        Syntax(unexpectedBetweenLeftParenAndElements), 
        Syntax(elements), 
        Syntax(unexpectedBetweenElementsAndRightParen), 
        Syntax(rightParen), 
        Syntax(unexpectedAfterRightParen)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tuplePattern,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternSyntax.self)
    }
  }
  
  /// The parent introducing the tuple.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `(`.
  public var leftParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternSyntax.self)
    }
  }
  
  public var unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternSyntax.self)
    }
  }
  
  public var elements: TuplePatternElementListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TuplePatternElementListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  ///
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  @available(*, deprecated, message: "Use node.elements.append(newElement) instead")
  public func addElement(_ element: TuplePatternElementSyntax) -> TuplePatternSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tuplePatternElementList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(TuplePatternSyntax.self)
  }
  
  public var unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternSyntax.self)
    }
  }
  
  /// The paren closing the tuple.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `)`.
  public var rightParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternSyntax.self)
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TuplePatternSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeLeftParen, 
        \Self.leftParen, 
        \Self.unexpectedBetweenLeftParenAndElements, 
        \Self.elements, 
        \Self.unexpectedBetweenElementsAndRightParen, 
        \Self.rightParen, 
        \Self.unexpectedAfterRightParen
      ])
}

// MARK: - TupleTypeElementSyntax

/// ### Children
/// 
///  - `inoutKeyword`: `inout`?
///  - `firstName`: (`<identifier>` | `_`)?
///  - `secondName`: (`<identifier>` | `_`)?
///  - `colon`: `:`?
///  - `type`: ``TypeSyntax``
///  - `ellipsis`: `...`?
///  - `trailingComma`: `,`?
///
/// ### Contained in
/// 
///  - ``TupleTypeElementListSyntax``
public struct TupleTypeElementSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .tupleTypeElement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeInoutKeyword: UnexpectedNodesSyntax? = nil,
      inoutKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenInoutKeywordAndFirstName: UnexpectedNodesSyntax? = nil,
      firstName: TokenSyntax? = nil,
      _ unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? = nil,
      secondName: TokenSyntax? = nil,
      _ unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax? = nil,
      _ unexpectedBetweenColonAndType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedBetweenTypeAndEllipsis: UnexpectedNodesSyntax? = nil,
      ellipsis: TokenSyntax? = nil,
      _ unexpectedBetweenEllipsisAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeInoutKeyword), 
        Syntax(inoutKeyword), 
        Syntax(unexpectedBetweenInoutKeywordAndFirstName), 
        Syntax(firstName), 
        Syntax(unexpectedBetweenFirstNameAndSecondName), 
        Syntax(secondName), 
        Syntax(unexpectedBetweenSecondNameAndColon), 
        Syntax(colon), 
        Syntax(unexpectedBetweenColonAndType), 
        Syntax(type), 
        Syntax(unexpectedBetweenTypeAndEllipsis), 
        Syntax(ellipsis), 
        Syntax(unexpectedBetweenEllipsisAndTrailingComma), 
        Syntax(trailingComma), 
        Syntax(unexpectedAfterTrailingComma)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tupleTypeElement,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeInoutKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `inout`.
  public var inoutKeyword: TokenSyntax? {
    get {
      return Syntax(self).child(at: 1)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenInoutKeywordAndFirstName: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `<identifier>`
  ///  - `_`
  public var firstName: TokenSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `<identifier>`
  ///  - `_`
  public var secondName: TokenSyntax? {
    get {
      return Syntax(self).child(at: 5)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `:`.
  public var colon: TokenSyntax? {
    get {
      return Syntax(self).child(at: 7)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenColonAndType: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var type: TypeSyntax {
    get {
      return Syntax(self).child(at: 9)!.cast(TypeSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 9, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenTypeAndEllipsis: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 10)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 10, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `...`.
  public var ellipsis: TokenSyntax? {
    get {
      return Syntax(self).child(at: 11)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 11, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var unexpectedBetweenEllipsisAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 12)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 12, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `,`.
  public var trailingComma: TokenSyntax? {
    get {
      return Syntax(self).child(at: 13)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 13, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 14)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 14, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeElementSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeInoutKeyword, 
        \Self.inoutKeyword, 
        \Self.unexpectedBetweenInoutKeywordAndFirstName, 
        \Self.firstName, 
        \Self.unexpectedBetweenFirstNameAndSecondName, 
        \Self.secondName, 
        \Self.unexpectedBetweenSecondNameAndColon, 
        \Self.colon, 
        \Self.unexpectedBetweenColonAndType, 
        \Self.type, 
        \Self.unexpectedBetweenTypeAndEllipsis, 
        \Self.ellipsis, 
        \Self.unexpectedBetweenEllipsisAndTrailingComma, 
        \Self.trailingComma, 
        \Self.unexpectedAfterTrailingComma
      ])
}

// MARK: - TupleTypeSyntax

/// ### Children
/// 
///  - `leftParen`: `(`
///  - `elements`: ``TupleTypeElementListSyntax``
///  - `rightParen`: `)`
public struct TupleTypeSyntax: TypeSyntaxProtocol, SyntaxHashable, _LeafTypeSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .tupleType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? = nil,
      elements: TupleTypeElementListSyntax,
      _ unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeLeftParen), 
        Syntax(leftParen), 
        Syntax(unexpectedBetweenLeftParenAndElements), 
        Syntax(elements), 
        Syntax(unexpectedBetweenElementsAndRightParen), 
        Syntax(rightParen), 
        Syntax(unexpectedAfterRightParen)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tupleType,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `(`.
  public var leftParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeSyntax.self)
    }
  }
  
  public var unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeSyntax.self)
    }
  }
  
  public var elements: TupleTypeElementListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TupleTypeElementListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  ///
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  @available(*, deprecated, message: "Use node.elements.append(newElement) instead")
  public func addElement(_ element: TupleTypeElementSyntax) -> TupleTypeSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleTypeElementList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(TupleTypeSyntax.self)
  }
  
  public var unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `)`.
  public var rightParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeSyntax.self)
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TupleTypeSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeLeftParen, 
        \Self.leftParen, 
        \Self.unexpectedBetweenLeftParenAndElements, 
        \Self.elements, 
        \Self.unexpectedBetweenElementsAndRightParen, 
        \Self.rightParen, 
        \Self.unexpectedAfterRightParen
      ])
}

// MARK: - TypeAliasDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `typealiasKeyword`: `typealias`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `initializer`: ``TypeInitializerClauseSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
public struct TypeAliasDeclSyntax: DeclSyntaxProtocol, SyntaxHashable, _LeafDeclSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .typeAliasDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericParameterClause: The parameter clause that defines the generic parameters.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndTypealiasKeyword: UnexpectedNodesSyntax? = nil,
      typealiasKeyword: TokenSyntax = .keyword(.typealias),
      _ unexpectedBetweenTypealiasKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInitializer: UnexpectedNodesSyntax? = nil,
      initializer: TypeInitializerClauseSyntax,
      _ unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeAttributes), 
        Syntax(attributes), 
        Syntax(unexpectedBetweenAttributesAndModifiers), 
        Syntax(modifiers), 
        Syntax(unexpectedBetweenModifiersAndTypealiasKeyword), 
        Syntax(typealiasKeyword), 
        Syntax(unexpectedBetweenTypealiasKeywordAndName), 
        Syntax(name), 
        Syntax(unexpectedBetweenNameAndGenericParameterClause), 
        Syntax(genericParameterClause), 
        Syntax(unexpectedBetweenGenericParameterClauseAndInitializer), 
        Syntax(initializer), 
        Syntax(unexpectedBetweenInitializerAndGenericWhereClause), 
        Syntax(genericWhereClause), 
        Syntax(unexpectedAfterGenericWhereClause)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeAliasDecl,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(AttributeListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> TypeAliasDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(TypeAliasDeclSyntax.self)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var modifiers: DeclModifierListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(DeclModifierListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> TypeAliasDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(TypeAliasDeclSyntax.self)
  }
  
  public var unexpectedBetweenModifiersAndTypealiasKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `typealias`.
  public var typealiasKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var unexpectedBetweenTypealiasKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `<identifier>`.
  public var name: TokenSyntax {
    get {
      return Syntax(self).child(at: 7)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  /// The parameter clause that defines the generic parameters.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return Syntax(self).child(at: 9)?.cast(GenericParameterClauseSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 9, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInitializer: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 10)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 10, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var initializer: TypeInitializerClauseSyntax {
    get {
      return Syntax(self).child(at: 11)!.cast(TypeInitializerClauseSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 11, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 12)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 12, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return Syntax(self).child(at: 13)?.cast(GenericWhereClauseSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 13, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public var unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 14)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 14, with: Syntax(value), arena: SyntaxArena()).cast(TypeAliasDeclSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeAttributes, 
        \Self.attributes, 
        \Self.unexpectedBetweenAttributesAndModifiers, 
        \Self.modifiers, 
        \Self.unexpectedBetweenModifiersAndTypealiasKeyword, 
        \Self.typealiasKeyword, 
        \Self.unexpectedBetweenTypealiasKeywordAndName, 
        \Self.name, 
        \Self.unexpectedBetweenNameAndGenericParameterClause, 
        \Self.genericParameterClause, 
        \Self.unexpectedBetweenGenericParameterClauseAndInitializer, 
        \Self.initializer, 
        \Self.unexpectedBetweenInitializerAndGenericWhereClause, 
        \Self.genericWhereClause, 
        \Self.unexpectedAfterGenericWhereClause
      ])
}

// MARK: - TypeAnnotationSyntax

/// ### Children
/// 
///  - `colon`: `:`
///  - `type`: ``TypeSyntax``
///
/// ### Contained in
/// 
///  - ``ForStmtSyntax``.``ForStmtSyntax/typeAnnotation``
///  - ``MatchingPatternConditionSyntax``.``MatchingPatternConditionSyntax/typeAnnotation``
///  - ``OptionalBindingConditionSyntax``.``OptionalBindingConditionSyntax/typeAnnotation``
///  - ``PatternBindingSyntax``.``PatternBindingSyntax/typeAnnotation``
public struct TypeAnnotationSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .typeAnnotation else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - colon: The colon separating previous pattern and the type.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedAfterType: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeColon), 
        Syntax(colon), 
        Syntax(unexpectedBetweenColonAndType), 
        Syntax(type), 
        Syntax(unexpectedAfterType)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeAnnotation,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TypeAnnotationSyntax.self)
    }
  }
  
  /// The colon separating previous pattern and the type.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `:`.
  public var colon: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TypeAnnotationSyntax.self)
    }
  }
  
  public var unexpectedBetweenColonAndType: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TypeAnnotationSyntax.self)
    }
  }
  
  public var type: TypeSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TypeSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TypeAnnotationSyntax.self)
    }
  }
  
  public var unexpectedAfterType: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TypeAnnotationSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeColon, 
        \Self.colon, 
        \Self.unexpectedBetweenColonAndType, 
        \Self.type, 
        \Self.unexpectedAfterType
      ])
}

// MARK: - TypeEffectSpecifiersSyntax

/// ### Children
/// 
///  - `asyncSpecifier`: `async`?
///  - `throwsClause`: ``ThrowsClauseSyntax``?
///
/// ### Contained in
/// 
///  - ``ArrowExprSyntax``.``ArrowExprSyntax/effectSpecifiers``
///  - ``ClosureSignatureSyntax``.``ClosureSignatureSyntax/effectSpecifiers``
///  - ``FunctionTypeSyntax``.``FunctionTypeSyntax/effectSpecifiers``
public struct TypeEffectSpecifiersSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .typeEffectSpecifiers else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - throwsClause: The clause specifying thrown errors
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAsyncSpecifier: UnexpectedNodesSyntax? = nil,
      asyncSpecifier: TokenSyntax? = nil,
      _ unexpectedBetweenAsyncSpecifierAndThrowsClause: UnexpectedNodesSyntax? = nil,
      throwsClause: ThrowsClauseSyntax? = nil,
      _ unexpectedAfterThrowsClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeAsyncSpecifier), 
        Syntax(asyncSpecifier), 
        Syntax(unexpectedBetweenAsyncSpecifierAndThrowsClause), 
        Syntax(throwsClause), 
        Syntax(unexpectedAfterThrowsClause)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeEffectSpecifiers,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeAsyncSpecifier: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TypeEffectSpecifiersSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `async`.
  public var asyncSpecifier: TokenSyntax? {
    get {
      return Syntax(self).child(at: 1)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TypeEffectSpecifiersSyntax.self)
    }
  }
  
  public var unexpectedBetweenAsyncSpecifierAndThrowsClause: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TypeEffectSpecifiersSyntax.self)
    }
  }
  
  /// The clause specifying thrown errors
  public var throwsClause: ThrowsClauseSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(ThrowsClauseSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TypeEffectSpecifiersSyntax.self)
    }
  }
  
  public var unexpectedAfterThrowsClause: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TypeEffectSpecifiersSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeAsyncSpecifier, 
        \Self.asyncSpecifier, 
        \Self.unexpectedBetweenAsyncSpecifierAndThrowsClause, 
        \Self.throwsClause, 
        \Self.unexpectedAfterThrowsClause
      ])
}

// MARK: - TypeExprSyntax

/// ### Children
/// 
///  - `type`: ``TypeSyntax``
public struct TypeExprSyntax: ExprSyntaxProtocol, SyntaxHashable, _LeafExprSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .typeExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedAfterType: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [Syntax(unexpectedBeforeType), Syntax(type), Syntax(unexpectedAfterType)]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeExpr,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeType: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TypeExprSyntax.self)
    }
  }
  
  public var type: TypeSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TypeSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TypeExprSyntax.self)
    }
  }
  
  public var unexpectedAfterType: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TypeExprSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([\Self.unexpectedBeforeType, \Self.type, \Self.unexpectedAfterType])
}

// MARK: - TypeInitializerClauseSyntax

/// ### Children
/// 
///  - `equal`: `=`
///  - `value`: ``TypeSyntax``
///
/// ### Contained in
/// 
///  - ``AssociatedTypeDeclSyntax``.``AssociatedTypeDeclSyntax/initializer``
///  - ``TypeAliasDeclSyntax``.``TypeAliasDeclSyntax/initializer``
public struct TypeInitializerClauseSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .typeInitializerClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEqual: UnexpectedNodesSyntax? = nil,
      equal: TokenSyntax = .equalToken(),
      _ unexpectedBetweenEqualAndValue: UnexpectedNodesSyntax? = nil,
      value: some TypeSyntaxProtocol,
      _ unexpectedAfterValue: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeEqual), 
        Syntax(equal), 
        Syntax(unexpectedBetweenEqualAndValue), 
        Syntax(value), 
        Syntax(unexpectedAfterValue)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeInitializerClause,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeEqual: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(TypeInitializerClauseSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `=`.
  public var equal: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(TypeInitializerClauseSyntax.self)
    }
  }
  
  public var unexpectedBetweenEqualAndValue: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(TypeInitializerClauseSyntax.self)
    }
  }
  
  public var value: TypeSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TypeSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(TypeInitializerClauseSyntax.self)
    }
  }
  
  public var unexpectedAfterValue: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(TypeInitializerClauseSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeEqual, 
        \Self.equal, 
        \Self.unexpectedBetweenEqualAndValue, 
        \Self.value, 
        \Self.unexpectedAfterValue
      ])
}

// MARK: - UnavailableFromAsyncAttributeArgumentsSyntax

/// The arguments for the '@_unavailableFromAsync' attribute
///
/// ### Children
/// 
///  - `messageLabel`: `message`
///  - `colon`: `:`
///  - `message`: ``StringLiteralExprSyntax``
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct UnavailableFromAsyncAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .unavailableFromAsyncAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeMessageLabel: UnexpectedNodesSyntax? = nil,
      messageLabel: TokenSyntax = .keyword(.message),
      _ unexpectedBetweenMessageLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndMessage: UnexpectedNodesSyntax? = nil,
      message: StringLiteralExprSyntax,
      _ unexpectedAfterMessage: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeMessageLabel), 
        Syntax(messageLabel), 
        Syntax(unexpectedBetweenMessageLabelAndColon), 
        Syntax(colon), 
        Syntax(unexpectedBetweenColonAndMessage), 
        Syntax(message), 
        Syntax(unexpectedAfterMessage)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unavailableFromAsyncAttributeArguments,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeMessageLabel: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(UnavailableFromAsyncAttributeArgumentsSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `message`.
  public var messageLabel: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(UnavailableFromAsyncAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenMessageLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(UnavailableFromAsyncAttributeArgumentsSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `:`.
  public var colon: TokenSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(UnavailableFromAsyncAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenColonAndMessage: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(UnavailableFromAsyncAttributeArgumentsSyntax.self)
    }
  }
  
  public var message: StringLiteralExprSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(StringLiteralExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(UnavailableFromAsyncAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedAfterMessage: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(UnavailableFromAsyncAttributeArgumentsSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeMessageLabel, 
        \Self.messageLabel, 
        \Self.unexpectedBetweenMessageLabelAndColon, 
        \Self.colon, 
        \Self.unexpectedBetweenColonAndMessage, 
        \Self.message, 
        \Self.unexpectedAfterMessage
      ])
}

// MARK: - UnderscorePrivateAttributeArgumentsSyntax

/// The arguments for the '@_private' attribute
///
/// ### Children
/// 
///  - `sourceFileLabel`: `sourceFile`
///  - `colon`: `:`
///  - `filename`: ``StringLiteralExprSyntax``
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct UnderscorePrivateAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .underscorePrivateAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeSourceFileLabel: UnexpectedNodesSyntax? = nil,
      sourceFileLabel: TokenSyntax = .keyword(.sourceFile),
      _ unexpectedBetweenSourceFileLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndFilename: UnexpectedNodesSyntax? = nil,
      filename: StringLiteralExprSyntax,
      _ unexpectedAfterFilename: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeSourceFileLabel), 
        Syntax(sourceFileLabel), 
        Syntax(unexpectedBetweenSourceFileLabelAndColon), 
        Syntax(colon), 
        Syntax(unexpectedBetweenColonAndFilename), 
        Syntax(filename), 
        Syntax(unexpectedAfterFilename)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.underscorePrivateAttributeArguments,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeSourceFileLabel: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(UnderscorePrivateAttributeArgumentsSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `sourceFile`.
  public var sourceFileLabel: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(UnderscorePrivateAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenSourceFileLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(UnderscorePrivateAttributeArgumentsSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `:`.
  public var colon: TokenSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(UnderscorePrivateAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenColonAndFilename: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(UnderscorePrivateAttributeArgumentsSyntax.self)
    }
  }
  
  public var filename: StringLiteralExprSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(StringLiteralExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(UnderscorePrivateAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedAfterFilename: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(UnderscorePrivateAttributeArgumentsSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeSourceFileLabel, 
        \Self.sourceFileLabel, 
        \Self.unexpectedBetweenSourceFileLabelAndColon, 
        \Self.colon, 
        \Self.unexpectedBetweenColonAndFilename, 
        \Self.filename, 
        \Self.unexpectedAfterFilename
      ])
}

// MARK: - UnresolvedAsExprSyntax

/// The `as` keyword without any operands.
/// 
/// - Note: The parser does not know the precedences of operators and thus represents `as` by an ``UnresolvedAsExprSyntax``.
///   After operator folding using the `SwiftOperators` library, this gets translated to an ``AsExprSyntax``.
///
/// ### Children
/// 
///  - `asKeyword`: `as`
///  - `questionOrExclamationMark`: (`?` | `!`)?
public struct UnresolvedAsExprSyntax: ExprSyntaxProtocol, SyntaxHashable, _LeafExprSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .unresolvedAsExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAsKeyword: UnexpectedNodesSyntax? = nil,
      asKeyword: TokenSyntax = .keyword(.as),
      _ unexpectedBetweenAsKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedAfterQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeAsKeyword), 
        Syntax(asKeyword), 
        Syntax(unexpectedBetweenAsKeywordAndQuestionOrExclamationMark), 
        Syntax(questionOrExclamationMark), 
        Syntax(unexpectedAfterQuestionOrExclamationMark)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedAsExpr,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeAsKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedAsExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `as`.
  public var asKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedAsExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenAsKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedAsExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `?`
  ///  - `!`
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedAsExprSyntax.self)
    }
  }
  
  public var unexpectedAfterQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedAsExprSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeAsKeyword, 
        \Self.asKeyword, 
        \Self.unexpectedBetweenAsKeywordAndQuestionOrExclamationMark, 
        \Self.questionOrExclamationMark, 
        \Self.unexpectedAfterQuestionOrExclamationMark
      ])
}

// MARK: - UnresolvedIsExprSyntax

/// The `is` keyword without any operands.
/// 
/// - Note: The parser does not know the precedences of operators and thus represents `is` by an ``UnresolvedIsExprSyntax``.
///   After operator folding using the `SwiftOperators` library, this gets translated to an ``IsExprSyntax``.
///
/// ### Children
/// 
///  - `isKeyword`: `is`
public struct UnresolvedIsExprSyntax: ExprSyntaxProtocol, SyntaxHashable, _LeafExprSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .unresolvedIsExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIsKeyword: UnexpectedNodesSyntax? = nil,
      isKeyword: TokenSyntax = .keyword(.is),
      _ unexpectedAfterIsKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [Syntax(unexpectedBeforeIsKeyword), Syntax(isKeyword), Syntax(unexpectedAfterIsKeyword)]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedIsExpr,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeIsKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedIsExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `is`.
  public var isKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedIsExprSyntax.self)
    }
  }
  
  public var unexpectedAfterIsKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedIsExprSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([\Self.unexpectedBeforeIsKeyword, \Self.isKeyword, \Self.unexpectedAfterIsKeyword])
}

// MARK: - UnresolvedTernaryExprSyntax

/// The middle section of a ternary operator between `?` and `:`.
/// 
/// - Note: The parser does not know the precedences of operators and thus represents the 
///   middle section of a ternary operator by an ``UnresolvedTernaryExprSyntax``.
///   After operator folding using the `SwiftOperators` library, this gets translated to an ``TernaryExprSyntax``.
///
/// ### Children
/// 
///  - `questionMark`: `?`
///  - `thenExpression`: ``ExprSyntax``
///  - `colon`: `:`
public struct UnresolvedTernaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable, _LeafExprSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .unresolvedTernaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .infixQuestionMarkToken(),
      _ unexpectedBetweenQuestionMarkAndThenExpression: UnexpectedNodesSyntax? = nil,
      thenExpression: some ExprSyntaxProtocol,
      _ unexpectedBetweenThenExpressionAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedAfterColon: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeQuestionMark), 
        Syntax(questionMark), 
        Syntax(unexpectedBetweenQuestionMarkAndThenExpression), 
        Syntax(thenExpression), 
        Syntax(unexpectedBetweenThenExpressionAndColon), 
        Syntax(colon), 
        Syntax(unexpectedAfterColon)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedTernaryExpr,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeQuestionMark: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedTernaryExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `?`.
  public var questionMark: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedTernaryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenQuestionMarkAndThenExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedTernaryExprSyntax.self)
    }
  }
  
  public var thenExpression: ExprSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedTernaryExprSyntax.self)
    }
  }
  
  public var unexpectedBetweenThenExpressionAndColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedTernaryExprSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `:`.
  public var colon: TokenSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedTernaryExprSyntax.self)
    }
  }
  
  public var unexpectedAfterColon: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(UnresolvedTernaryExprSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeQuestionMark, 
        \Self.questionMark, 
        \Self.unexpectedBetweenQuestionMarkAndThenExpression, 
        \Self.thenExpression, 
        \Self.unexpectedBetweenThenExpressionAndColon, 
        \Self.colon, 
        \Self.unexpectedAfterColon
      ])
}

// MARK: - ValueBindingPatternSyntax

/// ### Children
/// 
///  - `bindingSpecifier`: (`let` | `var` | `inout` | `_mutating` | `_borrowing` | `_consuming` | `borrowing`)
///  - `pattern`: ``PatternSyntax``
public struct ValueBindingPatternSyntax: PatternSyntaxProtocol, SyntaxHashable, _LeafPatternSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .valueBindingPattern else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBindingSpecifier: UnexpectedNodesSyntax? = nil,
      bindingSpecifier: TokenSyntax,
      _ unexpectedBetweenBindingSpecifierAndPattern: UnexpectedNodesSyntax? = nil,
      pattern: some PatternSyntaxProtocol,
      _ unexpectedAfterPattern: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeBindingSpecifier), 
        Syntax(bindingSpecifier), 
        Syntax(unexpectedBetweenBindingSpecifierAndPattern), 
        Syntax(pattern), 
        Syntax(unexpectedAfterPattern)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.valueBindingPattern,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeBindingSpecifier: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(ValueBindingPatternSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `let`
  ///  - `var`
  ///  - `inout`
  ///  - `_mutating`
  ///  - `_borrowing`
  ///  - `_consuming`
  ///  - `borrowing`
  public var bindingSpecifier: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(ValueBindingPatternSyntax.self)
    }
  }
  
  public var unexpectedBetweenBindingSpecifierAndPattern: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(ValueBindingPatternSyntax.self)
    }
  }
  
  public var pattern: PatternSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(PatternSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(ValueBindingPatternSyntax.self)
    }
  }
  
  public var unexpectedAfterPattern: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(ValueBindingPatternSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeBindingSpecifier, 
        \Self.bindingSpecifier, 
        \Self.unexpectedBetweenBindingSpecifierAndPattern, 
        \Self.pattern, 
        \Self.unexpectedAfterPattern
      ])
}

// MARK: - VariableDeclSyntax

/// Declaration of one or more variables
/// 
/// The core of a variable declaration consists of a binding specifier (`let` or `var`),
/// followed by any number of pattern bindings, which define the variables.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `bindingSpecifier`: (`let` | `var` | `inout` | `_mutating` | `_borrowing` | `_consuming`)
///  - `bindings`: ``PatternBindingListSyntax``
public struct VariableDeclSyntax: DeclSyntaxProtocol, SyntaxHashable, _LeafDeclSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .variableDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - modifiers: Modifiers modifiers applied to the variable declaration.
  ///   - bindingSpecifier: The specifier that defines the type of the variables declared (`let` or `var`).
  ///   - bindings: The pattern bindings that define the actual variables.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndBindingSpecifier: UnexpectedNodesSyntax? = nil,
      bindingSpecifier: TokenSyntax,
      _ unexpectedBetweenBindingSpecifierAndBindings: UnexpectedNodesSyntax? = nil,
      bindings: PatternBindingListSyntax,
      _ unexpectedAfterBindings: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeAttributes), 
        Syntax(attributes), 
        Syntax(unexpectedBetweenAttributesAndModifiers), 
        Syntax(modifiers), 
        Syntax(unexpectedBetweenModifiersAndBindingSpecifier), 
        Syntax(bindingSpecifier), 
        Syntax(unexpectedBetweenBindingSpecifierAndBindings), 
        Syntax(bindings), 
        Syntax(unexpectedAfterBindings)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.variableDecl,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(AttributeListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(VariableDeclSyntax.self)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  /// Modifiers modifiers applied to the variable declaration.
  public var modifiers: DeclModifierListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(DeclModifierListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(VariableDeclSyntax.self)
  }
  
  public var unexpectedBetweenModifiersAndBindingSpecifier: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  /// The specifier that defines the type of the variables declared (`let` or `var`).
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `let`
  ///  - `var`
  ///  - `inout`
  ///  - `_mutating`
  ///  - `_borrowing`
  ///  - `_consuming`
  public var bindingSpecifier: TokenSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  public var unexpectedBetweenBindingSpecifierAndBindings: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  /// The pattern bindings that define the actual variables.
  /// 
  /// The pattern bindings contain the declared variables’ names, their types,
  /// initializers and accessors.
  /// 
  /// A variable declaration can contain multiple pattern bindings, because it’s possible
  /// to define multiple variables after a single `let` keyword, for example
  /// 
  /// ```swift
  /// let x: Int = 1, y: Int = 2
  /// ```
  public var bindings: PatternBindingListSyntax {
    get {
      return Syntax(self).child(at: 7)!.cast(PatternBindingListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `bindings`
  /// collection.
  ///
  /// - param element: The new `Binding` to add to the node's
  ///                  `bindings` collection.
  /// - returns: A copy of the receiver with the provided `Binding`
  ///            appended to its `bindings` collection.
  @available(*, deprecated, message: "Use node.bindings.append(newElement) instead")
  public func addBinding(_ element: PatternBindingSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[7] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.patternBindingList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 7, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(VariableDeclSyntax.self)
  }
  
  public var unexpectedAfterBindings: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(VariableDeclSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeAttributes, 
        \Self.attributes, 
        \Self.unexpectedBetweenAttributesAndModifiers, 
        \Self.modifiers, 
        \Self.unexpectedBetweenModifiersAndBindingSpecifier, 
        \Self.bindingSpecifier, 
        \Self.unexpectedBetweenBindingSpecifierAndBindings, 
        \Self.bindings, 
        \Self.unexpectedAfterBindings
      ])
}

// MARK: - VersionComponentSyntax

/// An element to represent a single component in a version, like `.1`.
///
/// ### Children
/// 
///  - `period`: `.`
///  - `number`: `<integerLiteral>`
///
/// ### Contained in
/// 
///  - ``VersionComponentListSyntax``
public struct VersionComponentSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .versionComponent else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - period: The period of this version component.
  ///   - number: The version number of this component.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePeriod: UnexpectedNodesSyntax? = nil,
      period: TokenSyntax = .periodToken(),
      _ unexpectedBetweenPeriodAndNumber: UnexpectedNodesSyntax? = nil,
      number: TokenSyntax,
      _ unexpectedAfterNumber: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforePeriod), 
        Syntax(period), 
        Syntax(unexpectedBetweenPeriodAndNumber), 
        Syntax(number), 
        Syntax(unexpectedAfterNumber)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.versionComponent,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforePeriod: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(VersionComponentSyntax.self)
    }
  }
  
  /// The period of this version component.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `.`.
  public var period: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(VersionComponentSyntax.self)
    }
  }
  
  public var unexpectedBetweenPeriodAndNumber: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(VersionComponentSyntax.self)
    }
  }
  
  /// The version number of this component.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `<integerLiteral>`.
  public var number: TokenSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(VersionComponentSyntax.self)
    }
  }
  
  public var unexpectedAfterNumber: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(VersionComponentSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforePeriod, 
        \Self.period, 
        \Self.unexpectedBetweenPeriodAndNumber, 
        \Self.number, 
        \Self.unexpectedAfterNumber
      ])
}

// MARK: - VersionTupleSyntax

/// A version number like `1.2.0`. Only the first version component is required. There might be an arbitrary number of following components.
///
/// ### Children
/// 
///  - `major`: `<integerLiteral>`
///  - `components`: ``VersionComponentListSyntax``
///
/// ### Contained in
/// 
///  - ``AvailabilityLabeledArgumentSyntax``.``AvailabilityLabeledArgumentSyntax/value``
///  - `_CanImportVersionInfoSyntax`.`_CanImportVersionInfoSyntax/version`
///  - ``PlatformVersionSyntax``.``PlatformVersionSyntax/version``
public struct VersionTupleSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .versionTuple else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - major: The major version.
  ///   - components: Any version components that are not the major version . For example, for `1.2.0`, this will contain `.2.0`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeMajor: UnexpectedNodesSyntax? = nil,
      major: TokenSyntax,
      _ unexpectedBetweenMajorAndComponents: UnexpectedNodesSyntax? = nil,
      components: VersionComponentListSyntax,
      _ unexpectedAfterComponents: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeMajor), 
        Syntax(major), 
        Syntax(unexpectedBetweenMajorAndComponents), 
        Syntax(components), 
        Syntax(unexpectedAfterComponents)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.versionTuple,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeMajor: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(VersionTupleSyntax.self)
    }
  }
  
  /// The major version.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `<integerLiteral>`.
  public var major: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(VersionTupleSyntax.self)
    }
  }
  
  public var unexpectedBetweenMajorAndComponents: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(VersionTupleSyntax.self)
    }
  }
  
  /// Any version components that are not the major version . For example, for `1.2.0`, this will contain `.2.0`.
  public var components: VersionComponentListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(VersionComponentListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(VersionTupleSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `components`
  /// collection.
  ///
  /// - param element: The new `VersionComponent` to add to the node's
  ///                  `components` collection.
  /// - returns: A copy of the receiver with the provided `VersionComponent`
  ///            appended to its `components` collection.
  @available(*, deprecated, message: "Use node.components.append(newElement) instead")
  public func addVersionComponent(_ element: VersionComponentSyntax) -> VersionTupleSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.versionComponentList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(VersionTupleSyntax.self)
  }
  
  public var unexpectedAfterComponents: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(VersionTupleSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeMajor, 
        \Self.major, 
        \Self.unexpectedBetweenMajorAndComponents, 
        \Self.components, 
        \Self.unexpectedAfterComponents
      ])
}

// MARK: - WhereClauseSyntax

/// ### Children
/// 
///  - `whereKeyword`: `where`
///  - `condition`: ``ExprSyntax``
///
/// ### Contained in
/// 
///  - ``CatchItemSyntax``.``CatchItemSyntax/whereClause``
///  - ``ForStmtSyntax``.``ForStmtSyntax/whereClause``
///  - ``SwitchCaseItemSyntax``.``SwitchCaseItemSyntax/whereClause``
public struct WhereClauseSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .whereClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWhereKeyword: UnexpectedNodesSyntax? = nil,
      whereKeyword: TokenSyntax = .keyword(.where),
      _ unexpectedBetweenWhereKeywordAndCondition: UnexpectedNodesSyntax? = nil,
      condition: some ExprSyntaxProtocol,
      _ unexpectedAfterCondition: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeWhereKeyword), 
        Syntax(whereKeyword), 
        Syntax(unexpectedBetweenWhereKeywordAndCondition), 
        Syntax(condition), 
        Syntax(unexpectedAfterCondition)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.whereClause,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeWhereKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(WhereClauseSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `where`.
  public var whereKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(WhereClauseSyntax.self)
    }
  }
  
  public var unexpectedBetweenWhereKeywordAndCondition: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(WhereClauseSyntax.self)
    }
  }
  
  public var condition: ExprSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(WhereClauseSyntax.self)
    }
  }
  
  public var unexpectedAfterCondition: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(WhereClauseSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeWhereKeyword, 
        \Self.whereKeyword, 
        \Self.unexpectedBetweenWhereKeywordAndCondition, 
        \Self.condition, 
        \Self.unexpectedAfterCondition
      ])
}

// MARK: - WhileStmtSyntax

/// ### Children
/// 
///  - `whileKeyword`: `while`
///  - `conditions`: ``ConditionElementListSyntax``
///  - `body`: ``CodeBlockSyntax``
public struct WhileStmtSyntax: StmtSyntaxProtocol, SyntaxHashable, _LeafStmtSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .whileStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWhileKeyword: UnexpectedNodesSyntax? = nil,
      whileKeyword: TokenSyntax = .keyword(.while),
      _ unexpectedBetweenWhileKeywordAndConditions: UnexpectedNodesSyntax? = nil,
      conditions: ConditionElementListSyntax,
      _ unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeWhileKeyword), 
        Syntax(whileKeyword), 
        Syntax(unexpectedBetweenWhileKeywordAndConditions), 
        Syntax(conditions), 
        Syntax(unexpectedBetweenConditionsAndBody), 
        Syntax(body), 
        Syntax(unexpectedAfterBody)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.whileStmt,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeWhileKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(WhileStmtSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `while`.
  public var whileKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(WhileStmtSyntax.self)
    }
  }
  
  public var unexpectedBetweenWhileKeywordAndConditions: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(WhileStmtSyntax.self)
    }
  }
  
  public var conditions: ConditionElementListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(ConditionElementListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(WhileStmtSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `conditions`
  /// collection.
  ///
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  @available(*, deprecated, message: "Use node.conditions.append(newElement) instead")
  public func addCondition(_ element: ConditionElementSyntax) -> WhileStmtSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.conditionElementList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(WhileStmtSyntax.self)
  }
  
  public var unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(WhileStmtSyntax.self)
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(CodeBlockSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(WhileStmtSyntax.self)
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(WhileStmtSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeWhileKeyword, 
        \Self.whileKeyword, 
        \Self.unexpectedBetweenWhileKeywordAndConditions, 
        \Self.conditions, 
        \Self.unexpectedBetweenConditionsAndBody, 
        \Self.body, 
        \Self.unexpectedAfterBody
      ])
}

// MARK: - WildcardPatternSyntax

/// A pattern that represent a wildcard.
/// 
/// ### Examples
/// 
/// ``WildcardPatternSyntax`` matches and ignores any value.
/// For example `_` in the example:
/// 
/// ```swift
/// for _ in 1...3 {
///   // ...
/// }
/// ```
///
/// ### Children
/// 
///  - `wildcard`: `_`
public struct WildcardPatternSyntax: PatternSyntaxProtocol, SyntaxHashable, _LeafPatternSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .wildcardPattern else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWildcard: UnexpectedNodesSyntax? = nil,
      wildcard: TokenSyntax = .wildcardToken(),
      _ unexpectedAfterWildcard: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [Syntax(unexpectedBeforeWildcard), Syntax(wildcard), Syntax(unexpectedAfterWildcard)]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.wildcardPattern,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeWildcard: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(WildcardPatternSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `_`.
  public var wildcard: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(WildcardPatternSyntax.self)
    }
  }
  
  public var unexpectedAfterWildcard: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(WildcardPatternSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([\Self.unexpectedBeforeWildcard, \Self.wildcard, \Self.unexpectedAfterWildcard])
}

// MARK: - YieldStmtSyntax

/// ### Children
/// 
///  - `yieldKeyword`: `yield`
///  - `yieldedExpressions`: (``YieldedExpressionsClauseSyntax`` | ``ExprSyntax``)
public struct YieldStmtSyntax: StmtSyntaxProtocol, SyntaxHashable, _LeafStmtSyntaxNodeProtocol {
  public enum YieldedExpressions: SyntaxChildChoices, SyntaxHashable {
    case `multiple`(YieldedExpressionsClauseSyntax)
    case `single`(ExprSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .multiple(let node):
        return node._syntaxNode
      case .single(let node):
        return node._syntaxNode
      }
    }
    
    public init(_ node: YieldedExpressionsClauseSyntax) {
      self = .multiple(node)
    }
    
    public init(_ node: some ExprSyntaxProtocol) {
      self = .single(ExprSyntax(node))
    }
    
    public init?(_ node: __shared some SyntaxProtocol) {
      if let node = node.as(YieldedExpressionsClauseSyntax.self) {
        self = .multiple(node)
        return
      }
      if let node = node.as(ExprSyntax.self) {
        self = .single(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(YieldedExpressionsClauseSyntax.self), .node(ExprSyntax.self)])
    }
    
    /// Checks if the current syntax node can be cast to ``YieldedExpressionsClauseSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: YieldedExpressionsClauseSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``YieldedExpressionsClauseSyntax``.
    ///
    /// - Returns: An instance of ``YieldedExpressionsClauseSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: YieldedExpressionsClauseSyntax.Type) -> YieldedExpressionsClauseSyntax? {
      return YieldedExpressionsClauseSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``YieldedExpressionsClauseSyntax``.
    ///
    /// - Returns: An instance of ``YieldedExpressionsClauseSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: YieldedExpressionsClauseSyntax.Type) -> YieldedExpressionsClauseSyntax {
      return self.as(YieldedExpressionsClauseSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to the type conforming to the ``ExprSyntaxProtocol`` protocol.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to the type conforming to the ``ExprSyntaxProtocol`` protocol.
    ///
    /// - Returns: An instance of the specialized type, or `nil` if the cast fails.
    public func `as`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
      return S.init(self)
    }
    
    /// Force-casts the current syntax node to the type conforming to the ``ExprSyntaxProtocol`` protocol.
    ///
    /// - Returns: An instance of the specialized type.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S {
      return self.as(S.self)!
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .yieldStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeYieldKeyword: UnexpectedNodesSyntax? = nil,
      yieldKeyword: TokenSyntax = .keyword(.yield),
      _ unexpectedBetweenYieldKeywordAndYieldedExpressions: UnexpectedNodesSyntax? = nil,
      yieldedExpressions: YieldedExpressions,
      _ unexpectedAfterYieldedExpressions: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeYieldKeyword), 
        Syntax(yieldKeyword), 
        Syntax(unexpectedBetweenYieldKeywordAndYieldedExpressions), 
        Syntax(yieldedExpressions), 
        Syntax(unexpectedAfterYieldedExpressions)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.yieldStmt,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeYieldKeyword: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(YieldStmtSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `yield`.
  public var yieldKeyword: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(YieldStmtSyntax.self)
    }
  }
  
  public var unexpectedBetweenYieldKeywordAndYieldedExpressions: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(YieldStmtSyntax.self)
    }
  }
  
  public var yieldedExpressions: YieldedExpressions {
    get {
      return Syntax(self).child(at: 3)!.cast(YieldedExpressions.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(YieldStmtSyntax.self)
    }
  }
  
  public var unexpectedAfterYieldedExpressions: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(YieldStmtSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeYieldKeyword, 
        \Self.yieldKeyword, 
        \Self.unexpectedBetweenYieldKeywordAndYieldedExpressions, 
        \Self.yieldedExpressions, 
        \Self.unexpectedAfterYieldedExpressions
      ])
}

// MARK: - YieldedExpressionSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `comma`: `,`?
///
/// ### Contained in
/// 
///  - ``YieldedExpressionListSyntax``
public struct YieldedExpressionSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .yieldedExpression else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax? = nil,
      _ unexpectedAfterComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeExpression), 
        Syntax(expression), 
        Syntax(unexpectedBetweenExpressionAndComma), 
        Syntax(comma), 
        Syntax(unexpectedAfterComma)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.yieldedExpression,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionSyntax.self)
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(ExprSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionSyntax.self)
    }
  }
  
  public var unexpectedBetweenExpressionAndComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `,`.
  public var comma: TokenSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionSyntax.self)
    }
  }
  
  public var unexpectedAfterComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeExpression, 
        \Self.expression, 
        \Self.unexpectedBetweenExpressionAndComma, 
        \Self.comma, 
        \Self.unexpectedAfterComma
      ])
}

// MARK: - YieldedExpressionsClauseSyntax

/// ### Children
/// 
///  - `leftParen`: `(`
///  - `elements`: ``YieldedExpressionListSyntax``
///  - `rightParen`: `)`
///
/// ### Contained in
/// 
///  - ``YieldStmtSyntax``.``YieldStmtSyntax/yieldedExpressions``
public struct YieldedExpressionsClauseSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: __shared some SyntaxProtocol) {
    guard node.raw.kind == .yieldedExpressionsClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? = nil,
      elements: YieldedExpressionListSyntax,
      _ unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    let nodes: [Syntax?] = [
        Syntax(unexpectedBeforeLeftParen), 
        Syntax(leftParen), 
        Syntax(unexpectedBetweenLeftParenAndElements), 
        Syntax(elements), 
        Syntax(unexpectedBetweenElementsAndRightParen), 
        Syntax(rightParen), 
        Syntax(unexpectedAfterRightParen)
      ]
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime(SyntaxArena()) { (arena) in
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.yieldedExpressionsClause,
        from: nodes,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
    Syntax(self).setSyntaxTrackingOfTree(SyntaxTracking(tracking: nodes))
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionsClauseSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `(`.
  public var leftParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionsClauseSyntax.self)
    }
  }
  
  public var unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionsClauseSyntax.self)
    }
  }
  
  public var elements: YieldedExpressionListSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(YieldedExpressionListSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionsClauseSyntax.self)
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  ///
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  @available(*, deprecated, message: "Use node.elements.append(newElement) instead")
  public func addElement(_ element: YieldedExpressionSyntax) -> YieldedExpressionsClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.yieldedExpressionList,
                                        from: [Syntax(element)], arena: arena)
    }
    return Syntax(self)
      .replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
      .cast(YieldedExpressionsClauseSyntax.self)
  }
  
  public var unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionsClauseSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `)`.
  public var rightParen: TokenSyntax {
    get {
      return Syntax(self).child(at: 5)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionsClauseSyntax.self)
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(YieldedExpressionsClauseSyntax.self)
    }
  }
  
  public static let structure: SyntaxNodeStructure = .layout([
        \Self.unexpectedBeforeLeftParen, 
        \Self.leftParen, 
        \Self.unexpectedBetweenLeftParenAndElements, 
        \Self.elements, 
        \Self.unexpectedBetweenElementsAndRightParen, 
        \Self.rightParen, 
        \Self.unexpectedAfterRightParen
      ])
}
