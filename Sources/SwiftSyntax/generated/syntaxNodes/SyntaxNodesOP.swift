//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - ObjCSelectorPieceSyntax

/// A piece of an Objective-C selector. Either consisting of just an identifier for a nullary selector, an identifier and a colon for a labeled argument or just a colon for an unlabeled argument
///
/// ### Children
/// 
///  - `name`: ``TokenSyntax``?
///  - `colon`: `':'`?
///
/// ### Contained in
/// 
///  - ``ObjCSelectorPieceListSyntax``
public struct ObjCSelectorPieceSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .objCSelectorPiece else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ObjCSelectorPieceSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .objCSelectorPiece)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax? = nil,
      _ unexpectedBetweenNameAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax? = nil,
      _ unexpectedAfterColon: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndColon, 
            colon, 
            unexpectedAfterColon
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name?.raw, 
          unexpectedBetweenNameAndColon?.raw, 
          colon?.raw, 
          unexpectedAfterColon?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.objCSelectorPiece,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ObjCSelectorPieceSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax? {
    get {
      return data.child(at: 1).map(TokenSyntax.init)
    }
    set(value) {
      self = ObjCSelectorPieceSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ObjCSelectorPieceSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax? {
    get {
      return data.child(at: 3).map(TokenSyntax.init)
    }
    set(value) {
      self = ObjCSelectorPieceSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ObjCSelectorPieceSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndColon, 
          \Self.colon, 
          \Self.unexpectedAfterColon
        ])
  }
}

// MARK: - OpaqueReturnTypeOfAttributeArgumentsSyntax

/// The arguments for the '@_opaqueReturnTypeOf()'.
///
/// ### Children
/// 
///  - `mangledName`: ``StringLiteralExprSyntax``
///  - `comma`: `','`
///  - `ordinal`: `<integerLiteral>`
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct OpaqueReturnTypeOfAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .opaqueReturnTypeOfAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OpaqueReturnTypeOfAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .opaqueReturnTypeOfAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - mangledName: The mangled name of a declaration.
  ///   - ordinal: The ordinal corresponding to the 'some' keyword that introduced this opaque type.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeMangledName: UnexpectedNodesSyntax? = nil,
      mangledName: StringLiteralExprSyntax,
      _ unexpectedBetweenMangledNameAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax = .commaToken(),
      _ unexpectedBetweenCommaAndOrdinal: UnexpectedNodesSyntax? = nil,
      ordinal: TokenSyntax,
      _ unexpectedAfterOrdinal: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeMangledName, 
            mangledName, 
            unexpectedBetweenMangledNameAndComma, 
            comma, 
            unexpectedBetweenCommaAndOrdinal, 
            ordinal, 
            unexpectedAfterOrdinal
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeMangledName?.raw, 
          mangledName.raw, 
          unexpectedBetweenMangledNameAndComma?.raw, 
          comma.raw, 
          unexpectedBetweenCommaAndOrdinal?.raw, 
          ordinal.raw, 
          unexpectedAfterOrdinal?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.opaqueReturnTypeOfAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeMangledName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OpaqueReturnTypeOfAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The mangled name of a declaration.
  public var mangledName: StringLiteralExprSyntax {
    get {
      return StringLiteralExprSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = OpaqueReturnTypeOfAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenMangledNameAndComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OpaqueReturnTypeOfAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = OpaqueReturnTypeOfAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndOrdinal: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OpaqueReturnTypeOfAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The ordinal corresponding to the 'some' keyword that introduced this opaque type.
  public var ordinal: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = OpaqueReturnTypeOfAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOrdinal: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OpaqueReturnTypeOfAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeMangledName, 
          \Self.mangledName, 
          \Self.unexpectedBetweenMangledNameAndComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndOrdinal, 
          \Self.ordinal, 
          \Self.unexpectedAfterOrdinal
        ])
  }
}

// MARK: - OperatorDeclSyntax

/// A Swift `operator` declaration.
///
/// ### Children
/// 
///  - `fixitySpecifier`: (`'prefix'` | `'postfix'` | `'infix'`)
///  - `operatorKeyword`: `'operator'`
///  - `name`: (`<binaryOperator>` | `<prefixOperator>` | `<postfixOperator>`)
///  - `operatorPrecedenceAndTypes`: ``OperatorPrecedenceAndTypesSyntax``?
public struct OperatorDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .operatorDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OperatorDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .operatorDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - fixitySpecifier: The fixity applied to the 'operator' declaration.
  ///   - operatorPrecedenceAndTypes: Optionally specify a precedence group and designated types.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeFixitySpecifier: UnexpectedNodesSyntax? = nil,
      fixitySpecifier: TokenSyntax,
      _ unexpectedBetweenFixitySpecifierAndOperatorKeyword: UnexpectedNodesSyntax? = nil,
      operatorKeyword: TokenSyntax = .keyword(.operator),
      _ unexpectedBetweenOperatorKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? = nil,
      operatorPrecedenceAndTypes: OperatorPrecedenceAndTypesSyntax? = nil,
      _ unexpectedAfterOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeFixitySpecifier, 
            fixitySpecifier, 
            unexpectedBetweenFixitySpecifierAndOperatorKeyword, 
            operatorKeyword, 
            unexpectedBetweenOperatorKeywordAndName, 
            name, 
            unexpectedBetweenNameAndOperatorPrecedenceAndTypes, 
            operatorPrecedenceAndTypes, 
            unexpectedAfterOperatorPrecedenceAndTypes
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeFixitySpecifier?.raw, 
          fixitySpecifier.raw, 
          unexpectedBetweenFixitySpecifierAndOperatorKeyword?.raw, 
          operatorKeyword.raw, 
          unexpectedBetweenOperatorKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndOperatorPrecedenceAndTypes?.raw, 
          operatorPrecedenceAndTypes?.raw, 
          unexpectedAfterOperatorPrecedenceAndTypes?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.operatorDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeFixitySpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The fixity applied to the 'operator' declaration.
  public var fixitySpecifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFixitySpecifierAndOperatorKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var operatorKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Optionally specify a precedence group and designated types.
  public var operatorPrecedenceAndTypes: OperatorPrecedenceAndTypesSyntax? {
    get {
      return data.child(at: 7).map(OperatorPrecedenceAndTypesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeFixitySpecifier, 
          \Self.fixitySpecifier, 
          \Self.unexpectedBetweenFixitySpecifierAndOperatorKeyword, 
          \Self.operatorKeyword, 
          \Self.unexpectedBetweenOperatorKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndOperatorPrecedenceAndTypes, 
          \Self.operatorPrecedenceAndTypes, 
          \Self.unexpectedAfterOperatorPrecedenceAndTypes
        ])
  }
}

// MARK: - OperatorPrecedenceAndTypesSyntax

/// A clause to specify precedence group in infix operator declarations, and designated types in any operator declaration.
///
/// ### Children
/// 
///  - `colon`: `':'`
///  - `precedenceGroup`: `<identifier>`
///  - `designatedTypes`: ``DesignatedTypeListSyntax``
///
/// ### Contained in
/// 
///  - ``OperatorDeclSyntax``.``OperatorDeclSyntax/operatorPrecedenceAndTypes``
public struct OperatorPrecedenceAndTypesSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .operatorPrecedenceAndTypes else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OperatorPrecedenceAndTypesSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .operatorPrecedenceAndTypes)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - precedenceGroup: The precedence group for this operator
  ///   - designatedTypes: The designated types associated with this operator.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndPrecedenceGroup: UnexpectedNodesSyntax? = nil,
      precedenceGroup: TokenSyntax,
      _ unexpectedBetweenPrecedenceGroupAndDesignatedTypes: UnexpectedNodesSyntax? = nil,
      designatedTypes: DesignatedTypeListSyntax,
      _ unexpectedAfterDesignatedTypes: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeColon, 
            colon, 
            unexpectedBetweenColonAndPrecedenceGroup, 
            precedenceGroup, 
            unexpectedBetweenPrecedenceGroupAndDesignatedTypes, 
            designatedTypes, 
            unexpectedAfterDesignatedTypes
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndPrecedenceGroup?.raw, 
          precedenceGroup.raw, 
          unexpectedBetweenPrecedenceGroupAndDesignatedTypes?.raw, 
          designatedTypes.raw, 
          unexpectedAfterDesignatedTypes?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.operatorPrecedenceAndTypes,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorPrecedenceAndTypesSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = OperatorPrecedenceAndTypesSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndPrecedenceGroup: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorPrecedenceAndTypesSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The precedence group for this operator
  public var precedenceGroup: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = OperatorPrecedenceAndTypesSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPrecedenceGroupAndDesignatedTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorPrecedenceAndTypesSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The designated types associated with this operator.
  public var designatedTypes: DesignatedTypeListSyntax {
    get {
      return DesignatedTypeListSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = OperatorPrecedenceAndTypesSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `designatedTypes`
  /// collection.
  ///
  /// - param element: The new `DesignatedTypeElement` to add to the node's
  ///                  `designatedTypes` collection.
  /// - returns: A copy of the receiver with the provided `DesignatedTypeElement`
  ///            appended to its `designatedTypes` collection.
  @available(*, deprecated, message: "Use node.designatedTypes.append(newElement) instead")
  public func addDesignatedTypeElement(_ element: DesignatedTypeSyntax) -> OperatorPrecedenceAndTypesSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.designatedTypeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return OperatorPrecedenceAndTypesSyntax(newData)
  }
  
  public var unexpectedAfterDesignatedTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorPrecedenceAndTypesSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndPrecedenceGroup, 
          \Self.precedenceGroup, 
          \Self.unexpectedBetweenPrecedenceGroupAndDesignatedTypes, 
          \Self.designatedTypes, 
          \Self.unexpectedAfterDesignatedTypes
        ])
  }
}

// MARK: - OptionalBindingConditionSyntax

/// ### Children
/// 
///  - `bindingSpecifier`: (`'let'` | `'var'` | `'inout'` | `'_mutating'` | `'_borrowing'` | `'_consuming'`)
///  - `pattern`: ``PatternSyntax``
///  - `typeAnnotation`: ``TypeAnnotationSyntax``?
///  - `initializer`: ``InitializerClauseSyntax``?
///
/// ### Contained in
/// 
///  - ``ConditionElementSyntax``.``ConditionElementSyntax/condition``
public struct OptionalBindingConditionSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .optionalBindingCondition else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OptionalBindingConditionSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .optionalBindingCondition)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBindingSpecifier: UnexpectedNodesSyntax? = nil,
      bindingSpecifier: TokenSyntax,
      _ unexpectedBetweenBindingSpecifierAndPattern: UnexpectedNodesSyntax? = nil,
      pattern: some PatternSyntaxProtocol,
      _ unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodesSyntax? = nil,
      typeAnnotation: TypeAnnotationSyntax? = nil,
      _ unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodesSyntax? = nil,
      initializer: InitializerClauseSyntax? = nil,
      _ unexpectedAfterInitializer: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBindingSpecifier, 
            bindingSpecifier, 
            unexpectedBetweenBindingSpecifierAndPattern, 
            pattern, 
            unexpectedBetweenPatternAndTypeAnnotation, 
            typeAnnotation, 
            unexpectedBetweenTypeAnnotationAndInitializer, 
            initializer, 
            unexpectedAfterInitializer
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBindingSpecifier?.raw, 
          bindingSpecifier.raw, 
          unexpectedBetweenBindingSpecifierAndPattern?.raw, 
          pattern.raw, 
          unexpectedBetweenPatternAndTypeAnnotation?.raw, 
          typeAnnotation?.raw, 
          unexpectedBetweenTypeAnnotationAndInitializer?.raw, 
          initializer?.raw, 
          unexpectedAfterInitializer?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.optionalBindingCondition,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBindingSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var bindingSpecifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBindingSpecifierAndPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pattern: PatternSyntax {
    get {
      return PatternSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      return data.child(at: 5).map(TypeAnnotationSyntax.init)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var initializer: InitializerClauseSyntax? {
    get {
      return data.child(at: 7).map(InitializerClauseSyntax.init)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterInitializer: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalBindingConditionSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBindingSpecifier, 
          \Self.bindingSpecifier, 
          \Self.unexpectedBetweenBindingSpecifierAndPattern, 
          \Self.pattern, 
          \Self.unexpectedBetweenPatternAndTypeAnnotation, 
          \Self.typeAnnotation, 
          \Self.unexpectedBetweenTypeAnnotationAndInitializer, 
          \Self.initializer, 
          \Self.unexpectedAfterInitializer
        ])
  }
}

// MARK: - OptionalChainingExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `questionMark`: `'?'`
public struct OptionalChainingExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .optionalChainingExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OptionalChainingExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .optionalChainingExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .postfixQuestionMarkToken(),
      _ unexpectedAfterQuestionMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndQuestionMark, 
            questionMark, 
            unexpectedAfterQuestionMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedAfterQuestionMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.optionalChainingExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedAfterQuestionMark
        ])
  }
}

// MARK: - OptionalTypeSyntax

/// ### Children
/// 
///  - `wrappedType`: ``TypeSyntax``
///  - `questionMark`: `'?'`
public struct OptionalTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .optionalType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OptionalTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .optionalType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWrappedType: UnexpectedNodesSyntax? = nil,
      wrappedType: some TypeSyntaxProtocol,
      _ unexpectedBetweenWrappedTypeAndQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .postfixQuestionMarkToken(),
      _ unexpectedAfterQuestionMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeWrappedType, 
            wrappedType, 
            unexpectedBetweenWrappedTypeAndQuestionMark, 
            questionMark, 
            unexpectedAfterQuestionMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeWrappedType?.raw, 
          wrappedType.raw, 
          unexpectedBetweenWrappedTypeAndQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedAfterQuestionMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.optionalType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWrappedType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var wrappedType: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = OptionalTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenWrappedTypeAndQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = OptionalTypeSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeWrappedType, 
          \Self.wrappedType, 
          \Self.unexpectedBetweenWrappedTypeAndQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedAfterQuestionMark
        ])
  }
}

// MARK: - OriginallyDefinedInAttributeArgumentsSyntax

/// The arguments for the '@_originallyDefinedIn' attribute
///
/// ### Children
/// 
///  - `moduleLabel`: `'module'`
///  - `colon`: `':'`
///  - `moduleName`: ``StringLiteralExprSyntax``
///  - `comma`: `','`
///  - `platforms`: ``PlatformVersionItemListSyntax``
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct OriginallyDefinedInAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .originallyDefinedInAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OriginallyDefinedInAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .originallyDefinedInAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeModuleLabel: UnexpectedNodesSyntax? = nil,
      moduleLabel: TokenSyntax = .keyword(.module),
      _ unexpectedBetweenModuleLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndModuleName: UnexpectedNodesSyntax? = nil,
      moduleName: StringLiteralExprSyntax,
      _ unexpectedBetweenModuleNameAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax = .commaToken(),
      _ unexpectedBetweenCommaAndPlatforms: UnexpectedNodesSyntax? = nil,
      platforms: PlatformVersionItemListSyntax,
      _ unexpectedAfterPlatforms: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeModuleLabel, 
            moduleLabel, 
            unexpectedBetweenModuleLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndModuleName, 
            moduleName, 
            unexpectedBetweenModuleNameAndComma, 
            comma, 
            unexpectedBetweenCommaAndPlatforms, 
            platforms, 
            unexpectedAfterPlatforms
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeModuleLabel?.raw, 
          moduleLabel.raw, 
          unexpectedBetweenModuleLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndModuleName?.raw, 
          moduleName.raw, 
          unexpectedBetweenModuleNameAndComma?.raw, 
          comma.raw, 
          unexpectedBetweenCommaAndPlatforms?.raw, 
          platforms.raw, 
          unexpectedAfterPlatforms?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.originallyDefinedInAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeModuleLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var moduleLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenModuleLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndModuleName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var moduleName: StringLiteralExprSyntax {
    get {
      return StringLiteralExprSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenModuleNameAndComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7)!)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndPlatforms: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var platforms: PlatformVersionItemListSyntax {
    get {
      return PlatformVersionItemListSyntax(data.child(at: 9)!)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `platforms`
  /// collection.
  ///
  /// - param element: The new `Platform` to add to the node's
  ///                  `platforms` collection.
  /// - returns: A copy of the receiver with the provided `Platform`
  ///            appended to its `platforms` collection.
  @available(*, deprecated, message: "Use node.platforms.append(newElement) instead")
  public func addPlatform(_ element: PlatformVersionItemSyntax) -> OriginallyDefinedInAttributeArgumentsSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[9] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.platformVersionItemList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 9, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return OriginallyDefinedInAttributeArgumentsSyntax(newData)
  }
  
  public var unexpectedAfterPlatforms: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OriginallyDefinedInAttributeArgumentsSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeModuleLabel, 
          \Self.moduleLabel, 
          \Self.unexpectedBetweenModuleLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndModuleName, 
          \Self.moduleName, 
          \Self.unexpectedBetweenModuleNameAndComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndPlatforms, 
          \Self.platforms, 
          \Self.unexpectedAfterPlatforms
        ])
  }
}

// MARK: - PackElementExprSyntax

/// ### Children
/// 
///  - `eachKeyword`: `'each'`
///  - `pack`: ``ExprSyntax``
public struct PackElementExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .packElementExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PackElementExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packElementExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? = nil,
      eachKeyword: TokenSyntax = .keyword(.each),
      _ unexpectedBetweenEachKeywordAndPack: UnexpectedNodesSyntax? = nil,
      pack: some ExprSyntaxProtocol,
      _ unexpectedAfterPack: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeEachKeyword, 
            eachKeyword, 
            unexpectedBetweenEachKeywordAndPack, 
            pack, 
            unexpectedAfterPack
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeEachKeyword?.raw, 
          eachKeyword.raw, 
          unexpectedBetweenEachKeywordAndPack?.raw, 
          pack.raw, 
          unexpectedAfterPack?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packElementExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var eachKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEachKeywordAndPack: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pack: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPack: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeEachKeyword, 
          \Self.eachKeyword, 
          \Self.unexpectedBetweenEachKeywordAndPack, 
          \Self.pack, 
          \Self.unexpectedAfterPack
        ])
  }
}

// MARK: - PackElementTypeSyntax

/// ### Children
/// 
///  - `eachKeyword`: `'each'`
///  - `pack`: ``TypeSyntax``
public struct PackElementTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .packElementType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PackElementTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packElementType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? = nil,
      eachKeyword: TokenSyntax = .keyword(.each),
      _ unexpectedBetweenEachKeywordAndPack: UnexpectedNodesSyntax? = nil,
      pack: some TypeSyntaxProtocol,
      _ unexpectedAfterPack: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeEachKeyword, 
            eachKeyword, 
            unexpectedBetweenEachKeywordAndPack, 
            pack, 
            unexpectedAfterPack
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeEachKeyword?.raw, 
          eachKeyword.raw, 
          unexpectedBetweenEachKeywordAndPack?.raw, 
          pack.raw, 
          unexpectedAfterPack?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packElementType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var eachKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PackElementTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEachKeywordAndPack: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pack: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PackElementTypeSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPack: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeEachKeyword, 
          \Self.eachKeyword, 
          \Self.unexpectedBetweenEachKeywordAndPack, 
          \Self.pack, 
          \Self.unexpectedAfterPack
        ])
  }
}

// MARK: - PackExpansionExprSyntax

/// ### Children
/// 
///  - `repeatKeyword`: `'repeat'`
///  - `repetitionPattern`: ``ExprSyntax``
public struct PackExpansionExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .packExpansionExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PackExpansionExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packExpansionExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? = nil,
      repeatKeyword: TokenSyntax = .keyword(.repeat),
      _ unexpectedBetweenRepeatKeywordAndRepetitionPattern: UnexpectedNodesSyntax? = nil,
      repetitionPattern: some ExprSyntaxProtocol,
      _ unexpectedAfterRepetitionPattern: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeRepeatKeyword, 
            repeatKeyword, 
            unexpectedBetweenRepeatKeywordAndRepetitionPattern, 
            repetitionPattern, 
            unexpectedAfterRepetitionPattern
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeRepeatKeyword?.raw, 
          repeatKeyword.raw, 
          unexpectedBetweenRepeatKeywordAndRepetitionPattern?.raw, 
          repetitionPattern.raw, 
          unexpectedAfterRepetitionPattern?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packExpansionExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var repeatKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRepeatKeywordAndRepetitionPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var repetitionPattern: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRepetitionPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeRepeatKeyword, 
          \Self.repeatKeyword, 
          \Self.unexpectedBetweenRepeatKeywordAndRepetitionPattern, 
          \Self.repetitionPattern, 
          \Self.unexpectedAfterRepetitionPattern
        ])
  }
}

// MARK: - PackExpansionTypeSyntax

/// ### Children
/// 
///  - `repeatKeyword`: `'repeat'`
///  - `repetitionPattern`: ``TypeSyntax``
public struct PackExpansionTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .packExpansionType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PackExpansionTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packExpansionType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? = nil,
      repeatKeyword: TokenSyntax = .keyword(.repeat),
      _ unexpectedBetweenRepeatKeywordAndRepetitionPattern: UnexpectedNodesSyntax? = nil,
      repetitionPattern: some TypeSyntaxProtocol,
      _ unexpectedAfterRepetitionPattern: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeRepeatKeyword, 
            repeatKeyword, 
            unexpectedBetweenRepeatKeywordAndRepetitionPattern, 
            repetitionPattern, 
            unexpectedAfterRepetitionPattern
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeRepeatKeyword?.raw, 
          repeatKeyword.raw, 
          unexpectedBetweenRepeatKeywordAndRepetitionPattern?.raw, 
          repetitionPattern.raw, 
          unexpectedAfterRepetitionPattern?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packExpansionType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var repeatKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PackExpansionTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRepeatKeywordAndRepetitionPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var repetitionPattern: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PackExpansionTypeSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRepetitionPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeRepeatKeyword, 
          \Self.repeatKeyword, 
          \Self.unexpectedBetweenRepeatKeywordAndRepetitionPattern, 
          \Self.repetitionPattern, 
          \Self.unexpectedAfterRepetitionPattern
        ])
  }
}

// MARK: - PatternBindingSyntax

/// Defines variables inside a variable declaration.
///
/// ### Children
/// 
///  - `pattern`: ``PatternSyntax``
///  - `typeAnnotation`: ``TypeAnnotationSyntax``?
///  - `initializer`: ``InitializerClauseSyntax``?
///  - `accessorBlock`: ``AccessorBlockSyntax``?
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``PatternBindingListSyntax``
public struct PatternBindingSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .patternBinding else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PatternBindingSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .patternBinding)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - pattern: The pattern that defines the variables.
  ///   - typeAnnotation: The type of the variables defined by the pattern.
  ///   - initializer: If the variables have a default value, the clause that initializes them.
  ///   - accessorBlock: If the variable is computed, the accessors that get (and optionally set) the value.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePattern: UnexpectedNodesSyntax? = nil,
      pattern: some PatternSyntaxProtocol,
      _ unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodesSyntax? = nil,
      typeAnnotation: TypeAnnotationSyntax? = nil,
      _ unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodesSyntax? = nil,
      initializer: InitializerClauseSyntax? = nil,
      _ unexpectedBetweenInitializerAndAccessorBlock: UnexpectedNodesSyntax? = nil,
      accessorBlock: AccessorBlockSyntax? = nil,
      _ unexpectedBetweenAccessorBlockAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePattern, 
            pattern, 
            unexpectedBetweenPatternAndTypeAnnotation, 
            typeAnnotation, 
            unexpectedBetweenTypeAnnotationAndInitializer, 
            initializer, 
            unexpectedBetweenInitializerAndAccessorBlock, 
            accessorBlock, 
            unexpectedBetweenAccessorBlockAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePattern?.raw, 
          pattern.raw, 
          unexpectedBetweenPatternAndTypeAnnotation?.raw, 
          typeAnnotation?.raw, 
          unexpectedBetweenTypeAnnotationAndInitializer?.raw, 
          initializer?.raw, 
          unexpectedBetweenInitializerAndAccessorBlock?.raw, 
          accessorBlock?.raw, 
          unexpectedBetweenAccessorBlockAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.patternBinding,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The pattern that defines the variables.
  /// 
  /// In simple variable declarations this is an ``IdentifierPatternSyntax``, which defines
  /// the name of a single variable.
  /// 
  /// In more complex variable declaration, this can, for example, be a ``TuplePatternSyntax``
  /// that destructures a tuple.
  /// 
  /// ```swift
  /// let (x, y) = (1, 2)
  /// ```
  public var pattern: PatternSyntax {
    get {
      return PatternSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The type of the variables defined by the pattern.
  /// 
  /// Can be omitted, in which case the variables’ types are inferred from the initializer.
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      return data.child(at: 3).map(TypeAnnotationSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the variables have a default value, the clause that initializes them.
  public var initializer: InitializerClauseSyntax? {
    get {
      return data.child(at: 5).map(InitializerClauseSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInitializerAndAccessorBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the variable is computed, the accessors that get (and optionally set) the value.
  public var accessorBlock: AccessorBlockSyntax? {
    get {
      return data.child(at: 7).map(AccessorBlockSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAccessorBlockAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 9).map(TokenSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternBindingSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePattern, 
          \Self.pattern, 
          \Self.unexpectedBetweenPatternAndTypeAnnotation, 
          \Self.typeAnnotation, 
          \Self.unexpectedBetweenTypeAnnotationAndInitializer, 
          \Self.initializer, 
          \Self.unexpectedBetweenInitializerAndAccessorBlock, 
          \Self.accessorBlock, 
          \Self.unexpectedBetweenAccessorBlockAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - PatternExprSyntax

/// ### Children
/// 
///  - `pattern`: ``PatternSyntax``
public struct PatternExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .patternExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PatternExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .patternExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePattern: UnexpectedNodesSyntax? = nil,
      pattern: some PatternSyntaxProtocol,
      _ unexpectedAfterPattern: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforePattern, pattern, unexpectedAfterPattern))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforePattern?.raw, pattern.raw, unexpectedAfterPattern?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.patternExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pattern: PatternSyntax {
    get {
      return PatternSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PatternExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PatternExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforePattern, \Self.pattern, \Self.unexpectedAfterPattern])
  }
}

// MARK: - PlatformVersionItemSyntax

/// A single platform/version pair in an attribute, e.g. `iOS 10.1`.
///
/// ### Children
/// 
///  - `platformVersion`: ``PlatformVersionSyntax``
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``PlatformVersionItemListSyntax``
public struct PlatformVersionItemSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .platformVersionItem else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PlatformVersionItemSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .platformVersionItem)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingComma: A trailing comma if the argument is followed by another argument
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePlatformVersion: UnexpectedNodesSyntax? = nil,
      platformVersion: PlatformVersionSyntax,
      _ unexpectedBetweenPlatformVersionAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePlatformVersion, 
            platformVersion, 
            unexpectedBetweenPlatformVersionAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePlatformVersion?.raw, 
          platformVersion.raw, 
          unexpectedBetweenPlatformVersionAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.platformVersionItem,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePlatformVersion: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PlatformVersionItemSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var platformVersion: PlatformVersionSyntax {
    get {
      return PlatformVersionSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PlatformVersionItemSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPlatformVersionAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PlatformVersionItemSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A trailing comma if the argument is followed by another argument
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3).map(TokenSyntax.init)
    }
    set(value) {
      self = PlatformVersionItemSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PlatformVersionItemSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePlatformVersion, 
          \Self.platformVersion, 
          \Self.unexpectedBetweenPlatformVersionAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - PlatformVersionSyntax

/// An argument to `@available` that restricts the availability on a certain platform to a version, e.g. `iOS 10` or `swift 3.4`.
///
/// ### Children
/// 
///  - `platform`: `<identifier>`
///  - `version`: ``VersionTupleSyntax``?
///
/// ### Contained in
/// 
///  - ``AvailabilityArgumentSyntax``.``AvailabilityArgumentSyntax/argument``
///  - ``PlatformVersionItemSyntax``.``PlatformVersionItemSyntax/platformVersion``
public struct PlatformVersionSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .platformVersion else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PlatformVersionSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .platformVersion)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - platform: The name of the OS on which the availability should be restricted or 'swift' if the availability should be restricted based on a Swift version.
  ///   - version: The version of this platform.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePlatform: UnexpectedNodesSyntax? = nil,
      platform: TokenSyntax,
      _ unexpectedBetweenPlatformAndVersion: UnexpectedNodesSyntax? = nil,
      version: VersionTupleSyntax? = nil,
      _ unexpectedAfterVersion: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePlatform, 
            platform, 
            unexpectedBetweenPlatformAndVersion, 
            version, 
            unexpectedAfterVersion
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePlatform?.raw, 
          platform.raw, 
          unexpectedBetweenPlatformAndVersion?.raw, 
          version?.raw, 
          unexpectedAfterVersion?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.platformVersion,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePlatform: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PlatformVersionSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of the OS on which the availability should be restricted or 'swift' if the availability should be restricted based on a Swift version.
  public var platform: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PlatformVersionSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPlatformAndVersion: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PlatformVersionSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The version of this platform.
  /// 
  /// This parameter is optional because a custom platform alias can be specified using the `-define-availability` 
  /// argument to the Swift compiler. For example, when passing `-define-availability "_iOS8Aligned:macOS 10.10, iOS 8.0"`
  /// to the Swift compiler, then `@available(_iOS8Aligned, *)` is interpreted as `@available(macOS 10.10, iOS 8.0, *)`.
  public var version: VersionTupleSyntax? {
    get {
      return data.child(at: 3).map(VersionTupleSyntax.init)
    }
    set(value) {
      self = PlatformVersionSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterVersion: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PlatformVersionSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePlatform, 
          \Self.platform, 
          \Self.unexpectedBetweenPlatformAndVersion, 
          \Self.version, 
          \Self.unexpectedAfterVersion
        ])
  }
}

// MARK: - PostfixIfConfigExprSyntax

/// ### Children
/// 
///  - `base`: ``ExprSyntax``?
///  - `config`: ``IfConfigDeclSyntax``
public struct PostfixIfConfigExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .postfixIfConfigExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PostfixIfConfigExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .postfixIfConfigExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBase: UnexpectedNodesSyntax? = nil,
      base: (some ExprSyntaxProtocol)? = ExprSyntax?.none,
      _ unexpectedBetweenBaseAndConfig: UnexpectedNodesSyntax? = nil,
      config: IfConfigDeclSyntax,
      _ unexpectedAfterConfig: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBase, 
            base, 
            unexpectedBetweenBaseAndConfig, 
            config, 
            unexpectedAfterConfig
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBase?.raw, 
          base?.raw, 
          unexpectedBetweenBaseAndConfig?.raw, 
          config.raw, 
          unexpectedAfterConfig?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.postfixIfConfigExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBase: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var base: ExprSyntax? {
    get {
      return data.child(at: 1).map(ExprSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBaseAndConfig: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var config: IfConfigDeclSyntax {
    get {
      return IfConfigDeclSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterConfig: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBase, 
          \Self.base, 
          \Self.unexpectedBetweenBaseAndConfig, 
          \Self.config, 
          \Self.unexpectedAfterConfig
        ])
  }
}

// MARK: - PostfixOperatorExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `operator`: `<postfixOperator>`
public struct PostfixOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .postfixOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PostfixOperatorExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .postfixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndOperator: UnexpectedNodesSyntax? = nil,
      operator: TokenSyntax,
      _ unexpectedAfterOperator: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndOperator, 
            `operator`, 
            unexpectedAfterOperator
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndOperator?.raw, 
          `operator`.raw, 
          unexpectedAfterOperator?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.postfixOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PostfixOperatorExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var `operator`: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PostfixOperatorExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixOperatorExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndOperator, 
          \Self.operator, 
          \Self.unexpectedAfterOperator
        ])
  }
}

// MARK: - PoundSourceLocationArgumentsSyntax

/// ### Children
/// 
///  - `fileLabel`: `'file'`
///  - `fileColon`: `':'`
///  - `fileName`: ``SimpleStringLiteralExprSyntax``
///  - `comma`: `','`
///  - `lineLabel`: `'line'`
///  - `lineColon`: `':'`
///  - `lineNumber`: `<integerLiteral>`
///
/// ### Contained in
/// 
///  - ``PoundSourceLocationSyntax``.``PoundSourceLocationSyntax/arguments``
public struct PoundSourceLocationArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .poundSourceLocationArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PoundSourceLocationArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .poundSourceLocationArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeFileLabel: UnexpectedNodesSyntax? = nil,
      fileLabel: TokenSyntax = .keyword(.file),
      _ unexpectedBetweenFileLabelAndFileColon: UnexpectedNodesSyntax? = nil,
      fileColon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenFileColonAndFileName: UnexpectedNodesSyntax? = nil,
      fileName: SimpleStringLiteralExprSyntax,
      _ unexpectedBetweenFileNameAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax = .commaToken(),
      _ unexpectedBetweenCommaAndLineLabel: UnexpectedNodesSyntax? = nil,
      lineLabel: TokenSyntax = .keyword(.line),
      _ unexpectedBetweenLineLabelAndLineColon: UnexpectedNodesSyntax? = nil,
      lineColon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenLineColonAndLineNumber: UnexpectedNodesSyntax? = nil,
      lineNumber: TokenSyntax,
      _ unexpectedAfterLineNumber: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeFileLabel, 
            fileLabel, 
            unexpectedBetweenFileLabelAndFileColon, 
            fileColon, 
            unexpectedBetweenFileColonAndFileName, 
            fileName, 
            unexpectedBetweenFileNameAndComma, 
            comma, 
            unexpectedBetweenCommaAndLineLabel, 
            lineLabel, 
            unexpectedBetweenLineLabelAndLineColon, 
            lineColon, 
            unexpectedBetweenLineColonAndLineNumber, 
            lineNumber, 
            unexpectedAfterLineNumber
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeFileLabel?.raw, 
          fileLabel.raw, 
          unexpectedBetweenFileLabelAndFileColon?.raw, 
          fileColon.raw, 
          unexpectedBetweenFileColonAndFileName?.raw, 
          fileName.raw, 
          unexpectedBetweenFileNameAndComma?.raw, 
          comma.raw, 
          unexpectedBetweenCommaAndLineLabel?.raw, 
          lineLabel.raw, 
          unexpectedBetweenLineLabelAndLineColon?.raw, 
          lineColon.raw, 
          unexpectedBetweenLineColonAndLineNumber?.raw, 
          lineNumber.raw, 
          unexpectedAfterLineNumber?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.poundSourceLocationArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeFileLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var fileLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFileLabelAndFileColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var fileColon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFileColonAndFileName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var fileName: SimpleStringLiteralExprSyntax {
    get {
      return SimpleStringLiteralExprSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFileNameAndComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7)!)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndLineLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var lineLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9)!)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLineLabelAndLineColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var lineColon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 11)!)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLineColonAndLineNumber: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var lineNumber: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 13)!)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 13, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterLineNumber: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationArgumentsSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeFileLabel, 
          \Self.fileLabel, 
          \Self.unexpectedBetweenFileLabelAndFileColon, 
          \Self.fileColon, 
          \Self.unexpectedBetweenFileColonAndFileName, 
          \Self.fileName, 
          \Self.unexpectedBetweenFileNameAndComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndLineLabel, 
          \Self.lineLabel, 
          \Self.unexpectedBetweenLineLabelAndLineColon, 
          \Self.lineColon, 
          \Self.unexpectedBetweenLineColonAndLineNumber, 
          \Self.lineNumber, 
          \Self.unexpectedAfterLineNumber
        ])
  }
}

// MARK: - PoundSourceLocationSyntax

/// ### Children
/// 
///  - `poundSourceLocation`: `'#sourceLocation'`
///  - `leftParen`: `'('`
///  - `arguments`: ``PoundSourceLocationArgumentsSyntax``?
///  - `rightParen`: `')'`
public struct PoundSourceLocationSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .poundSourceLocation else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PoundSourceLocationSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .poundSourceLocation)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePoundSourceLocation: UnexpectedNodesSyntax? = nil,
      poundSourceLocation: TokenSyntax = .poundSourceLocationToken(),
      _ unexpectedBetweenPoundSourceLocationAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: PoundSourceLocationArgumentsSyntax? = nil,
      _ unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePoundSourceLocation, 
            poundSourceLocation, 
            unexpectedBetweenPoundSourceLocationAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePoundSourceLocation?.raw, 
          poundSourceLocation.raw, 
          unexpectedBetweenPoundSourceLocationAndLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndArguments?.raw, 
          arguments?.raw, 
          unexpectedBetweenArgumentsAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.poundSourceLocation,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePoundSourceLocation: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var poundSourceLocation: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPoundSourceLocationAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: PoundSourceLocationArgumentsSyntax? {
    get {
      return data.child(at: 5).map(PoundSourceLocationArgumentsSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7)!)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePoundSourceLocation, 
          \Self.poundSourceLocation, 
          \Self.unexpectedBetweenPoundSourceLocationAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - PrecedenceGroupAssignmentSyntax

/// Specifies the precedence of an operator when used in an operation that includes optional chaining.
///
/// ### Children
/// 
///  - `assignmentLabel`: `'assignment'`
///  - `colon`: `':'`
///  - `value`: (`'true'` | `'false'`)
///
/// ### Contained in
/// 
///  - ``PrecedenceGroupAttributeListSyntax``
public struct PrecedenceGroupAssignmentSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupAssignment else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrecedenceGroupAssignmentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupAssignment)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - value: When true, an operator in the corresponding precedence group uses the same grouping rules during optional chaining as the assignment operators from the standard library. Otherwise, operators in the precedence group follows the same optional chaining rules as operators that don't perform assignment.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAssignmentLabel: UnexpectedNodesSyntax? = nil,
      assignmentLabel: TokenSyntax = .keyword(.assignment),
      _ unexpectedBetweenAssignmentLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? = nil,
      value: TokenSyntax,
      _ unexpectedAfterValue: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAssignmentLabel, 
            assignmentLabel, 
            unexpectedBetweenAssignmentLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndValue, 
            value, 
            unexpectedAfterValue
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAssignmentLabel?.raw, 
          assignmentLabel.raw, 
          unexpectedBetweenAssignmentLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndValue?.raw, 
          value.raw, 
          unexpectedAfterValue?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.precedenceGroupAssignment,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAssignmentLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssignmentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var assignmentLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrecedenceGroupAssignmentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAssignmentLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssignmentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PrecedenceGroupAssignmentSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssignmentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// When true, an operator in the corresponding precedence group uses the same grouping rules during optional chaining as the assignment operators from the standard library. Otherwise, operators in the precedence group follows the same optional chaining rules as operators that don't perform assignment.
  public var value: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = PrecedenceGroupAssignmentSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssignmentSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAssignmentLabel, 
          \Self.assignmentLabel, 
          \Self.unexpectedBetweenAssignmentLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndValue, 
          \Self.value, 
          \Self.unexpectedAfterValue
        ])
  }
}

// MARK: - PrecedenceGroupAssociativitySyntax

/// Specifies how a sequence of operators with the same precedence level are grouped together in the absence of grouping parentheses.
///
/// ### Children
/// 
///  - `associativityLabel`: `'associativity'`
///  - `colon`: `':'`
///  - `value`: (`'left'` | `'right'` | `'none'`)
///
/// ### Contained in
/// 
///  - ``PrecedenceGroupAttributeListSyntax``
public struct PrecedenceGroupAssociativitySyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupAssociativity else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrecedenceGroupAssociativitySyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupAssociativity)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - value: Operators that are `left`-associative group left-to-right. Operators that are `right`-associative group right-to-left. Operators that are specified with an associativity of `none` don't associate at all
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAssociativityLabel: UnexpectedNodesSyntax? = nil,
      associativityLabel: TokenSyntax = .keyword(.associativity),
      _ unexpectedBetweenAssociativityLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? = nil,
      value: TokenSyntax,
      _ unexpectedAfterValue: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAssociativityLabel, 
            associativityLabel, 
            unexpectedBetweenAssociativityLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndValue, 
            value, 
            unexpectedAfterValue
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAssociativityLabel?.raw, 
          associativityLabel.raw, 
          unexpectedBetweenAssociativityLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndValue?.raw, 
          value.raw, 
          unexpectedAfterValue?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.precedenceGroupAssociativity,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAssociativityLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssociativitySyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var associativityLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrecedenceGroupAssociativitySyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAssociativityLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssociativitySyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PrecedenceGroupAssociativitySyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssociativitySyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Operators that are `left`-associative group left-to-right. Operators that are `right`-associative group right-to-left. Operators that are specified with an associativity of `none` don't associate at all
  public var value: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = PrecedenceGroupAssociativitySyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupAssociativitySyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAssociativityLabel, 
          \Self.associativityLabel, 
          \Self.unexpectedBetweenAssociativityLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndValue, 
          \Self.value, 
          \Self.unexpectedAfterValue
        ])
  }
}

// MARK: - PrecedenceGroupDeclSyntax

/// A Swift `precedencegroup` declaration.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `precedencegroupKeyword`: `'precedencegroup'`
///  - `name`: `<identifier>`
///  - `leftBrace`: `'{'`
///  - `groupAttributes`: ``PrecedenceGroupAttributeListSyntax``
///  - `rightBrace`: `'}'`
public struct PrecedenceGroupDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrecedenceGroupDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: The attributes applied to the 'precedencegroup' declaration.
  ///   - modifiers: The declaration modifiers applied to the 'precedencegroup' declaration.
  ///   - name: The name of this precedence group.
  ///   - groupAttributes: The characteristics of this precedence group.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndPrecedencegroupKeyword: UnexpectedNodesSyntax? = nil,
      precedencegroupKeyword: TokenSyntax = .keyword(.precedencegroup),
      _ unexpectedBetweenPrecedencegroupKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndGroupAttributes: UnexpectedNodesSyntax? = nil,
      groupAttributes: PrecedenceGroupAttributeListSyntax,
      _ unexpectedBetweenGroupAttributesAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndPrecedencegroupKeyword, 
            precedencegroupKeyword, 
            unexpectedBetweenPrecedencegroupKeywordAndName, 
            name, 
            unexpectedBetweenNameAndLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndGroupAttributes, 
            groupAttributes, 
            unexpectedBetweenGroupAttributesAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndPrecedencegroupKeyword?.raw, 
          precedencegroupKeyword.raw, 
          unexpectedBetweenPrecedencegroupKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndGroupAttributes?.raw, 
          groupAttributes.raw, 
          unexpectedBetweenGroupAttributesAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.precedenceGroupDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The attributes applied to the 'precedencegroup' declaration.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrecedenceGroupDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The declaration modifiers applied to the 'precedencegroup' declaration.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrecedenceGroupDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndPrecedencegroupKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var precedencegroupKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPrecedencegroupKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of this precedence group.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7)!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9)!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndGroupAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The characteristics of this precedence group.
  public var groupAttributes: PrecedenceGroupAttributeListSyntax {
    get {
      return PrecedenceGroupAttributeListSyntax(data.child(at: 11)!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `groupAttributes`
  /// collection.
  ///
  /// - param element: The new `GroupAttribute` to add to the node's
  ///                  `groupAttributes` collection.
  /// - returns: A copy of the receiver with the provided `GroupAttribute`
  ///            appended to its `groupAttributes` collection.
  @available(*, deprecated, message: "Use node.groupAttributes.append(newElement) instead")
  public func addGroupAttribute(_ element: Syntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[11] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.precedenceGroupAttributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 11, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrecedenceGroupDeclSyntax(newData)
  }
  
  public var unexpectedBetweenGroupAttributesAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 13)!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 13, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndPrecedencegroupKeyword, 
          \Self.precedencegroupKeyword, 
          \Self.unexpectedBetweenPrecedencegroupKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndGroupAttributes, 
          \Self.groupAttributes, 
          \Self.unexpectedBetweenGroupAttributesAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - PrecedenceGroupNameSyntax

/// ### Children
/// 
///  - `name`: `<identifier>`
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``PrecedenceGroupNameListSyntax``
public struct PrecedenceGroupNameSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupName else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrecedenceGroupNameSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupName)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.precedenceGroupName,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupNameSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrecedenceGroupNameSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupNameSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3).map(TokenSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupNameSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupNameSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - PrecedenceGroupRelationSyntax

/// Specify the new precedence group's relation to existing precedence groups.
///
/// ### Children
/// 
///  - `higherThanOrLowerThanLabel`: (`'higherThan'` | `'lowerThan'`)
///  - `colon`: `':'`
///  - `precedenceGroups`: ``PrecedenceGroupNameListSyntax``
///
/// ### Contained in
/// 
///  - ``PrecedenceGroupAttributeListSyntax``
public struct PrecedenceGroupRelationSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupRelation else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrecedenceGroupRelationSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupRelation)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - higherThanOrLowerThanLabel: The relation to specified other precedence groups.
  ///   - precedenceGroups: The name of other precedence group to which this precedence group relates.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeHigherThanOrLowerThanLabel: UnexpectedNodesSyntax? = nil,
      higherThanOrLowerThanLabel: TokenSyntax,
      _ unexpectedBetweenHigherThanOrLowerThanLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndPrecedenceGroups: UnexpectedNodesSyntax? = nil,
      precedenceGroups: PrecedenceGroupNameListSyntax,
      _ unexpectedAfterPrecedenceGroups: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeHigherThanOrLowerThanLabel, 
            higherThanOrLowerThanLabel, 
            unexpectedBetweenHigherThanOrLowerThanLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndPrecedenceGroups, 
            precedenceGroups, 
            unexpectedAfterPrecedenceGroups
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeHigherThanOrLowerThanLabel?.raw, 
          higherThanOrLowerThanLabel.raw, 
          unexpectedBetweenHigherThanOrLowerThanLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndPrecedenceGroups?.raw, 
          precedenceGroups.raw, 
          unexpectedAfterPrecedenceGroups?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.precedenceGroupRelation,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeHigherThanOrLowerThanLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupRelationSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The relation to specified other precedence groups.
  public var higherThanOrLowerThanLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrecedenceGroupRelationSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenHigherThanOrLowerThanLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupRelationSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PrecedenceGroupRelationSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndPrecedenceGroups: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupRelationSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of other precedence group to which this precedence group relates.
  public var precedenceGroups: PrecedenceGroupNameListSyntax {
    get {
      return PrecedenceGroupNameListSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = PrecedenceGroupRelationSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `precedenceGroups`
  /// collection.
  ///
  /// - param element: The new `OtherName` to add to the node's
  ///                  `precedenceGroups` collection.
  /// - returns: A copy of the receiver with the provided `OtherName`
  ///            appended to its `precedenceGroups` collection.
  @available(*, deprecated, message: "Use node.precedenceGroups.append(newElement) instead")
  public func addOtherName(_ element: PrecedenceGroupNameSyntax) -> PrecedenceGroupRelationSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.precedenceGroupNameList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrecedenceGroupRelationSyntax(newData)
  }
  
  public var unexpectedAfterPrecedenceGroups: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupRelationSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeHigherThanOrLowerThanLabel, 
          \Self.higherThanOrLowerThanLabel, 
          \Self.unexpectedBetweenHigherThanOrLowerThanLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndPrecedenceGroups, 
          \Self.precedenceGroups, 
          \Self.unexpectedAfterPrecedenceGroups
        ])
  }
}

// MARK: - PrefixOperatorExprSyntax

/// ### Children
/// 
///  - `operator`: `<prefixOperator>`
///  - `expression`: ``ExprSyntax``
public struct PrefixOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .prefixOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrefixOperatorExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .prefixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOperator: UnexpectedNodesSyntax? = nil,
      operator: TokenSyntax,
      _ unexpectedBetweenOperatorAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOperator, 
            `operator`, 
            unexpectedBetweenOperatorAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOperator?.raw, 
          `operator`.raw, 
          unexpectedBetweenOperatorAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.prefixOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var `operator`: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOperator, 
          \Self.operator, 
          \Self.unexpectedBetweenOperatorAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - PrimaryAssociatedTypeClauseSyntax

/// ### Children
/// 
///  - `leftAngle`: `'<'`
///  - `primaryAssociatedTypes`: ``PrimaryAssociatedTypeListSyntax``
///  - `rightAngle`: `'>'`
///
/// ### Contained in
/// 
///  - ``ProtocolDeclSyntax``.``ProtocolDeclSyntax/primaryAssociatedTypeClause``
public struct PrimaryAssociatedTypeClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .primaryAssociatedTypeClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrimaryAssociatedTypeClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .primaryAssociatedTypeClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftAngle: UnexpectedNodesSyntax? = nil,
      leftAngle: TokenSyntax = .leftAngleToken(),
      _ unexpectedBetweenLeftAngleAndPrimaryAssociatedTypes: UnexpectedNodesSyntax? = nil,
      primaryAssociatedTypes: PrimaryAssociatedTypeListSyntax,
      _ unexpectedBetweenPrimaryAssociatedTypesAndRightAngle: UnexpectedNodesSyntax? = nil,
      rightAngle: TokenSyntax = .rightAngleToken(),
      _ unexpectedAfterRightAngle: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftAngle, 
            leftAngle, 
            unexpectedBetweenLeftAngleAndPrimaryAssociatedTypes, 
            primaryAssociatedTypes, 
            unexpectedBetweenPrimaryAssociatedTypesAndRightAngle, 
            rightAngle, 
            unexpectedAfterRightAngle
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftAngle?.raw, 
          leftAngle.raw, 
          unexpectedBetweenLeftAngleAndPrimaryAssociatedTypes?.raw, 
          primaryAssociatedTypes.raw, 
          unexpectedBetweenPrimaryAssociatedTypesAndRightAngle?.raw, 
          rightAngle.raw, 
          unexpectedAfterRightAngle?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.primaryAssociatedTypeClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftAngle: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrimaryAssociatedTypeClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftAngleAndPrimaryAssociatedTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var primaryAssociatedTypes: PrimaryAssociatedTypeListSyntax {
    get {
      return PrimaryAssociatedTypeListSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = PrimaryAssociatedTypeClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `primaryAssociatedTypes`
  /// collection.
  ///
  /// - param element: The new `PrimaryAssociatedType` to add to the node's
  ///                  `primaryAssociatedTypes` collection.
  /// - returns: A copy of the receiver with the provided `PrimaryAssociatedType`
  ///            appended to its `primaryAssociatedTypes` collection.
  @available(*, deprecated, message: "Use node.primaryAssociatedTypes.append(newElement) instead")
  public func addPrimaryAssociatedType(_ element: PrimaryAssociatedTypeSyntax) -> PrimaryAssociatedTypeClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.primaryAssociatedTypeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrimaryAssociatedTypeClauseSyntax(newData)
  }
  
  public var unexpectedBetweenPrimaryAssociatedTypesAndRightAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightAngle: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = PrimaryAssociatedTypeClauseSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftAngle, 
          \Self.leftAngle, 
          \Self.unexpectedBetweenLeftAngleAndPrimaryAssociatedTypes, 
          \Self.primaryAssociatedTypes, 
          \Self.unexpectedBetweenPrimaryAssociatedTypesAndRightAngle, 
          \Self.rightAngle, 
          \Self.unexpectedAfterRightAngle
        ])
  }
}

// MARK: - PrimaryAssociatedTypeSyntax

/// ### Children
/// 
///  - `name`: `<identifier>`
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``PrimaryAssociatedTypeListSyntax``
public struct PrimaryAssociatedTypeSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .primaryAssociatedType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrimaryAssociatedTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .primaryAssociatedType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.primaryAssociatedType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = PrimaryAssociatedTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3).map(TokenSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrimaryAssociatedTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - ProtocolDeclSyntax

/// A `protocol` declaration
/// 
/// An example of a protocol declaration is
/// 
/// ```swift
/// protocol Example {
///   var isValid: Bool { get }
/// }
/// ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `protocolKeyword`: `'protocol'`
///  - `name`: `<identifier>`
///  - `primaryAssociatedTypeClause`: ``PrimaryAssociatedTypeClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct ProtocolDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .protocolDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ProtocolDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .protocolDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes attached to the protocol declaration, such as an `@available` attribute.
  ///   - modifiers: Modifiers attached to the protocol declaration, such as `public`.
  ///   - protocolKeyword: The `protocol` keyword for this declaration.
  ///   - name: The name of the protocol.
  ///   - primaryAssociatedTypeClause: The primary associated type for the protocol.
  ///   - inheritanceClause: The inheritance clause describing one or more conformances for this protocol declaration.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this protocol declaration.
  ///   - memberBlock: The members of the protocol declaration.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndProtocolKeyword: UnexpectedNodesSyntax? = nil,
      protocolKeyword: TokenSyntax = .keyword(.protocol),
      _ unexpectedBetweenProtocolKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndPrimaryAssociatedTypeClause: UnexpectedNodesSyntax? = nil,
      primaryAssociatedTypeClause: PrimaryAssociatedTypeClauseSyntax? = nil,
      _ unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndProtocolKeyword, 
            protocolKeyword, 
            unexpectedBetweenProtocolKeywordAndName, 
            name, 
            unexpectedBetweenNameAndPrimaryAssociatedTypeClause, 
            primaryAssociatedTypeClause, 
            unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndProtocolKeyword?.raw, 
          protocolKeyword.raw, 
          unexpectedBetweenProtocolKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndPrimaryAssociatedTypeClause?.raw, 
          primaryAssociatedTypeClause?.raw, 
          unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.protocolDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes attached to the protocol declaration, such as an `@available` attribute.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1)!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ProtocolDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the protocol declaration, such as `public`.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3)!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ProtocolDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndProtocolKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `protocol` keyword for this declaration.
  public var protocolKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5)!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenProtocolKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of the protocol.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7)!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndPrimaryAssociatedTypeClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The primary associated type for the protocol.
  public var primaryAssociatedTypeClause: PrimaryAssociatedTypeClauseSyntax? {
    get {
      return data.child(at: 9).map(PrimaryAssociatedTypeClauseSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The inheritance clause describing one or more conformances for this protocol declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this protocol declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The members of the protocol declaration.
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15)!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndProtocolKeyword, 
          \Self.protocolKeyword, 
          \Self.unexpectedBetweenProtocolKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndPrimaryAssociatedTypeClause, 
          \Self.primaryAssociatedTypeClause, 
          \Self.unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}
