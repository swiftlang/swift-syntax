//// Automatically generated by generate-swiftsyntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

public protocol SyntaxCollection: SyntaxProtocol, Sequence where Element: SyntaxProtocol {
  /// The number of elements, `present` or `missing`, in this collection.
  var count: Int {
    get
  }
}

public extension SyntaxCollection {
  static var structure: SyntaxNodeStructure {
    return .collection(Element.self)
  }
}

/// `AccessPathSyntax` represents a collection of one or more
/// `AccessPathComponent` nodes. AccessPathSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct AccessPathSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = AccessPathComponentSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .accessPath else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .accessPath)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.accessPath,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `AccessPathSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `AccessPathSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> AccessPathSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return AccessPathSyntax(newData)
  }
  
  /// Creates a new `AccessPathSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `AccessPathSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> AccessPathSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessPathSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `AccessPathSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> AccessPathSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `AccessPathSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `AccessPathSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> AccessPathSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessPathSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `AccessPathSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> AccessPathSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessPathSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `AccessPathSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> AccessPathSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessPathSyntax` by removing the first element.
  ///
  /// - Returns: A new `AccessPathSyntax` with the first element removed.
  public func removingFirst() -> AccessPathSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessPathSyntax` by removing the last element.
  ///
  /// - Returns: A new `AccessPathSyntax` with the last element removed.
  public func removingLast() -> AccessPathSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `AccessPathSyntax` to the `BidirectionalCollection` protocol.
extension AccessPathSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `AccessorListSyntax` represents a collection of one or more
/// `AccessorDecl` nodes. AccessorListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct AccessorListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = AccessorDeclSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .accessorList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .accessorList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.accessorList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `AccessorListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `AccessorListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> AccessorListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return AccessorListSyntax(newData)
  }
  
  /// Creates a new `AccessorListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `AccessorListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> AccessorListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessorListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `AccessorListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> AccessorListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `AccessorListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `AccessorListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> AccessorListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessorListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `AccessorListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> AccessorListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessorListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `AccessorListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> AccessorListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessorListSyntax` by removing the first element.
  ///
  /// - Returns: A new `AccessorListSyntax` with the first element removed.
  public func removingFirst() -> AccessorListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AccessorListSyntax` by removing the last element.
  ///
  /// - Returns: A new `AccessorListSyntax` with the last element removed.
  public func removingLast() -> AccessorListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `AccessorListSyntax` to the `BidirectionalCollection` protocol.
extension AccessorListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `ArrayElementListSyntax` represents a collection of one or more
/// `ArrayElement` nodes. ArrayElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct ArrayElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ArrayElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .arrayElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .arrayElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.arrayElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ArrayElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ArrayElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ArrayElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ArrayElementListSyntax(newData)
  }
  
  /// Creates a new `ArrayElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ArrayElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ArrayElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ArrayElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ArrayElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ArrayElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ArrayElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ArrayElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ArrayElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ArrayElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ArrayElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ArrayElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ArrayElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ArrayElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ArrayElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ArrayElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `ArrayElementListSyntax` with the first element removed.
  public func removingFirst() -> ArrayElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ArrayElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `ArrayElementListSyntax` with the last element removed.
  public func removingLast() -> ArrayElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ArrayElementListSyntax` to the `BidirectionalCollection` protocol.
extension ArrayElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `AttributeListSyntax` represents a collection of one or more
/// `Syntax` nodes. AttributeListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct AttributeListSyntax: SyntaxCollection, SyntaxHashable {
  @frozen // FIXME: Not actually stable, works around a miscompile
  public enum Element: SyntaxChildChoices {
    case `attribute`(AttributeSyntax)
    case `ifConfigDecl`(IfConfigDeclSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .attribute(let node):
        return node._syntaxNode
      case .ifConfigDecl(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: AttributeSyntax) {
      self = .attribute(node)
    }
    
    public init(_ node: IfConfigDeclSyntax) {
      self = .ifConfigDecl(node)
    }
    
    public init?<S: SyntaxProtocol>(_ node: S) {
      if let node = node.as(AttributeSyntax.self) {
        self = .attribute(node)
        return
      }
      if let node = node.as(IfConfigDeclSyntax.self) {
        self = .ifConfigDecl(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(AttributeSyntax.self),
          .node(IfConfigDeclSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .attributeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .attributeList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `AttributeListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `AttributeListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> AttributeListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return AttributeListSyntax(newData)
  }
  
  /// Creates a new `AttributeListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `AttributeListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> AttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AttributeListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `AttributeListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> AttributeListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `AttributeListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `AttributeListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> AttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AttributeListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `AttributeListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> AttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AttributeListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `AttributeListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> AttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AttributeListSyntax` by removing the first element.
  ///
  /// - Returns: A new `AttributeListSyntax` with the first element removed.
  public func removingFirst() -> AttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AttributeListSyntax` by removing the last element.
  ///
  /// - Returns: A new `AttributeListSyntax` with the last element removed.
  public func removingLast() -> AttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `AttributeListSyntax` to the `BidirectionalCollection` protocol.
extension AttributeListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `AvailabilitySpecListSyntax` represents a collection of one or more
/// `AvailabilityArgument` nodes. AvailabilitySpecListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct AvailabilitySpecListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = AvailabilityArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .availabilitySpecList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .availabilitySpecList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.availabilitySpecList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `AvailabilitySpecListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> AvailabilitySpecListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return AvailabilitySpecListSyntax(newData)
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `AvailabilitySpecListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> AvailabilitySpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `AvailabilitySpecListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> AvailabilitySpecListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `AvailabilitySpecListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> AvailabilitySpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `AvailabilitySpecListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> AvailabilitySpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `AvailabilitySpecListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> AvailabilitySpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by removing the first element.
  ///
  /// - Returns: A new `AvailabilitySpecListSyntax` with the first element removed.
  public func removingFirst() -> AvailabilitySpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilitySpecListSyntax` by removing the last element.
  ///
  /// - Returns: A new `AvailabilitySpecListSyntax` with the last element removed.
  public func removingLast() -> AvailabilitySpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `AvailabilitySpecListSyntax` to the `BidirectionalCollection` protocol.
extension AvailabilitySpecListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `AvailabilityVersionRestrictionListSyntax` represents a collection of one or more
/// `AvailabilityVersionRestrictionListEntry` nodes. AvailabilityVersionRestrictionListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct AvailabilityVersionRestrictionListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = AvailabilityVersionRestrictionListEntrySyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .availabilityVersionRestrictionList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .availabilityVersionRestrictionList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.availabilityVersionRestrictionList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> AvailabilityVersionRestrictionListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return AvailabilityVersionRestrictionListSyntax(newData)
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> AvailabilityVersionRestrictionListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> AvailabilityVersionRestrictionListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> AvailabilityVersionRestrictionListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> AvailabilityVersionRestrictionListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> AvailabilityVersionRestrictionListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by removing the first element.
  ///
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with the first element removed.
  public func removingFirst() -> AvailabilityVersionRestrictionListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `AvailabilityVersionRestrictionListSyntax` by removing the last element.
  ///
  /// - Returns: A new `AvailabilityVersionRestrictionListSyntax` with the last element removed.
  public func removingLast() -> AvailabilityVersionRestrictionListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `AvailabilityVersionRestrictionListSyntax` to the `BidirectionalCollection` protocol.
extension AvailabilityVersionRestrictionListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `CaseItemListSyntax` represents a collection of one or more
/// `CaseItem` nodes. CaseItemListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct CaseItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CaseItemSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .caseItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .caseItemList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.caseItemList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `CaseItemListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `CaseItemListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> CaseItemListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return CaseItemListSyntax(newData)
  }
  
  /// Creates a new `CaseItemListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `CaseItemListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> CaseItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CaseItemListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `CaseItemListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> CaseItemListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `CaseItemListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `CaseItemListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> CaseItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CaseItemListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `CaseItemListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> CaseItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CaseItemListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `CaseItemListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> CaseItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CaseItemListSyntax` by removing the first element.
  ///
  /// - Returns: A new `CaseItemListSyntax` with the first element removed.
  public func removingFirst() -> CaseItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CaseItemListSyntax` by removing the last element.
  ///
  /// - Returns: A new `CaseItemListSyntax` with the last element removed.
  public func removingLast() -> CaseItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `CaseItemListSyntax` to the `BidirectionalCollection` protocol.
extension CaseItemListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `CatchClauseListSyntax` represents a collection of one or more
/// `CatchClause` nodes. CatchClauseListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct CatchClauseListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CatchClauseSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .catchClauseList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .catchClauseList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.catchClauseList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `CatchClauseListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `CatchClauseListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> CatchClauseListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return CatchClauseListSyntax(newData)
  }
  
  /// Creates a new `CatchClauseListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `CatchClauseListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> CatchClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchClauseListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `CatchClauseListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> CatchClauseListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `CatchClauseListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `CatchClauseListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> CatchClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchClauseListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `CatchClauseListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> CatchClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchClauseListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `CatchClauseListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> CatchClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchClauseListSyntax` by removing the first element.
  ///
  /// - Returns: A new `CatchClauseListSyntax` with the first element removed.
  public func removingFirst() -> CatchClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchClauseListSyntax` by removing the last element.
  ///
  /// - Returns: A new `CatchClauseListSyntax` with the last element removed.
  public func removingLast() -> CatchClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `CatchClauseListSyntax` to the `BidirectionalCollection` protocol.
extension CatchClauseListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `CatchItemListSyntax` represents a collection of one or more
/// `CatchItem` nodes. CatchItemListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct CatchItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CatchItemSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .catchItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .catchItemList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.catchItemList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `CatchItemListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `CatchItemListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> CatchItemListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return CatchItemListSyntax(newData)
  }
  
  /// Creates a new `CatchItemListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `CatchItemListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> CatchItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchItemListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `CatchItemListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> CatchItemListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `CatchItemListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `CatchItemListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> CatchItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchItemListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `CatchItemListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> CatchItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchItemListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `CatchItemListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> CatchItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchItemListSyntax` by removing the first element.
  ///
  /// - Returns: A new `CatchItemListSyntax` with the first element removed.
  public func removingFirst() -> CatchItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CatchItemListSyntax` by removing the last element.
  ///
  /// - Returns: A new `CatchItemListSyntax` with the last element removed.
  public func removingLast() -> CatchItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `CatchItemListSyntax` to the `BidirectionalCollection` protocol.
extension CatchItemListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `ClosureCaptureItemListSyntax` represents a collection of one or more
/// `ClosureCaptureItem` nodes. ClosureCaptureItemListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct ClosureCaptureItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ClosureCaptureItemSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .closureCaptureItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureCaptureItemList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.closureCaptureItemList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ClosureCaptureItemListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ClosureCaptureItemListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ClosureCaptureItemListSyntax(newData)
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ClosureCaptureItemListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ClosureCaptureItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ClosureCaptureItemListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ClosureCaptureItemListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ClosureCaptureItemListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ClosureCaptureItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ClosureCaptureItemListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ClosureCaptureItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ClosureCaptureItemListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ClosureCaptureItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by removing the first element.
  ///
  /// - Returns: A new `ClosureCaptureItemListSyntax` with the first element removed.
  public func removingFirst() -> ClosureCaptureItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureCaptureItemListSyntax` by removing the last element.
  ///
  /// - Returns: A new `ClosureCaptureItemListSyntax` with the last element removed.
  public func removingLast() -> ClosureCaptureItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ClosureCaptureItemListSyntax` to the `BidirectionalCollection` protocol.
extension ClosureCaptureItemListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `ClosureParamListSyntax` represents a collection of one or more
/// `ClosureParam` nodes. ClosureParamListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct ClosureParamListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ClosureParamSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .closureParamList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureParamList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.closureParamList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ClosureParamListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ClosureParamListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ClosureParamListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ClosureParamListSyntax(newData)
  }
  
  /// Creates a new `ClosureParamListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ClosureParamListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ClosureParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParamListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ClosureParamListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ClosureParamListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ClosureParamListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ClosureParamListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ClosureParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParamListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ClosureParamListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ClosureParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParamListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ClosureParamListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ClosureParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParamListSyntax` by removing the first element.
  ///
  /// - Returns: A new `ClosureParamListSyntax` with the first element removed.
  public func removingFirst() -> ClosureParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParamListSyntax` by removing the last element.
  ///
  /// - Returns: A new `ClosureParamListSyntax` with the last element removed.
  public func removingLast() -> ClosureParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ClosureParamListSyntax` to the `BidirectionalCollection` protocol.
extension ClosureParamListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `ClosureParameterListSyntax` represents a collection of one or more
/// `ClosureParameter` nodes. ClosureParameterListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct ClosureParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ClosureParameterSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .closureParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureParameterList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.closureParameterList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ClosureParameterListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ClosureParameterListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ClosureParameterListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ClosureParameterListSyntax(newData)
  }
  
  /// Creates a new `ClosureParameterListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ClosureParameterListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ClosureParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParameterListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ClosureParameterListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ClosureParameterListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ClosureParameterListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ClosureParameterListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ClosureParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParameterListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ClosureParameterListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ClosureParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParameterListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ClosureParameterListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ClosureParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParameterListSyntax` by removing the first element.
  ///
  /// - Returns: A new `ClosureParameterListSyntax` with the first element removed.
  public func removingFirst() -> ClosureParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ClosureParameterListSyntax` by removing the last element.
  ///
  /// - Returns: A new `ClosureParameterListSyntax` with the last element removed.
  public func removingLast() -> ClosureParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ClosureParameterListSyntax` to the `BidirectionalCollection` protocol.
extension ClosureParameterListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `CodeBlockItemListSyntax` represents a collection of one or more
/// `CodeBlockItem` nodes. CodeBlockItemListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct CodeBlockItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CodeBlockItemSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .codeBlockItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .codeBlockItemList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.codeBlockItemList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `CodeBlockItemListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> CodeBlockItemListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return CodeBlockItemListSyntax(newData)
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `CodeBlockItemListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> CodeBlockItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `CodeBlockItemListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> CodeBlockItemListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `CodeBlockItemListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> CodeBlockItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `CodeBlockItemListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> CodeBlockItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `CodeBlockItemListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> CodeBlockItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by removing the first element.
  ///
  /// - Returns: A new `CodeBlockItemListSyntax` with the first element removed.
  public func removingFirst() -> CodeBlockItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CodeBlockItemListSyntax` by removing the last element.
  ///
  /// - Returns: A new `CodeBlockItemListSyntax` with the last element removed.
  public func removingLast() -> CodeBlockItemListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `CodeBlockItemListSyntax` to the `BidirectionalCollection` protocol.
extension CodeBlockItemListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `CompositionTypeElementListSyntax` represents a collection of one or more
/// `CompositionTypeElement` nodes. CompositionTypeElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct CompositionTypeElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CompositionTypeElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .compositionTypeElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .compositionTypeElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.compositionTypeElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `CompositionTypeElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> CompositionTypeElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return CompositionTypeElementListSyntax(newData)
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `CompositionTypeElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> CompositionTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `CompositionTypeElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> CompositionTypeElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `CompositionTypeElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> CompositionTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `CompositionTypeElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> CompositionTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `CompositionTypeElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> CompositionTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `CompositionTypeElementListSyntax` with the first element removed.
  public func removingFirst() -> CompositionTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `CompositionTypeElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `CompositionTypeElementListSyntax` with the last element removed.
  public func removingLast() -> CompositionTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `CompositionTypeElementListSyntax` to the `BidirectionalCollection` protocol.
extension CompositionTypeElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `ConditionElementListSyntax` represents a collection of one or more
/// `ConditionElement` nodes. ConditionElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct ConditionElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ConditionElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .conditionElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .conditionElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.conditionElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ConditionElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ConditionElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ConditionElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ConditionElementListSyntax(newData)
  }
  
  /// Creates a new `ConditionElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ConditionElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ConditionElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ConditionElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ConditionElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ConditionElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ConditionElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ConditionElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ConditionElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ConditionElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ConditionElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ConditionElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ConditionElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ConditionElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ConditionElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ConditionElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `ConditionElementListSyntax` with the first element removed.
  public func removingFirst() -> ConditionElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ConditionElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `ConditionElementListSyntax` with the last element removed.
  public func removingLast() -> ConditionElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ConditionElementListSyntax` to the `BidirectionalCollection` protocol.
extension ConditionElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `DeclNameArgumentListSyntax` represents a collection of one or more
/// `DeclNameArgument` nodes. DeclNameArgumentListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct DeclNameArgumentListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DeclNameArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .declNameArgumentList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .declNameArgumentList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.declNameArgumentList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `DeclNameArgumentListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> DeclNameArgumentListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return DeclNameArgumentListSyntax(newData)
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `DeclNameArgumentListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> DeclNameArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `DeclNameArgumentListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> DeclNameArgumentListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `DeclNameArgumentListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> DeclNameArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `DeclNameArgumentListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> DeclNameArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `DeclNameArgumentListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> DeclNameArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by removing the first element.
  ///
  /// - Returns: A new `DeclNameArgumentListSyntax` with the first element removed.
  public func removingFirst() -> DeclNameArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DeclNameArgumentListSyntax` by removing the last element.
  ///
  /// - Returns: A new `DeclNameArgumentListSyntax` with the last element removed.
  public func removingLast() -> DeclNameArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `DeclNameArgumentListSyntax` to the `BidirectionalCollection` protocol.
extension DeclNameArgumentListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `DesignatedTypeListSyntax` represents a collection of one or more
/// `DesignatedTypeElement` nodes. DesignatedTypeListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct DesignatedTypeListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DesignatedTypeElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .designatedTypeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .designatedTypeList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.designatedTypeList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `DesignatedTypeListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> DesignatedTypeListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return DesignatedTypeListSyntax(newData)
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `DesignatedTypeListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> DesignatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `DesignatedTypeListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> DesignatedTypeListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `DesignatedTypeListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> DesignatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `DesignatedTypeListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> DesignatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `DesignatedTypeListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> DesignatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by removing the first element.
  ///
  /// - Returns: A new `DesignatedTypeListSyntax` with the first element removed.
  public func removingFirst() -> DesignatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DesignatedTypeListSyntax` by removing the last element.
  ///
  /// - Returns: A new `DesignatedTypeListSyntax` with the last element removed.
  public func removingLast() -> DesignatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `DesignatedTypeListSyntax` to the `BidirectionalCollection` protocol.
extension DesignatedTypeListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `DictionaryElementListSyntax` represents a collection of one or more
/// `DictionaryElement` nodes. DictionaryElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct DictionaryElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DictionaryElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .dictionaryElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .dictionaryElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.dictionaryElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `DictionaryElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `DictionaryElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> DictionaryElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return DictionaryElementListSyntax(newData)
  }
  
  /// Creates a new `DictionaryElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `DictionaryElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> DictionaryElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DictionaryElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `DictionaryElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> DictionaryElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `DictionaryElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `DictionaryElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> DictionaryElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DictionaryElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `DictionaryElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> DictionaryElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DictionaryElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `DictionaryElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> DictionaryElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DictionaryElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `DictionaryElementListSyntax` with the first element removed.
  public func removingFirst() -> DictionaryElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DictionaryElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `DictionaryElementListSyntax` with the last element removed.
  public func removingLast() -> DictionaryElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `DictionaryElementListSyntax` to the `BidirectionalCollection` protocol.
extension DictionaryElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `DifferentiabilityParamListSyntax` represents a collection of one or more
/// `DifferentiabilityParam` nodes. DifferentiabilityParamListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct DifferentiabilityParamListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DifferentiabilityParamSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .differentiabilityParamList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .differentiabilityParamList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.differentiabilityParamList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `DifferentiabilityParamListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> DifferentiabilityParamListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return DifferentiabilityParamListSyntax(newData)
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `DifferentiabilityParamListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> DifferentiabilityParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `DifferentiabilityParamListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> DifferentiabilityParamListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `DifferentiabilityParamListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> DifferentiabilityParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `DifferentiabilityParamListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> DifferentiabilityParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `DifferentiabilityParamListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> DifferentiabilityParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by removing the first element.
  ///
  /// - Returns: A new `DifferentiabilityParamListSyntax` with the first element removed.
  public func removingFirst() -> DifferentiabilityParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DifferentiabilityParamListSyntax` by removing the last element.
  ///
  /// - Returns: A new `DifferentiabilityParamListSyntax` with the last element removed.
  public func removingLast() -> DifferentiabilityParamListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `DifferentiabilityParamListSyntax` to the `BidirectionalCollection` protocol.
extension DifferentiabilityParamListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// The arguments of the '@_documentation' attribute
public struct DocumentationAttributeArgumentsSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DocumentationAttributeArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .documentationAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .documentationAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.documentationAttributeArguments,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> DocumentationAttributeArgumentsSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return DocumentationAttributeArgumentsSyntax(newData)
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> DocumentationAttributeArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> DocumentationAttributeArgumentsSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> DocumentationAttributeArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> DocumentationAttributeArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> DocumentationAttributeArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by removing the first element.
  ///
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with the first element removed.
  public func removingFirst() -> DocumentationAttributeArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `DocumentationAttributeArgumentsSyntax` by removing the last element.
  ///
  /// - Returns: A new `DocumentationAttributeArgumentsSyntax` with the last element removed.
  public func removingLast() -> DocumentationAttributeArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `DocumentationAttributeArgumentsSyntax` to the `BidirectionalCollection` protocol.
extension DocumentationAttributeArgumentsSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// The arguments of the '@_effect' attribute. These will be parsed during the SIL stage.
public struct EffectsArgumentsSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TokenSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .effectsArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .effectsArguments)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.effectsArguments,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `EffectsArgumentsSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> EffectsArgumentsSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return EffectsArgumentsSyntax(newData)
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `EffectsArgumentsSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> EffectsArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `EffectsArgumentsSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> EffectsArgumentsSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `EffectsArgumentsSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> EffectsArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `EffectsArgumentsSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> EffectsArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `EffectsArgumentsSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> EffectsArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by removing the first element.
  ///
  /// - Returns: A new `EffectsArgumentsSyntax` with the first element removed.
  public func removingFirst() -> EffectsArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EffectsArgumentsSyntax` by removing the last element.
  ///
  /// - Returns: A new `EffectsArgumentsSyntax` with the last element removed.
  public func removingLast() -> EffectsArgumentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `EffectsArgumentsSyntax` to the `BidirectionalCollection` protocol.
extension EffectsArgumentsSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// A collection of 0 or more `EnumCaseElement`s.
public struct EnumCaseElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = EnumCaseElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .enumCaseElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumCaseElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.enumCaseElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `EnumCaseElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> EnumCaseElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return EnumCaseElementListSyntax(newData)
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `EnumCaseElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> EnumCaseElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `EnumCaseElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> EnumCaseElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `EnumCaseElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> EnumCaseElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `EnumCaseElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> EnumCaseElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `EnumCaseElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> EnumCaseElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `EnumCaseElementListSyntax` with the first element removed.
  public func removingFirst() -> EnumCaseElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `EnumCaseElementListSyntax` with the last element removed.
  public func removingLast() -> EnumCaseElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `EnumCaseElementListSyntax` to the `BidirectionalCollection` protocol.
extension EnumCaseElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `EnumCaseParameterListSyntax` represents a collection of one or more
/// `EnumCaseParameter` nodes. EnumCaseParameterListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct EnumCaseParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = EnumCaseParameterSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .enumCaseParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumCaseParameterList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.enumCaseParameterList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `EnumCaseParameterListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> EnumCaseParameterListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return EnumCaseParameterListSyntax(newData)
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `EnumCaseParameterListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> EnumCaseParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `EnumCaseParameterListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> EnumCaseParameterListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `EnumCaseParameterListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> EnumCaseParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `EnumCaseParameterListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> EnumCaseParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `EnumCaseParameterListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> EnumCaseParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by removing the first element.
  ///
  /// - Returns: A new `EnumCaseParameterListSyntax` with the first element removed.
  public func removingFirst() -> EnumCaseParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `EnumCaseParameterListSyntax` by removing the last element.
  ///
  /// - Returns: A new `EnumCaseParameterListSyntax` with the last element removed.
  public func removingLast() -> EnumCaseParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `EnumCaseParameterListSyntax` to the `BidirectionalCollection` protocol.
extension EnumCaseParameterListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// A list of expressions connected by operators. This list is contained by a `SequenceExprSyntax`.
public struct ExprListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ExprSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .exprList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .exprList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.exprList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ExprListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ExprListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ExprListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ExprListSyntax(newData)
  }
  
  /// Creates a new `ExprListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ExprListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ExprListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ExprListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ExprListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ExprListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ExprListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ExprListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ExprListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ExprListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ExprListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ExprListSyntax` by removing the first element.
  ///
  /// - Returns: A new `ExprListSyntax` with the first element removed.
  public func removingFirst() -> ExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ExprListSyntax` by removing the last element.
  ///
  /// - Returns: A new `ExprListSyntax` with the last element removed.
  public func removingLast() -> ExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ExprListSyntax` to the `BidirectionalCollection` protocol.
extension ExprListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `FunctionParameterListSyntax` represents a collection of one or more
/// `FunctionParameter` nodes. FunctionParameterListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct FunctionParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = FunctionParameterSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .functionParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionParameterList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.functionParameterList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `FunctionParameterListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `FunctionParameterListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> FunctionParameterListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return FunctionParameterListSyntax(newData)
  }
  
  /// Creates a new `FunctionParameterListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `FunctionParameterListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> FunctionParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `FunctionParameterListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `FunctionParameterListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> FunctionParameterListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `FunctionParameterListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `FunctionParameterListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> FunctionParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `FunctionParameterListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `FunctionParameterListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> FunctionParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `FunctionParameterListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `FunctionParameterListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> FunctionParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `FunctionParameterListSyntax` by removing the first element.
  ///
  /// - Returns: A new `FunctionParameterListSyntax` with the first element removed.
  public func removingFirst() -> FunctionParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `FunctionParameterListSyntax` by removing the last element.
  ///
  /// - Returns: A new `FunctionParameterListSyntax` with the last element removed.
  public func removingLast() -> FunctionParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `FunctionParameterListSyntax` to the `BidirectionalCollection` protocol.
extension FunctionParameterListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `GenericArgumentListSyntax` represents a collection of one or more
/// `GenericArgument` nodes. GenericArgumentListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct GenericArgumentListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = GenericArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .genericArgumentList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericArgumentList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.genericArgumentList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `GenericArgumentListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `GenericArgumentListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> GenericArgumentListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return GenericArgumentListSyntax(newData)
  }
  
  /// Creates a new `GenericArgumentListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `GenericArgumentListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> GenericArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericArgumentListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `GenericArgumentListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> GenericArgumentListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `GenericArgumentListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `GenericArgumentListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> GenericArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericArgumentListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `GenericArgumentListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> GenericArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericArgumentListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `GenericArgumentListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> GenericArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericArgumentListSyntax` by removing the first element.
  ///
  /// - Returns: A new `GenericArgumentListSyntax` with the first element removed.
  public func removingFirst() -> GenericArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericArgumentListSyntax` by removing the last element.
  ///
  /// - Returns: A new `GenericArgumentListSyntax` with the last element removed.
  public func removingLast() -> GenericArgumentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `GenericArgumentListSyntax` to the `BidirectionalCollection` protocol.
extension GenericArgumentListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `GenericParameterListSyntax` represents a collection of one or more
/// `GenericParameter` nodes. GenericParameterListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct GenericParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = GenericParameterSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .genericParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericParameterList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.genericParameterList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `GenericParameterListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `GenericParameterListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> GenericParameterListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return GenericParameterListSyntax(newData)
  }
  
  /// Creates a new `GenericParameterListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `GenericParameterListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> GenericParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericParameterListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `GenericParameterListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> GenericParameterListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `GenericParameterListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `GenericParameterListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> GenericParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericParameterListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `GenericParameterListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> GenericParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericParameterListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `GenericParameterListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> GenericParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericParameterListSyntax` by removing the first element.
  ///
  /// - Returns: A new `GenericParameterListSyntax` with the first element removed.
  public func removingFirst() -> GenericParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericParameterListSyntax` by removing the last element.
  ///
  /// - Returns: A new `GenericParameterListSyntax` with the last element removed.
  public func removingLast() -> GenericParameterListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `GenericParameterListSyntax` to the `BidirectionalCollection` protocol.
extension GenericParameterListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `GenericRequirementListSyntax` represents a collection of one or more
/// `GenericRequirement` nodes. GenericRequirementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct GenericRequirementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = GenericRequirementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .genericRequirementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericRequirementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.genericRequirementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `GenericRequirementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `GenericRequirementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> GenericRequirementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return GenericRequirementListSyntax(newData)
  }
  
  /// Creates a new `GenericRequirementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `GenericRequirementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> GenericRequirementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericRequirementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `GenericRequirementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> GenericRequirementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `GenericRequirementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `GenericRequirementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> GenericRequirementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericRequirementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `GenericRequirementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> GenericRequirementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericRequirementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `GenericRequirementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> GenericRequirementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericRequirementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `GenericRequirementListSyntax` with the first element removed.
  public func removingFirst() -> GenericRequirementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `GenericRequirementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `GenericRequirementListSyntax` with the last element removed.
  public func removingLast() -> GenericRequirementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `GenericRequirementListSyntax` to the `BidirectionalCollection` protocol.
extension GenericRequirementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `IfConfigClauseListSyntax` represents a collection of one or more
/// `IfConfigClause` nodes. IfConfigClauseListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct IfConfigClauseListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = IfConfigClauseSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .ifConfigClauseList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ifConfigClauseList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.ifConfigClauseList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `IfConfigClauseListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> IfConfigClauseListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return IfConfigClauseListSyntax(newData)
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `IfConfigClauseListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> IfConfigClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `IfConfigClauseListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> IfConfigClauseListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `IfConfigClauseListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> IfConfigClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `IfConfigClauseListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> IfConfigClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `IfConfigClauseListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> IfConfigClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by removing the first element.
  ///
  /// - Returns: A new `IfConfigClauseListSyntax` with the first element removed.
  public func removingFirst() -> IfConfigClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `IfConfigClauseListSyntax` by removing the last element.
  ///
  /// - Returns: A new `IfConfigClauseListSyntax` with the last element removed.
  public func removingLast() -> IfConfigClauseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `IfConfigClauseListSyntax` to the `BidirectionalCollection` protocol.
extension IfConfigClauseListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `InheritedTypeListSyntax` represents a collection of one or more
/// `InheritedType` nodes. InheritedTypeListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct InheritedTypeListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = InheritedTypeSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .inheritedTypeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .inheritedTypeList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.inheritedTypeList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `InheritedTypeListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `InheritedTypeListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> InheritedTypeListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return InheritedTypeListSyntax(newData)
  }
  
  /// Creates a new `InheritedTypeListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `InheritedTypeListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> InheritedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `InheritedTypeListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `InheritedTypeListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> InheritedTypeListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `InheritedTypeListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `InheritedTypeListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> InheritedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `InheritedTypeListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `InheritedTypeListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> InheritedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `InheritedTypeListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `InheritedTypeListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> InheritedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `InheritedTypeListSyntax` by removing the first element.
  ///
  /// - Returns: A new `InheritedTypeListSyntax` with the first element removed.
  public func removingFirst() -> InheritedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `InheritedTypeListSyntax` by removing the last element.
  ///
  /// - Returns: A new `InheritedTypeListSyntax` with the last element removed.
  public func removingLast() -> InheritedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `InheritedTypeListSyntax` to the `BidirectionalCollection` protocol.
extension InheritedTypeListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `KeyPathComponentListSyntax` represents a collection of one or more
/// `KeyPathComponent` nodes. KeyPathComponentListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct KeyPathComponentListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = KeyPathComponentSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .keyPathComponentList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .keyPathComponentList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.keyPathComponentList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `KeyPathComponentListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> KeyPathComponentListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return KeyPathComponentListSyntax(newData)
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `KeyPathComponentListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> KeyPathComponentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `KeyPathComponentListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> KeyPathComponentListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `KeyPathComponentListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> KeyPathComponentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `KeyPathComponentListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> KeyPathComponentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `KeyPathComponentListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> KeyPathComponentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by removing the first element.
  ///
  /// - Returns: A new `KeyPathComponentListSyntax` with the first element removed.
  public func removingFirst() -> KeyPathComponentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `KeyPathComponentListSyntax` by removing the last element.
  ///
  /// - Returns: A new `KeyPathComponentListSyntax` with the last element removed.
  public func removingLast() -> KeyPathComponentListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `KeyPathComponentListSyntax` to the `BidirectionalCollection` protocol.
extension KeyPathComponentListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `MemberDeclListSyntax` represents a collection of one or more
/// `MemberDeclListItem` nodes. MemberDeclListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct MemberDeclListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = MemberDeclListItemSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .memberDeclList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .memberDeclList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.memberDeclList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `MemberDeclListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `MemberDeclListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> MemberDeclListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return MemberDeclListSyntax(newData)
  }
  
  /// Creates a new `MemberDeclListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `MemberDeclListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> MemberDeclListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MemberDeclListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `MemberDeclListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> MemberDeclListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `MemberDeclListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `MemberDeclListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> MemberDeclListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MemberDeclListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `MemberDeclListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> MemberDeclListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MemberDeclListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `MemberDeclListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> MemberDeclListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MemberDeclListSyntax` by removing the first element.
  ///
  /// - Returns: A new `MemberDeclListSyntax` with the first element removed.
  public func removingFirst() -> MemberDeclListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MemberDeclListSyntax` by removing the last element.
  ///
  /// - Returns: A new `MemberDeclListSyntax` with the last element removed.
  public func removingLast() -> MemberDeclListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `MemberDeclListSyntax` to the `BidirectionalCollection` protocol.
extension MemberDeclListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `ModifierListSyntax` represents a collection of one or more
/// `DeclModifier` nodes. ModifierListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct ModifierListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DeclModifierSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .modifierList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .modifierList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.modifierList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ModifierListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ModifierListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ModifierListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ModifierListSyntax(newData)
  }
  
  /// Creates a new `ModifierListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ModifierListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ModifierListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ModifierListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ModifierListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ModifierListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ModifierListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ModifierListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ModifierListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ModifierListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ModifierListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ModifierListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ModifierListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ModifierListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ModifierListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ModifierListSyntax` by removing the first element.
  ///
  /// - Returns: A new `ModifierListSyntax` with the first element removed.
  public func removingFirst() -> ModifierListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ModifierListSyntax` by removing the last element.
  ///
  /// - Returns: A new `ModifierListSyntax` with the last element removed.
  public func removingLast() -> ModifierListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ModifierListSyntax` to the `BidirectionalCollection` protocol.
extension ModifierListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `MultipleTrailingClosureElementListSyntax` represents a collection of one or more
/// `MultipleTrailingClosureElement` nodes. MultipleTrailingClosureElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct MultipleTrailingClosureElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = MultipleTrailingClosureElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .multipleTrailingClosureElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .multipleTrailingClosureElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> MultipleTrailingClosureElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return MultipleTrailingClosureElementListSyntax(newData)
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> MultipleTrailingClosureElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> MultipleTrailingClosureElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> MultipleTrailingClosureElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> MultipleTrailingClosureElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> MultipleTrailingClosureElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with the first element removed.
  public func removingFirst() -> MultipleTrailingClosureElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `MultipleTrailingClosureElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `MultipleTrailingClosureElementListSyntax` with the last element removed.
  public func removingLast() -> MultipleTrailingClosureElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `MultipleTrailingClosureElementListSyntax` to the `BidirectionalCollection` protocol.
extension MultipleTrailingClosureElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `ObjCSelectorSyntax` represents a collection of one or more
/// `ObjCSelectorPiece` nodes. ObjCSelectorSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct ObjCSelectorSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ObjCSelectorPieceSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .objCSelector else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .objCSelector)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.objCSelector,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `ObjCSelectorSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `ObjCSelectorSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> ObjCSelectorSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return ObjCSelectorSyntax(newData)
  }
  
  /// Creates a new `ObjCSelectorSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `ObjCSelectorSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> ObjCSelectorSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ObjCSelectorSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `ObjCSelectorSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> ObjCSelectorSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `ObjCSelectorSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `ObjCSelectorSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> ObjCSelectorSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ObjCSelectorSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `ObjCSelectorSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> ObjCSelectorSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ObjCSelectorSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `ObjCSelectorSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ObjCSelectorSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ObjCSelectorSyntax` by removing the first element.
  ///
  /// - Returns: A new `ObjCSelectorSyntax` with the first element removed.
  public func removingFirst() -> ObjCSelectorSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `ObjCSelectorSyntax` by removing the last element.
  ///
  /// - Returns: A new `ObjCSelectorSyntax` with the last element removed.
  public func removingLast() -> ObjCSelectorSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `ObjCSelectorSyntax` to the `BidirectionalCollection` protocol.
extension ObjCSelectorSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `PatternBindingListSyntax` represents a collection of one or more
/// `PatternBinding` nodes. PatternBindingListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct PatternBindingListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = PatternBindingSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .patternBindingList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .patternBindingList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.patternBindingList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `PatternBindingListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `PatternBindingListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> PatternBindingListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return PatternBindingListSyntax(newData)
  }
  
  /// Creates a new `PatternBindingListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `PatternBindingListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> PatternBindingListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PatternBindingListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `PatternBindingListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> PatternBindingListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `PatternBindingListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `PatternBindingListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> PatternBindingListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PatternBindingListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `PatternBindingListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> PatternBindingListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PatternBindingListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `PatternBindingListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> PatternBindingListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PatternBindingListSyntax` by removing the first element.
  ///
  /// - Returns: A new `PatternBindingListSyntax` with the first element removed.
  public func removingFirst() -> PatternBindingListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PatternBindingListSyntax` by removing the last element.
  ///
  /// - Returns: A new `PatternBindingListSyntax` with the last element removed.
  public func removingLast() -> PatternBindingListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `PatternBindingListSyntax` to the `BidirectionalCollection` protocol.
extension PatternBindingListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `PrecedenceGroupAttributeListSyntax` represents a collection of one or more
/// `Syntax` nodes. PrecedenceGroupAttributeListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct PrecedenceGroupAttributeListSyntax: SyntaxCollection, SyntaxHashable {
  @frozen // FIXME: Not actually stable, works around a miscompile
  public enum Element: SyntaxChildChoices {
    case `precedenceGroupRelation`(PrecedenceGroupRelationSyntax)
    case `precedenceGroupAssignment`(PrecedenceGroupAssignmentSyntax)
    case `precedenceGroupAssociativity`(PrecedenceGroupAssociativitySyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .precedenceGroupRelation(let node):
        return node._syntaxNode
      case .precedenceGroupAssignment(let node):
        return node._syntaxNode
      case .precedenceGroupAssociativity(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: PrecedenceGroupRelationSyntax) {
      self = .precedenceGroupRelation(node)
    }
    
    public init(_ node: PrecedenceGroupAssignmentSyntax) {
      self = .precedenceGroupAssignment(node)
    }
    
    public init(_ node: PrecedenceGroupAssociativitySyntax) {
      self = .precedenceGroupAssociativity(node)
    }
    
    public init?<S: SyntaxProtocol>(_ node: S) {
      if let node = node.as(PrecedenceGroupRelationSyntax.self) {
        self = .precedenceGroupRelation(node)
        return
      }
      if let node = node.as(PrecedenceGroupAssignmentSyntax.self) {
        self = .precedenceGroupAssignment(node)
        return
      }
      if let node = node.as(PrecedenceGroupAssociativitySyntax.self) {
        self = .precedenceGroupAssociativity(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(PrecedenceGroupRelationSyntax.self),
          .node(PrecedenceGroupAssignmentSyntax.self),
          .node(PrecedenceGroupAssociativitySyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .precedenceGroupAttributeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupAttributeList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.precedenceGroupAttributeList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> PrecedenceGroupAttributeListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return PrecedenceGroupAttributeListSyntax(newData)
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> PrecedenceGroupAttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> PrecedenceGroupAttributeListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> PrecedenceGroupAttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> PrecedenceGroupAttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> PrecedenceGroupAttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by removing the first element.
  ///
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with the first element removed.
  public func removingFirst() -> PrecedenceGroupAttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupAttributeListSyntax` by removing the last element.
  ///
  /// - Returns: A new `PrecedenceGroupAttributeListSyntax` with the last element removed.
  public func removingLast() -> PrecedenceGroupAttributeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `PrecedenceGroupAttributeListSyntax` to the `BidirectionalCollection` protocol.
extension PrecedenceGroupAttributeListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `PrecedenceGroupNameListSyntax` represents a collection of one or more
/// `PrecedenceGroupNameElement` nodes. PrecedenceGroupNameListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct PrecedenceGroupNameListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = PrecedenceGroupNameElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .precedenceGroupNameList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupNameList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.precedenceGroupNameList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> PrecedenceGroupNameListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return PrecedenceGroupNameListSyntax(newData)
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> PrecedenceGroupNameListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> PrecedenceGroupNameListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> PrecedenceGroupNameListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> PrecedenceGroupNameListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> PrecedenceGroupNameListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by removing the first element.
  ///
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with the first element removed.
  public func removingFirst() -> PrecedenceGroupNameListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrecedenceGroupNameListSyntax` by removing the last element.
  ///
  /// - Returns: A new `PrecedenceGroupNameListSyntax` with the last element removed.
  public func removingLast() -> PrecedenceGroupNameListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `PrecedenceGroupNameListSyntax` to the `BidirectionalCollection` protocol.
extension PrecedenceGroupNameListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `PrimaryAssociatedTypeListSyntax` represents a collection of one or more
/// `PrimaryAssociatedType` nodes. PrimaryAssociatedTypeListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct PrimaryAssociatedTypeListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = PrimaryAssociatedTypeSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .primaryAssociatedTypeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .primaryAssociatedTypeList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.primaryAssociatedTypeList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> PrimaryAssociatedTypeListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return PrimaryAssociatedTypeListSyntax(newData)
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> PrimaryAssociatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> PrimaryAssociatedTypeListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> PrimaryAssociatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> PrimaryAssociatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> PrimaryAssociatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by removing the first element.
  ///
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with the first element removed.
  public func removingFirst() -> PrimaryAssociatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `PrimaryAssociatedTypeListSyntax` by removing the last element.
  ///
  /// - Returns: A new `PrimaryAssociatedTypeListSyntax` with the last element removed.
  public func removingLast() -> PrimaryAssociatedTypeListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `PrimaryAssociatedTypeListSyntax` to the `BidirectionalCollection` protocol.
extension PrimaryAssociatedTypeListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// A collection of arguments for the `@_specialize` attribute
public struct SpecializeAttributeSpecListSyntax: SyntaxCollection, SyntaxHashable {
  @frozen // FIXME: Not actually stable, works around a miscompile
  public enum Element: SyntaxChildChoices {
    case `labeledSpecializeEntry`(LabeledSpecializeEntrySyntax)
    case `availabilityEntry`(AvailabilityEntrySyntax)
    case `targetFunctionEntry`(TargetFunctionEntrySyntax)
    case `genericWhereClause`(GenericWhereClauseSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .labeledSpecializeEntry(let node):
        return node._syntaxNode
      case .availabilityEntry(let node):
        return node._syntaxNode
      case .targetFunctionEntry(let node):
        return node._syntaxNode
      case .genericWhereClause(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: LabeledSpecializeEntrySyntax) {
      self = .labeledSpecializeEntry(node)
    }
    
    public init(_ node: AvailabilityEntrySyntax) {
      self = .availabilityEntry(node)
    }
    
    public init(_ node: TargetFunctionEntrySyntax) {
      self = .targetFunctionEntry(node)
    }
    
    public init(_ node: GenericWhereClauseSyntax) {
      self = .genericWhereClause(node)
    }
    
    public init?<S: SyntaxProtocol>(_ node: S) {
      if let node = node.as(LabeledSpecializeEntrySyntax.self) {
        self = .labeledSpecializeEntry(node)
        return
      }
      if let node = node.as(AvailabilityEntrySyntax.self) {
        self = .availabilityEntry(node)
        return
      }
      if let node = node.as(TargetFunctionEntrySyntax.self) {
        self = .targetFunctionEntry(node)
        return
      }
      if let node = node.as(GenericWhereClauseSyntax.self) {
        self = .genericWhereClause(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
            .node(LabeledSpecializeEntrySyntax.self),
            .node(AvailabilityEntrySyntax.self),
            .node(TargetFunctionEntrySyntax.self),
            .node(GenericWhereClauseSyntax.self)
          ])
    }
  }
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .specializeAttributeSpecList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .specializeAttributeSpecList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.specializeAttributeSpecList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> SpecializeAttributeSpecListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return SpecializeAttributeSpecListSyntax(newData)
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> SpecializeAttributeSpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> SpecializeAttributeSpecListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> SpecializeAttributeSpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> SpecializeAttributeSpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> SpecializeAttributeSpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by removing the first element.
  ///
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with the first element removed.
  public func removingFirst() -> SpecializeAttributeSpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SpecializeAttributeSpecListSyntax` by removing the last element.
  ///
  /// - Returns: A new `SpecializeAttributeSpecListSyntax` with the last element removed.
  public func removingLast() -> SpecializeAttributeSpecListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `SpecializeAttributeSpecListSyntax` to the `BidirectionalCollection` protocol.
extension SpecializeAttributeSpecListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `StringLiteralSegmentsSyntax` represents a collection of one or more
/// `Syntax` nodes. StringLiteralSegmentsSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct StringLiteralSegmentsSyntax: SyntaxCollection, SyntaxHashable {
  @frozen // FIXME: Not actually stable, works around a miscompile
  public enum Element: SyntaxChildChoices {
    case `stringSegment`(StringSegmentSyntax)
    case `expressionSegment`(ExpressionSegmentSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .stringSegment(let node):
        return node._syntaxNode
      case .expressionSegment(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: StringSegmentSyntax) {
      self = .stringSegment(node)
    }
    
    public init(_ node: ExpressionSegmentSyntax) {
      self = .expressionSegment(node)
    }
    
    public init?<S: SyntaxProtocol>(_ node: S) {
      if let node = node.as(StringSegmentSyntax.self) {
        self = .stringSegment(node)
        return
      }
      if let node = node.as(ExpressionSegmentSyntax.self) {
        self = .expressionSegment(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(StringSegmentSyntax.self),
          .node(ExpressionSegmentSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .stringLiteralSegments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .stringLiteralSegments)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.stringLiteralSegments,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `StringLiteralSegmentsSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> StringLiteralSegmentsSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return StringLiteralSegmentsSyntax(newData)
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `StringLiteralSegmentsSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> StringLiteralSegmentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `StringLiteralSegmentsSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> StringLiteralSegmentsSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `StringLiteralSegmentsSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> StringLiteralSegmentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `StringLiteralSegmentsSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> StringLiteralSegmentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `StringLiteralSegmentsSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> StringLiteralSegmentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by removing the first element.
  ///
  /// - Returns: A new `StringLiteralSegmentsSyntax` with the first element removed.
  public func removingFirst() -> StringLiteralSegmentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `StringLiteralSegmentsSyntax` by removing the last element.
  ///
  /// - Returns: A new `StringLiteralSegmentsSyntax` with the last element removed.
  public func removingLast() -> StringLiteralSegmentsSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `StringLiteralSegmentsSyntax` to the `BidirectionalCollection` protocol.
extension StringLiteralSegmentsSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `SwitchCaseListSyntax` represents a collection of one or more
/// `Syntax` nodes. SwitchCaseListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct SwitchCaseListSyntax: SyntaxCollection, SyntaxHashable {
  @frozen // FIXME: Not actually stable, works around a miscompile
  public enum Element: SyntaxChildChoices {
    case `switchCase`(SwitchCaseSyntax)
    case `ifConfigDecl`(IfConfigDeclSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .switchCase(let node):
        return node._syntaxNode
      case .ifConfigDecl(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: SwitchCaseSyntax) {
      self = .switchCase(node)
    }
    
    public init(_ node: IfConfigDeclSyntax) {
      self = .ifConfigDecl(node)
    }
    
    public init?<S: SyntaxProtocol>(_ node: S) {
      if let node = node.as(SwitchCaseSyntax.self) {
        self = .switchCase(node)
        return
      }
      if let node = node.as(IfConfigDeclSyntax.self) {
        self = .ifConfigDecl(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(SwitchCaseSyntax.self),
          .node(IfConfigDeclSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .switchCaseList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .switchCaseList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.switchCaseList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `SwitchCaseListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `SwitchCaseListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> SwitchCaseListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return SwitchCaseListSyntax(newData)
  }
  
  /// Creates a new `SwitchCaseListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `SwitchCaseListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> SwitchCaseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SwitchCaseListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `SwitchCaseListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> SwitchCaseListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `SwitchCaseListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `SwitchCaseListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> SwitchCaseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SwitchCaseListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `SwitchCaseListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> SwitchCaseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SwitchCaseListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `SwitchCaseListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> SwitchCaseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SwitchCaseListSyntax` by removing the first element.
  ///
  /// - Returns: A new `SwitchCaseListSyntax` with the first element removed.
  public func removingFirst() -> SwitchCaseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `SwitchCaseListSyntax` by removing the last element.
  ///
  /// - Returns: A new `SwitchCaseListSyntax` with the last element removed.
  public func removingLast() -> SwitchCaseListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `SwitchCaseListSyntax` to the `BidirectionalCollection` protocol.
extension SwitchCaseListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `TupleExprElementListSyntax` represents a collection of one or more
/// `TupleExprElement` nodes. TupleExprElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct TupleExprElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TupleExprElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .tupleExprElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .tupleExprElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `TupleExprElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `TupleExprElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> TupleExprElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return TupleExprElementListSyntax(newData)
  }
  
  /// Creates a new `TupleExprElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `TupleExprElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> TupleExprElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleExprElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `TupleExprElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> TupleExprElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `TupleExprElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `TupleExprElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> TupleExprElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleExprElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `TupleExprElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> TupleExprElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleExprElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `TupleExprElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> TupleExprElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleExprElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `TupleExprElementListSyntax` with the first element removed.
  public func removingFirst() -> TupleExprElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleExprElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `TupleExprElementListSyntax` with the last element removed.
  public func removingLast() -> TupleExprElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `TupleExprElementListSyntax` to the `BidirectionalCollection` protocol.
extension TupleExprElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `TuplePatternElementListSyntax` represents a collection of one or more
/// `TuplePatternElement` nodes. TuplePatternElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct TuplePatternElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TuplePatternElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .tuplePatternElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .tuplePatternElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.tuplePatternElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `TuplePatternElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> TuplePatternElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return TuplePatternElementListSyntax(newData)
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `TuplePatternElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> TuplePatternElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `TuplePatternElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> TuplePatternElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `TuplePatternElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> TuplePatternElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `TuplePatternElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> TuplePatternElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `TuplePatternElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> TuplePatternElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `TuplePatternElementListSyntax` with the first element removed.
  public func removingFirst() -> TuplePatternElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TuplePatternElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `TuplePatternElementListSyntax` with the last element removed.
  public func removingLast() -> TuplePatternElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `TuplePatternElementListSyntax` to the `BidirectionalCollection` protocol.
extension TuplePatternElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `TupleTypeElementListSyntax` represents a collection of one or more
/// `TupleTypeElement` nodes. TupleTypeElementListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct TupleTypeElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TupleTypeElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .tupleTypeElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .tupleTypeElementList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.tupleTypeElementList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `TupleTypeElementListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> TupleTypeElementListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return TupleTypeElementListSyntax(newData)
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `TupleTypeElementListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> TupleTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `TupleTypeElementListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> TupleTypeElementListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `TupleTypeElementListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> TupleTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `TupleTypeElementListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> TupleTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `TupleTypeElementListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> TupleTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by removing the first element.
  ///
  /// - Returns: A new `TupleTypeElementListSyntax` with the first element removed.
  public func removingFirst() -> TupleTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `TupleTypeElementListSyntax` by removing the last element.
  ///
  /// - Returns: A new `TupleTypeElementListSyntax` with the last element removed.
  public func removingLast() -> TupleTypeElementListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `TupleTypeElementListSyntax` to the `BidirectionalCollection` protocol.
extension TupleTypeElementListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// A collection of syntax nodes that occurred in the source code but could not be used to form a valid syntax tree.
public struct UnexpectedNodesSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = Syntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .unexpectedNodes else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unexpectedNodes)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.unexpectedNodes,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `UnexpectedNodesSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> UnexpectedNodesSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return UnexpectedNodesSyntax(newData)
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `UnexpectedNodesSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> UnexpectedNodesSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `UnexpectedNodesSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> UnexpectedNodesSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `UnexpectedNodesSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> UnexpectedNodesSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `UnexpectedNodesSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> UnexpectedNodesSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `UnexpectedNodesSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> UnexpectedNodesSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by removing the first element.
  ///
  /// - Returns: A new `UnexpectedNodesSyntax` with the first element removed.
  public func removingFirst() -> UnexpectedNodesSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `UnexpectedNodesSyntax` by removing the last element.
  ///
  /// - Returns: A new `UnexpectedNodesSyntax` with the last element removed.
  public func removingLast() -> UnexpectedNodesSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `UnexpectedNodesSyntax` to the `BidirectionalCollection` protocol.
extension UnexpectedNodesSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}

/// `YieldExprListSyntax` represents a collection of one or more
/// `YieldExprListElement` nodes. YieldExprListSyntax behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
public struct YieldExprListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = YieldExprListElementSyntax
  
  public let _syntaxNode: Syntax
  
  private var layoutView: RawSyntaxLayoutView {
    data.raw.layoutView!
  }
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .yieldExprList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a Syntax node from the provided root and data. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .yieldExprList)
    self._syntaxNode = Syntax(data)
  }
  
  public init(_ children: [Element]) {
    let data: SyntaxData = withExtendedLifetime(SyntaxArena()) { arena in
      let raw = RawSyntax.makeLayout(kind: SyntaxKind.yieldExprList,
                                     from: children.map {
          $0.raw
        }, arena: arena)
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// The number of elements, `present` or `missing`, in this collection.
  public var count: Int {
    return layoutView.children.count
  }
  
  /// Creates a new `YieldExprListSyntax` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `YieldExprListSyntax` with the new layout underlying it.
  internal func replacingLayout(_ layout: [RawSyntax?]) -> YieldExprListSyntax {
    let arena = SyntaxArena()
    let newRaw = layoutView.replacingLayout(with: layout, arena: arena)
    let newData = data.replacingSelf(newRaw, arena: arena)
    return YieldExprListSyntax(newData)
  }
  
  /// Creates a new `YieldExprListSyntax` by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new `YieldExprListSyntax` with that element appended to the end.
  public func appending(_ syntax: Element) -> YieldExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `YieldExprListSyntax` by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new `YieldExprListSyntax` with that element prepended to the
  ///            beginning.
  public func prepending(_ syntax: Element) -> YieldExprListSyntax {
    return inserting(syntax, at: 0)
  }
  
  /// Creates a new `YieldExprListSyntax` by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new `YieldExprListSyntax` with that element appended to the end.
  public func inserting(_ syntax: Element, at index: Int) -> YieldExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex ... newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `YieldExprListSyntax` by replacing the syntax element
  /// at the provided index.
  ///
  /// - Parameters:
  ///   - index: The index at which to replace the element in the collection.
  ///   - syntax: The element to replace with.
  ///
  /// - Returns: A new `YieldExprListSyntax` with the new element at the provided index.
  public func replacing(childAt index: Int, with syntax: Element) -> YieldExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    /// Make sure the index is a valid index for replacing
    precondition((newLayout.startIndex ..< newLayout.endIndex).contains(index),
                 "replacing node at invalid index \(index)")
    newLayout[index] = syntax.raw
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `YieldExprListSyntax` by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new `YieldExprListSyntax` with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> YieldExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `YieldExprListSyntax` by removing the first element.
  ///
  /// - Returns: A new `YieldExprListSyntax` with the first element removed.
  public func removingFirst() -> YieldExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }
  
  /// Creates a new `YieldExprListSyntax` by removing the last element.
  ///
  /// - Returns: A new `YieldExprListSyntax` with the last element removed.
  public func removingLast() -> YieldExprListSyntax {
    var newLayout = layoutView.formLayoutArray()
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }
}

/// Conformance for `YieldExprListSyntax` to the `BidirectionalCollection` protocol.
extension YieldExprListSyntax: BidirectionalCollection {
  public typealias Index = SyntaxChildrenIndex
  
  public struct Iterator: IteratorProtocol {
    private let parent: Syntax
    
    private var iterator: RawSyntaxChildren.Iterator
    

    init(parent: Syntax, rawChildren: RawSyntaxChildren) {
      self.parent = parent
      self.iterator = rawChildren.makeIterator()
    }
    

    public mutating func next() -> Element? {
      guard let (raw, info) = self.iterator.next() else {
        return nil
      }
      let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
      let data = SyntaxData(absoluteRaw, parent: parent)
      return Element(data)
    }
  }
  
  public func makeIterator() -> Iterator {
    return Iterator(parent: Syntax(self), rawChildren: rawChildren)
  }
  
  private var rawChildren: RawSyntaxChildren {
    // We know children in a syntax collection cannot be missing. So we can
    // use the low-level and faster RawSyntaxChildren collection instead of
    // NonNilRawSyntaxChildren.
    return RawSyntaxChildren(self.data.absoluteRaw)
  }
  
  public var startIndex: SyntaxChildrenIndex {
    return rawChildren.startIndex
  }
  
  public var endIndex: SyntaxChildrenIndex {
    return rawChildren.endIndex
  }
  
  public func index(after index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(after: index)
  }
  
  public func index(before index: SyntaxChildrenIndex) -> SyntaxChildrenIndex {
    return rawChildren.index(before: index)
  }
  
  public func distance(from start: SyntaxChildrenIndex, to end: SyntaxChildrenIndex)
  -> Int {
    return rawChildren.distance(from: start, to: end)
  }
  
  public subscript(position: SyntaxChildrenIndex) -> Element {
    let (raw, info) = rawChildren[position]
    let absoluteRaw = AbsoluteRawSyntax(raw: raw!, info: info)
    let data = SyntaxData(absoluteRaw, parent: Syntax(self))
    return Element(data)
  }
}
