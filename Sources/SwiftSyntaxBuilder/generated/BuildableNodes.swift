
//// Automatically Generated by generate-swift-syntax-builder
//// Do Not Edit Directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftSyntax
/// A CodeBlockItem is any Syntax node that appears on its own line insidea CodeBlock.
public struct CodeBlockItem: SyntaxBuildable, ExpressibleAsCodeBlockItem {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeItem: UnexpectedNodes?
  var item: SyntaxBuildable
  var unexpectedBetweenItemAndSemicolon: UnexpectedNodes?
  var semicolon: Token?
  var unexpectedBetweenSemicolonAndErrorTokens: UnexpectedNodes?
  var errorTokens: SyntaxBuildable?
  /// Creates a `CodeBlockItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeItem: 
  ///   - item: The underlying node inside the code block.
  ///   - unexpectedBetweenItemAndSemicolon: 
  ///   - semicolon: If present, the trailing semicolon at the end of the item.
  ///   - unexpectedBetweenSemicolonAndErrorTokens: 
  ///   - errorTokens: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeItem: ExpressibleAsUnexpectedNodes? = nil, item: ExpressibleAsSyntaxBuildable, unexpectedBetweenItemAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token? = nil, unexpectedBetweenSemicolonAndErrorTokens: ExpressibleAsUnexpectedNodes? = nil, errorTokens: ExpressibleAsSyntaxBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeItem = unexpectedBeforeItem?.createUnexpectedNodes()
    self.item = item.createSyntaxBuildable()
    self.unexpectedBetweenItemAndSemicolon = unexpectedBetweenItemAndSemicolon?.createUnexpectedNodes()
    self.semicolon = semicolon
    assert(semicolon == nil || semicolon!.text == #";"#)
    self.unexpectedBetweenSemicolonAndErrorTokens = unexpectedBetweenSemicolonAndErrorTokens?.createUnexpectedNodes()
    self.errorTokens = errorTokens?.createSyntaxBuildable()
  }
  /// Builds a `CodeBlockItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CodeBlockItemSyntax`.
  func buildCodeBlockItem(format: Format) -> CodeBlockItemSyntax {
    var result = CodeBlockItemSyntax(unexpectedBeforeItem?.buildUnexpectedNodes(format: format), item: item.buildSyntax(format: format), unexpectedBetweenItemAndSemicolon?.buildUnexpectedNodes(format: format), semicolon: semicolon?.buildToken(format: format), unexpectedBetweenSemicolonAndErrorTokens?.buildUnexpectedNodes(format: format), errorTokens: errorTokens?.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCodeBlockItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCodeBlockItem`.
  public func createCodeBlockItem() -> CodeBlockItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CodeBlockItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct CodeBlock: SyntaxBuildable, ExpressibleAsCodeBlock {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftBrace: UnexpectedNodes?
  var leftBrace: Token
  var unexpectedBetweenLeftBraceAndStatements: UnexpectedNodes?
  var statements: CodeBlockItemList
  var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodes?
  var rightBrace: Token
  /// Creates a `CodeBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndStatements = unexpectedBetweenLeftBraceAndStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
    self.unexpectedBetweenStatementsAndRightBrace = unexpectedBetweenStatementsAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndStatements: unexpectedBetweenLeftBraceAndStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `CodeBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CodeBlockSyntax`.
  func buildCodeBlock(format: Format) -> CodeBlockSyntax {
    var result = CodeBlockSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: leftBrace.buildToken(format: format), unexpectedBetweenLeftBraceAndStatements?.buildUnexpectedNodes(format: format), statements: statements.buildCodeBlockItemList(format: format._indented), unexpectedBetweenStatementsAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: rightBrace.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCodeBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCodeBlock`.
  public func createCodeBlock() -> CodeBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CodeBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct InOutExpr: ExprBuildable, ExpressibleAsInOutExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAmpersand: UnexpectedNodes?
  var ampersand: Token
  var unexpectedBetweenAmpersandAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `InOutExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAmpersand: 
  ///   - ampersand: 
  ///   - unexpectedBetweenAmpersandAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAmpersand: ExpressibleAsUnexpectedNodes? = nil, ampersand: Token = Token.`prefixAmpersand`, unexpectedBetweenAmpersandAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAmpersand = unexpectedBeforeAmpersand?.createUnexpectedNodes()
    self.ampersand = ampersand
    assert(ampersand.text == #"&"#)
    self.unexpectedBetweenAmpersandAndExpression = unexpectedBetweenAmpersandAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `InOutExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InOutExprSyntax`.
  func buildInOutExpr(format: Format) -> InOutExprSyntax {
    var result = InOutExprSyntax(unexpectedBeforeAmpersand?.buildUnexpectedNodes(format: format), ampersand: ampersand.buildToken(format: format), unexpectedBetweenAmpersandAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildInOutExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsInOutExpr`.
  public func createInOutExpr() -> InOutExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `InOutExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundColumnExpr: ExprBuildable, ExpressibleAsPoundColumnExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundColumn: UnexpectedNodes?
  var poundColumn: Token
  /// Creates a `PoundColumnExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundColumn: 
  ///   - poundColumn: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundColumn: ExpressibleAsUnexpectedNodes? = nil, poundColumn: Token = Token.`poundColumn`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundColumn = unexpectedBeforePoundColumn?.createUnexpectedNodes()
    self.poundColumn = poundColumn
    assert(poundColumn.text == #"#column"#)
  }
  /// Builds a `PoundColumnExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundColumnExprSyntax`.
  func buildPoundColumnExpr(format: Format) -> PoundColumnExprSyntax {
    var result = PoundColumnExprSyntax(unexpectedBeforePoundColumn?.buildUnexpectedNodes(format: format), poundColumn: poundColumn.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundColumnExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundColumnExpr`.
  public func createPoundColumnExpr() -> PoundColumnExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundColumnExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TryExpr: ExprBuildable, ExpressibleAsTryExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeTryKeyword: UnexpectedNodes?
  var tryKeyword: Token
  var unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodes?
  var questionOrExclamationMark: Token?
  var unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `TryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTryKeyword: 
  ///   - tryKeyword: 
  ///   - unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  ///   - unexpectedBetweenQuestionOrExclamationMarkAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token = Token.`try`, unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil, unexpectedBetweenQuestionOrExclamationMarkAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeTryKeyword = unexpectedBeforeTryKeyword?.createUnexpectedNodes()
    self.tryKeyword = tryKeyword
    assert(tryKeyword.text == #"try"#)
    self.unexpectedBetweenTryKeywordAndQuestionOrExclamationMark = unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.createUnexpectedNodes()
    self.questionOrExclamationMark = questionOrExclamationMark
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
    self.unexpectedBetweenQuestionOrExclamationMarkAndExpression = unexpectedBetweenQuestionOrExclamationMarkAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `TryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TryExprSyntax`.
  func buildTryExpr(format: Format) -> TryExprSyntax {
    var result = TryExprSyntax(unexpectedBeforeTryKeyword?.buildUnexpectedNodes(format: format), tryKeyword: tryKeyword.buildToken(format: format), unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format), questionOrExclamationMark: questionOrExclamationMark?.buildToken(format: format), unexpectedBetweenQuestionOrExclamationMarkAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTryExpr`.
  public func createTryExpr() -> TryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AwaitExpr: ExprBuildable, ExpressibleAsAwaitExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAwaitKeyword: UnexpectedNodes?
  var awaitKeyword: Token
  var unexpectedBetweenAwaitKeywordAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `AwaitExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAwaitKeyword: 
  ///   - awaitKeyword: 
  ///   - unexpectedBetweenAwaitKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: Token, unexpectedBetweenAwaitKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAwaitKeyword = unexpectedBeforeAwaitKeyword?.createUnexpectedNodes()
    self.awaitKeyword = awaitKeyword
    assert(awaitKeyword.text == #"await"#)
    self.unexpectedBetweenAwaitKeywordAndExpression = unexpectedBetweenAwaitKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: String, unexpectedBetweenAwaitKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAwaitKeyword: unexpectedBeforeAwaitKeyword, awaitKeyword: Token.`contextualKeyword`(awaitKeyword), unexpectedBetweenAwaitKeywordAndExpression: unexpectedBetweenAwaitKeywordAndExpression, expression: expression)
  }
  /// Builds a `AwaitExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AwaitExprSyntax`.
  func buildAwaitExpr(format: Format) -> AwaitExprSyntax {
    var result = AwaitExprSyntax(unexpectedBeforeAwaitKeyword?.buildUnexpectedNodes(format: format), awaitKeyword: awaitKeyword.buildToken(format: format), unexpectedBetweenAwaitKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildAwaitExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAwaitExpr`.
  public func createAwaitExpr() -> AwaitExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AwaitExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct MoveExpr: ExprBuildable, ExpressibleAsMoveExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeMoveKeyword: UnexpectedNodes?
  var moveKeyword: Token
  var unexpectedBetweenMoveKeywordAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `MoveExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMoveKeyword: 
  ///   - moveKeyword: 
  ///   - unexpectedBetweenMoveKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeMoveKeyword: ExpressibleAsUnexpectedNodes? = nil, moveKeyword: Token, unexpectedBetweenMoveKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeMoveKeyword = unexpectedBeforeMoveKeyword?.createUnexpectedNodes()
    self.moveKeyword = moveKeyword
    assert(moveKeyword.text == #"_move"#)
    self.unexpectedBetweenMoveKeywordAndExpression = unexpectedBetweenMoveKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMoveKeyword: ExpressibleAsUnexpectedNodes? = nil, moveKeyword: String, unexpectedBetweenMoveKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMoveKeyword: unexpectedBeforeMoveKeyword, moveKeyword: Token.`contextualKeyword`(moveKeyword), unexpectedBetweenMoveKeywordAndExpression: unexpectedBetweenMoveKeywordAndExpression, expression: expression)
  }
  /// Builds a `MoveExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MoveExprSyntax`.
  func buildMoveExpr(format: Format) -> MoveExprSyntax {
    var result = MoveExprSyntax(unexpectedBeforeMoveKeyword?.buildUnexpectedNodes(format: format), moveKeyword: moveKeyword.buildToken(format: format), unexpectedBetweenMoveKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildMoveExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsMoveExpr`.
  public func createMoveExpr() -> MoveExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `MoveExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeclNameArgument: SyntaxBuildable, ExpressibleAsDeclNameArgument {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndColon: UnexpectedNodes?
  var colon: Token
  /// Creates a `DeclNameArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndColon = unexpectedBetweenNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
  }
  /// Builds a `DeclNameArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameArgumentSyntax`.
  func buildDeclNameArgument(format: Format) -> DeclNameArgumentSyntax {
    var result = DeclNameArgumentSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclNameArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclNameArgument`.
  public func createDeclNameArgument() -> DeclNameArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclNameArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeclNameArguments: SyntaxBuildable, ExpressibleAsDeclNameArguments {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
  var arguments: DeclNameArgumentList
  var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `DeclNameArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArgumentList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArguments = unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createDeclNameArgumentList()
    self.unexpectedBetweenArgumentsAndRightParen = unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `DeclNameArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameArgumentsSyntax`.
  func buildDeclNameArguments(format: Format) -> DeclNameArgumentsSyntax {
    var result = DeclNameArgumentsSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format), arguments: arguments.buildDeclNameArgumentList(format: format), unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclNameArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclNameArguments`.
  public func createDeclNameArguments() -> DeclNameArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclNameArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IdentifierExpr: ExprBuildable, ExpressibleAsIdentifierExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodes?
  var declNameArguments: DeclNameArguments?
  /// Creates a `IdentifierExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndDeclNameArguments: 
  ///   - declNameArguments: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndDeclNameArguments = unexpectedBetweenIdentifierAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `IdentifierExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IdentifierExprSyntax`.
  func buildIdentifierExpr(format: Format) -> IdentifierExprSyntax {
    var result = IdentifierExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildIdentifierExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIdentifierExpr`.
  public func createIdentifierExpr() -> IdentifierExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IdentifierExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SuperRefExpr: ExprBuildable, ExpressibleAsSuperRefExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeSuperKeyword: UnexpectedNodes?
  var superKeyword: Token
  /// Creates a `SuperRefExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSuperKeyword: 
  ///   - superKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSuperKeyword: ExpressibleAsUnexpectedNodes? = nil, superKeyword: Token = Token.`super`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeSuperKeyword = unexpectedBeforeSuperKeyword?.createUnexpectedNodes()
    self.superKeyword = superKeyword
    assert(superKeyword.text == #"super"#)
  }
  /// Builds a `SuperRefExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SuperRefExprSyntax`.
  func buildSuperRefExpr(format: Format) -> SuperRefExprSyntax {
    var result = SuperRefExprSyntax(unexpectedBeforeSuperKeyword?.buildUnexpectedNodes(format: format), superKeyword: superKeyword.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSuperRefExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSuperRefExpr`.
  public func createSuperRefExpr() -> SuperRefExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SuperRefExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct NilLiteralExpr: ExprBuildable, ExpressibleAsNilLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeNilKeyword: UnexpectedNodes?
  var nilKeyword: Token
  /// Creates a `NilLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeNilKeyword: 
  ///   - nilKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeNilKeyword: ExpressibleAsUnexpectedNodes? = nil, nilKeyword: Token = Token.`nil`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeNilKeyword = unexpectedBeforeNilKeyword?.createUnexpectedNodes()
    self.nilKeyword = nilKeyword
    assert(nilKeyword.text == #"nil"#)
  }
  /// Builds a `NilLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `NilLiteralExprSyntax`.
  func buildNilLiteralExpr(format: Format) -> NilLiteralExprSyntax {
    var result = NilLiteralExprSyntax(unexpectedBeforeNilKeyword?.buildUnexpectedNodes(format: format), nilKeyword: nilKeyword.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildNilLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsNilLiteralExpr`.
  public func createNilLiteralExpr() -> NilLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `NilLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DiscardAssignmentExpr: ExprBuildable, ExpressibleAsDiscardAssignmentExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWildcard: UnexpectedNodes?
  var wildcard: Token
  /// Creates a `DiscardAssignmentExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWildcard: 
  ///   - wildcard: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWildcard: ExpressibleAsUnexpectedNodes? = nil, wildcard: Token = Token.`wildcard`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWildcard = unexpectedBeforeWildcard?.createUnexpectedNodes()
    self.wildcard = wildcard
    assert(wildcard.text == #"_"#)
  }
  /// Builds a `DiscardAssignmentExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DiscardAssignmentExprSyntax`.
  func buildDiscardAssignmentExpr(format: Format) -> DiscardAssignmentExprSyntax {
    var result = DiscardAssignmentExprSyntax(unexpectedBeforeWildcard?.buildUnexpectedNodes(format: format), wildcard: wildcard.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildDiscardAssignmentExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsDiscardAssignmentExpr`.
  public func createDiscardAssignmentExpr() -> DiscardAssignmentExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `DiscardAssignmentExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AssignmentExpr: ExprBuildable, ExpressibleAsAssignmentExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAssignToken: UnexpectedNodes?
  var assignToken: Token
  /// Creates a `AssignmentExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssignToken: 
  ///   - assignToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token = Token.`equal`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAssignToken = unexpectedBeforeAssignToken?.createUnexpectedNodes()
    self.assignToken = assignToken
    assert(assignToken.text == #"="#)
  }
  /// Builds a `AssignmentExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AssignmentExprSyntax`.
  func buildAssignmentExpr(format: Format) -> AssignmentExprSyntax {
    var result = AssignmentExprSyntax(unexpectedBeforeAssignToken?.buildUnexpectedNodes(format: format), assignToken: assignToken.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildAssignmentExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAssignmentExpr`.
  public func createAssignmentExpr() -> AssignmentExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AssignmentExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SequenceExpr: ExprBuildable, ExpressibleAsSequenceExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeElements: UnexpectedNodes?
  var elements: ExprList
  /// Creates a `SequenceExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsExprList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeElements = unexpectedBeforeElements?.createUnexpectedNodes()
    self.elements = elements.createExprList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, @ExprListBuilder elementsBuilder: () -> ExpressibleAsExprList =  {
    ExprList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeElements: unexpectedBeforeElements, elements: elementsBuilder())
  }
  /// Builds a `SequenceExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SequenceExprSyntax`.
  func buildSequenceExpr(format: Format) -> SequenceExprSyntax {
    var result = SequenceExprSyntax(unexpectedBeforeElements?.buildUnexpectedNodes(format: format), elements: elements.buildExprList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSequenceExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSequenceExpr`.
  public func createSequenceExpr() -> SequenceExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SequenceExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundLineExpr: ExprBuildable, ExpressibleAsPoundLineExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundLine: UnexpectedNodes?
  var poundLine: Token
  /// Creates a `PoundLineExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundLine: 
  ///   - poundLine: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundLine: ExpressibleAsUnexpectedNodes? = nil, poundLine: Token = Token.`poundLine`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundLine = unexpectedBeforePoundLine?.createUnexpectedNodes()
    self.poundLine = poundLine
    assert(poundLine.text == #"#line"#)
  }
  /// Builds a `PoundLineExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundLineExprSyntax`.
  func buildPoundLineExpr(format: Format) -> PoundLineExprSyntax {
    var result = PoundLineExprSyntax(unexpectedBeforePoundLine?.buildUnexpectedNodes(format: format), poundLine: poundLine.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundLineExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundLineExpr`.
  public func createPoundLineExpr() -> PoundLineExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundLineExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundFileExpr: ExprBuildable, ExpressibleAsPoundFileExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundFile: UnexpectedNodes?
  var poundFile: Token
  /// Creates a `PoundFileExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFile: 
  ///   - poundFile: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFile: ExpressibleAsUnexpectedNodes? = nil, poundFile: Token = Token.`poundFile`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundFile = unexpectedBeforePoundFile?.createUnexpectedNodes()
    self.poundFile = poundFile
    assert(poundFile.text == #"#file"#)
  }
  /// Builds a `PoundFileExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFileExprSyntax`.
  func buildPoundFileExpr(format: Format) -> PoundFileExprSyntax {
    var result = PoundFileExprSyntax(unexpectedBeforePoundFile?.buildUnexpectedNodes(format: format), poundFile: poundFile.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFileExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFileExpr`.
  public func createPoundFileExpr() -> PoundFileExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFileExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundFileIDExpr: ExprBuildable, ExpressibleAsPoundFileIDExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundFileID: UnexpectedNodes?
  var poundFileID: Token
  /// Creates a `PoundFileIDExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFileID: 
  ///   - poundFileID: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFileID: ExpressibleAsUnexpectedNodes? = nil, poundFileID: Token = Token.`poundFileID`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundFileID = unexpectedBeforePoundFileID?.createUnexpectedNodes()
    self.poundFileID = poundFileID
    assert(poundFileID.text == #"#fileID"#)
  }
  /// Builds a `PoundFileIDExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFileIDExprSyntax`.
  func buildPoundFileIDExpr(format: Format) -> PoundFileIDExprSyntax {
    var result = PoundFileIDExprSyntax(unexpectedBeforePoundFileID?.buildUnexpectedNodes(format: format), poundFileID: poundFileID.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFileIDExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFileIDExpr`.
  public func createPoundFileIDExpr() -> PoundFileIDExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFileIDExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundFilePathExpr: ExprBuildable, ExpressibleAsPoundFilePathExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundFilePath: UnexpectedNodes?
  var poundFilePath: Token
  /// Creates a `PoundFilePathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFilePath: 
  ///   - poundFilePath: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFilePath: ExpressibleAsUnexpectedNodes? = nil, poundFilePath: Token = Token.`poundFilePath`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundFilePath = unexpectedBeforePoundFilePath?.createUnexpectedNodes()
    self.poundFilePath = poundFilePath
    assert(poundFilePath.text == #"#filePath"#)
  }
  /// Builds a `PoundFilePathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFilePathExprSyntax`.
  func buildPoundFilePathExpr(format: Format) -> PoundFilePathExprSyntax {
    var result = PoundFilePathExprSyntax(unexpectedBeforePoundFilePath?.buildUnexpectedNodes(format: format), poundFilePath: poundFilePath.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFilePathExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFilePathExpr`.
  public func createPoundFilePathExpr() -> PoundFilePathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFilePathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundFunctionExpr: ExprBuildable, ExpressibleAsPoundFunctionExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundFunction: UnexpectedNodes?
  var poundFunction: Token
  /// Creates a `PoundFunctionExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFunction: 
  ///   - poundFunction: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFunction: ExpressibleAsUnexpectedNodes? = nil, poundFunction: Token = Token.`poundFunction`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundFunction = unexpectedBeforePoundFunction?.createUnexpectedNodes()
    self.poundFunction = poundFunction
    assert(poundFunction.text == #"#function"#)
  }
  /// Builds a `PoundFunctionExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFunctionExprSyntax`.
  func buildPoundFunctionExpr(format: Format) -> PoundFunctionExprSyntax {
    var result = PoundFunctionExprSyntax(unexpectedBeforePoundFunction?.buildUnexpectedNodes(format: format), poundFunction: poundFunction.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFunctionExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFunctionExpr`.
  public func createPoundFunctionExpr() -> PoundFunctionExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFunctionExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundDsohandleExpr: ExprBuildable, ExpressibleAsPoundDsohandleExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundDsohandle: UnexpectedNodes?
  var poundDsohandle: Token
  /// Creates a `PoundDsohandleExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundDsohandle: 
  ///   - poundDsohandle: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundDsohandle: ExpressibleAsUnexpectedNodes? = nil, poundDsohandle: Token = Token.`poundDsohandle`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundDsohandle = unexpectedBeforePoundDsohandle?.createUnexpectedNodes()
    self.poundDsohandle = poundDsohandle
    assert(poundDsohandle.text == #"#dsohandle"#)
  }
  /// Builds a `PoundDsohandleExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundDsohandleExprSyntax`.
  func buildPoundDsohandleExpr(format: Format) -> PoundDsohandleExprSyntax {
    var result = PoundDsohandleExprSyntax(unexpectedBeforePoundDsohandle?.buildUnexpectedNodes(format: format), poundDsohandle: poundDsohandle.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundDsohandleExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundDsohandleExpr`.
  public func createPoundDsohandleExpr() -> PoundDsohandleExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundDsohandleExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SymbolicReferenceExpr: ExprBuildable, ExpressibleAsSymbolicReferenceExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndGenericArgumentClause: UnexpectedNodes?
  var genericArgumentClause: GenericArgumentClause?
  /// Creates a `SymbolicReferenceExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericArgumentClause = unexpectedBetweenIdentifierAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause?.createGenericArgumentClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericArgumentClause: unexpectedBetweenIdentifierAndGenericArgumentClause, genericArgumentClause: genericArgumentClause)
  }
  /// Builds a `SymbolicReferenceExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SymbolicReferenceExprSyntax`.
  func buildSymbolicReferenceExpr(format: Format) -> SymbolicReferenceExprSyntax {
    var result = SymbolicReferenceExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: genericArgumentClause?.buildGenericArgumentClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSymbolicReferenceExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSymbolicReferenceExpr`.
  public func createSymbolicReferenceExpr() -> SymbolicReferenceExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SymbolicReferenceExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PrefixOperatorExpr: ExprBuildable, ExpressibleAsPrefixOperatorExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeOperatorToken: UnexpectedNodes?
  var operatorToken: Token?
  var unexpectedBetweenOperatorTokenAndPostfixExpression: UnexpectedNodes?
  var postfixExpression: ExprBuildable
  /// Creates a `PrefixOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOperatorToken: 
  ///   - operatorToken: 
  ///   - unexpectedBetweenOperatorTokenAndPostfixExpression: 
  ///   - postfixExpression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token? = nil, unexpectedBetweenOperatorTokenAndPostfixExpression: ExpressibleAsUnexpectedNodes? = nil, postfixExpression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeOperatorToken = unexpectedBeforeOperatorToken?.createUnexpectedNodes()
    self.operatorToken = operatorToken
    self.unexpectedBetweenOperatorTokenAndPostfixExpression = unexpectedBetweenOperatorTokenAndPostfixExpression?.createUnexpectedNodes()
    self.postfixExpression = postfixExpression.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: String?, unexpectedBetweenOperatorTokenAndPostfixExpression: ExpressibleAsUnexpectedNodes? = nil, postfixExpression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOperatorToken: unexpectedBeforeOperatorToken, operatorToken: operatorToken.map {
      Token.`prefixOperator`($0)
    }, unexpectedBetweenOperatorTokenAndPostfixExpression: unexpectedBetweenOperatorTokenAndPostfixExpression, postfixExpression: postfixExpression)
  }
  /// Builds a `PrefixOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrefixOperatorExprSyntax`.
  func buildPrefixOperatorExpr(format: Format) -> PrefixOperatorExprSyntax {
    var result = PrefixOperatorExprSyntax(unexpectedBeforeOperatorToken?.buildUnexpectedNodes(format: format), operatorToken: operatorToken?.buildToken(format: format), unexpectedBetweenOperatorTokenAndPostfixExpression?.buildUnexpectedNodes(format: format), postfixExpression: postfixExpression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPrefixOperatorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPrefixOperatorExpr`.
  public func createPrefixOperatorExpr() -> PrefixOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PrefixOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct BinaryOperatorExpr: ExprBuildable, ExpressibleAsBinaryOperatorExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeOperatorToken: UnexpectedNodes?
  var operatorToken: Token
  /// Creates a `BinaryOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOperatorToken: 
  ///   - operatorToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeOperatorToken = unexpectedBeforeOperatorToken?.createUnexpectedNodes()
    self.operatorToken = operatorToken
  }
  /// Builds a `BinaryOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BinaryOperatorExprSyntax`.
  func buildBinaryOperatorExpr(format: Format) -> BinaryOperatorExprSyntax {
    var result = BinaryOperatorExprSyntax(unexpectedBeforeOperatorToken?.buildUnexpectedNodes(format: format), operatorToken: operatorToken.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildBinaryOperatorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsBinaryOperatorExpr`.
  public func createBinaryOperatorExpr() -> BinaryOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `BinaryOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ArrowExpr: ExprBuildable, ExpressibleAsArrowExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAsyncKeyword: UnexpectedNodes?
  var asyncKeyword: Token?
  var unexpectedBetweenAsyncKeywordAndThrowsToken: UnexpectedNodes?
  var throwsToken: Token?
  var unexpectedBetweenThrowsTokenAndArrowToken: UnexpectedNodes?
  var arrowToken: Token
  /// Creates a `ArrowExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsToken: 
  ///   - throwsToken: 
  ///   - unexpectedBetweenThrowsTokenAndArrowToken: 
  ///   - arrowToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsToken: ExpressibleAsUnexpectedNodes? = nil, throwsToken: Token? = nil, unexpectedBetweenThrowsTokenAndArrowToken: ExpressibleAsUnexpectedNodes? = nil, arrowToken: Token = Token.`arrow`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAsyncKeyword = unexpectedBeforeAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsToken = unexpectedBetweenAsyncKeywordAndThrowsToken?.createUnexpectedNodes()
    self.throwsToken = throwsToken
    assert(throwsToken == nil || throwsToken!.text == #"throws"#)
    self.unexpectedBetweenThrowsTokenAndArrowToken = unexpectedBetweenThrowsTokenAndArrowToken?.createUnexpectedNodes()
    self.arrowToken = arrowToken
    assert(arrowToken.text == #"->"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsToken: ExpressibleAsUnexpectedNodes? = nil, throwsToken: Token? = nil, unexpectedBetweenThrowsTokenAndArrowToken: ExpressibleAsUnexpectedNodes? = nil, arrowToken: Token = Token.`arrow`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAsyncKeyword: unexpectedBeforeAsyncKeyword, asyncKeyword: asyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncKeywordAndThrowsToken: unexpectedBetweenAsyncKeywordAndThrowsToken, throwsToken: throwsToken, unexpectedBetweenThrowsTokenAndArrowToken: unexpectedBetweenThrowsTokenAndArrowToken, arrowToken: arrowToken)
  }
  /// Builds a `ArrowExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrowExprSyntax`.
  func buildArrowExpr(format: Format) -> ArrowExprSyntax {
    var result = ArrowExprSyntax(unexpectedBeforeAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: asyncKeyword?.buildToken(format: format), unexpectedBetweenAsyncKeywordAndThrowsToken?.buildUnexpectedNodes(format: format), throwsToken: throwsToken?.buildToken(format: format), unexpectedBetweenThrowsTokenAndArrowToken?.buildUnexpectedNodes(format: format), arrowToken: arrowToken.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildArrowExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrowExpr`.
  public func createArrowExpr() -> ArrowExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ArrowExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct InfixOperatorExpr: ExprBuildable, ExpressibleAsInfixOperatorExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftOperand: UnexpectedNodes?
  var leftOperand: ExprBuildable
  var unexpectedBetweenLeftOperandAndOperatorOperand: UnexpectedNodes?
  var operatorOperand: ExprBuildable
  var unexpectedBetweenOperatorOperandAndRightOperand: UnexpectedNodes?
  var rightOperand: ExprBuildable
  /// Creates a `InfixOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftOperand: 
  ///   - leftOperand: 
  ///   - unexpectedBetweenLeftOperandAndOperatorOperand: 
  ///   - operatorOperand: 
  ///   - unexpectedBetweenOperatorOperandAndRightOperand: 
  ///   - rightOperand: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftOperand: ExpressibleAsUnexpectedNodes? = nil, leftOperand: ExpressibleAsExprBuildable, unexpectedBetweenLeftOperandAndOperatorOperand: ExpressibleAsUnexpectedNodes? = nil, operatorOperand: ExpressibleAsExprBuildable, unexpectedBetweenOperatorOperandAndRightOperand: ExpressibleAsUnexpectedNodes? = nil, rightOperand: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftOperand = unexpectedBeforeLeftOperand?.createUnexpectedNodes()
    self.leftOperand = leftOperand.createExprBuildable()
    self.unexpectedBetweenLeftOperandAndOperatorOperand = unexpectedBetweenLeftOperandAndOperatorOperand?.createUnexpectedNodes()
    self.operatorOperand = operatorOperand.createExprBuildable()
    self.unexpectedBetweenOperatorOperandAndRightOperand = unexpectedBetweenOperatorOperandAndRightOperand?.createUnexpectedNodes()
    self.rightOperand = rightOperand.createExprBuildable()
  }
  /// Builds a `InfixOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InfixOperatorExprSyntax`.
  func buildInfixOperatorExpr(format: Format) -> InfixOperatorExprSyntax {
    var result = InfixOperatorExprSyntax(unexpectedBeforeLeftOperand?.buildUnexpectedNodes(format: format), leftOperand: leftOperand.buildExpr(format: format), unexpectedBetweenLeftOperandAndOperatorOperand?.buildUnexpectedNodes(format: format), operatorOperand: operatorOperand.buildExpr(format: format), unexpectedBetweenOperatorOperandAndRightOperand?.buildUnexpectedNodes(format: format), rightOperand: rightOperand.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildInfixOperatorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsInfixOperatorExpr`.
  public func createInfixOperatorExpr() -> InfixOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `InfixOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct FloatLiteralExpr: ExprBuildable, ExpressibleAsFloatLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeFloatingDigits: UnexpectedNodes?
  var floatingDigits: Token
  /// Creates a `FloatLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFloatingDigits: 
  ///   - floatingDigits: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeFloatingDigits: ExpressibleAsUnexpectedNodes? = nil, floatingDigits: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeFloatingDigits = unexpectedBeforeFloatingDigits?.createUnexpectedNodes()
    self.floatingDigits = floatingDigits
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFloatingDigits: ExpressibleAsUnexpectedNodes? = nil, floatingDigits: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeFloatingDigits: unexpectedBeforeFloatingDigits, floatingDigits: Token.`floatingLiteral`(floatingDigits))
  }
  /// Builds a `FloatLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FloatLiteralExprSyntax`.
  func buildFloatLiteralExpr(format: Format) -> FloatLiteralExprSyntax {
    var result = FloatLiteralExprSyntax(unexpectedBeforeFloatingDigits?.buildUnexpectedNodes(format: format), floatingDigits: floatingDigits.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildFloatLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsFloatLiteralExpr`.
  public func createFloatLiteralExpr() -> FloatLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `FloatLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TupleExpr: ExprBuildable, ExpressibleAsTupleExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndElementList: UnexpectedNodes?
  var elementList: TupleExprElementList
  var unexpectedBetweenElementListAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `TupleExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElementList: 
  ///   - elementList: 
  ///   - unexpectedBetweenElementListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, elementList: ExpressibleAsTupleExprElementList, unexpectedBetweenElementListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElementList = unexpectedBetweenLeftParenAndElementList?.createUnexpectedNodes()
    self.elementList = elementList.createTupleExprElementList()
    self.unexpectedBetweenElementListAndRightParen = unexpectedBetweenElementListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TupleExprElementListBuilder elementListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElementList: unexpectedBetweenLeftParenAndElementList, elementList: elementListBuilder(), unexpectedBetweenElementListAndRightParen: unexpectedBetweenElementListAndRightParen, rightParen: rightParen)
  }
  /// Builds a `TupleExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleExprSyntax`.
  func buildTupleExpr(format: Format) -> TupleExprSyntax {
    var result = TupleExprSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndElementList?.buildUnexpectedNodes(format: format), elementList: elementList.buildTupleExprElementList(format: format), unexpectedBetweenElementListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTupleExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTupleExpr`.
  public func createTupleExpr() -> TupleExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TupleExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ArrayExpr: ExprBuildable, ExpressibleAsArrayExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftSquare: UnexpectedNodes?
  var leftSquare: Token
  var unexpectedBetweenLeftSquareAndElements: UnexpectedNodes?
  var elements: ArrayElementList
  var unexpectedBetweenElementsAndRightSquare: UnexpectedNodes?
  var rightSquare: Token
  /// Creates a `ArrayExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsArrayElementList, unexpectedBetweenElementsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftSquare = unexpectedBeforeLeftSquare?.createUnexpectedNodes()
    self.leftSquare = leftSquare
    assert(leftSquare.text == #"["#)
    self.unexpectedBetweenLeftSquareAndElements = unexpectedBetweenLeftSquareAndElements?.createUnexpectedNodes()
    self.elements = elements.createArrayElementList()
    self.unexpectedBetweenElementsAndRightSquare = unexpectedBetweenElementsAndRightSquare?.createUnexpectedNodes()
    self.rightSquare = rightSquare
    assert(rightSquare.text == #"]"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndElements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`, @ArrayElementListBuilder elementsBuilder: () -> ExpressibleAsArrayElementList =  {
    ArrayElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare, leftSquare: leftSquare, unexpectedBetweenLeftSquareAndElements: unexpectedBetweenLeftSquareAndElements, elements: elementsBuilder(), unexpectedBetweenElementsAndRightSquare: unexpectedBetweenElementsAndRightSquare, rightSquare: rightSquare)
  }
  /// Builds a `ArrayExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayExprSyntax`.
  func buildArrayExpr(format: Format) -> ArrayExprSyntax {
    var result = ArrayExprSyntax(unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format), leftSquare: leftSquare.buildToken(format: format), unexpectedBetweenLeftSquareAndElements?.buildUnexpectedNodes(format: format), elements: elements.buildArrayElementList(format: format), unexpectedBetweenElementsAndRightSquare?.buildUnexpectedNodes(format: format), rightSquare: rightSquare.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildArrayExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrayExpr`.
  public func createArrayExpr() -> ArrayExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ArrayExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DictionaryExpr: ExprBuildable, ExpressibleAsDictionaryExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftSquare: UnexpectedNodes?
  var leftSquare: Token
  var unexpectedBetweenLeftSquareAndContent: UnexpectedNodes?
  var content: SyntaxBuildable
  var unexpectedBetweenContentAndRightSquare: UnexpectedNodes?
  var rightSquare: Token
  /// Creates a `DictionaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndContent: 
  ///   - content: 
  ///   - unexpectedBetweenContentAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndContent: ExpressibleAsUnexpectedNodes? = nil, content: ExpressibleAsSyntaxBuildable, unexpectedBetweenContentAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftSquare = unexpectedBeforeLeftSquare?.createUnexpectedNodes()
    self.leftSquare = leftSquare
    assert(leftSquare.text == #"["#)
    self.unexpectedBetweenLeftSquareAndContent = unexpectedBetweenLeftSquareAndContent?.createUnexpectedNodes()
    self.content = content.createSyntaxBuildable()
    self.unexpectedBetweenContentAndRightSquare = unexpectedBetweenContentAndRightSquare?.createUnexpectedNodes()
    self.rightSquare = rightSquare
    assert(rightSquare.text == #"]"#)
  }
  /// Builds a `DictionaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryExprSyntax`.
  func buildDictionaryExpr(format: Format) -> DictionaryExprSyntax {
    var result = DictionaryExprSyntax(unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format), leftSquare: leftSquare.buildToken(format: format), unexpectedBetweenLeftSquareAndContent?.buildUnexpectedNodes(format: format), content: content.buildSyntax(format: format), unexpectedBetweenContentAndRightSquare?.buildUnexpectedNodes(format: format), rightSquare: rightSquare.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildDictionaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryExpr`.
  public func createDictionaryExpr() -> DictionaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `DictionaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TupleExprElement: SyntaxBuildable, ExpressibleAsTupleExprElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabel: UnexpectedNodes?
  var label: Token?
  var unexpectedBetweenLabelAndColon: UnexpectedNodes?
  var colon: Token?
  var unexpectedBetweenColonAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `TupleExprElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndExpression = unexpectedBetweenColonAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndTrailingComma = unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `TupleExprElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleExprElementSyntax`.
  func buildTupleExprElement(format: Format) -> TupleExprElementSyntax {
    var result = TupleExprElementSyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: label?.buildToken(format: format), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon?.buildToken(format: format), unexpectedBetweenColonAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTupleExprElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTupleExprElement`.
  public func createTupleExprElement() -> TupleExprElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TupleExprElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ArrayElement: SyntaxBuildable, ExpressibleAsArrayElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `ArrayElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndTrailingComma = unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `ArrayElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayElementSyntax`.
  func buildArrayElement(format: Format) -> ArrayElementSyntax {
    var result = ArrayElementSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildArrayElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsArrayElement`.
  public func createArrayElement() -> ArrayElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ArrayElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DictionaryElement: SyntaxBuildable, ExpressibleAsDictionaryElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeKeyExpression: UnexpectedNodes?
  var keyExpression: ExprBuildable
  var unexpectedBetweenKeyExpressionAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndValueExpression: UnexpectedNodes?
  var valueExpression: ExprBuildable
  var unexpectedBetweenValueExpressionAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `DictionaryElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeKeyExpression: 
  ///   - keyExpression: 
  ///   - unexpectedBetweenKeyExpressionAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValueExpression: 
  ///   - valueExpression: 
  ///   - unexpectedBetweenValueExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeKeyExpression: ExpressibleAsUnexpectedNodes? = nil, keyExpression: ExpressibleAsExprBuildable, unexpectedBetweenKeyExpressionAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValueExpression: ExpressibleAsUnexpectedNodes? = nil, valueExpression: ExpressibleAsExprBuildable, unexpectedBetweenValueExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeKeyExpression = unexpectedBeforeKeyExpression?.createUnexpectedNodes()
    self.keyExpression = keyExpression.createExprBuildable()
    self.unexpectedBetweenKeyExpressionAndColon = unexpectedBetweenKeyExpressionAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValueExpression = unexpectedBetweenColonAndValueExpression?.createUnexpectedNodes()
    self.valueExpression = valueExpression.createExprBuildable()
    self.unexpectedBetweenValueExpressionAndTrailingComma = unexpectedBetweenValueExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `DictionaryElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryElementSyntax`.
  func buildDictionaryElement(format: Format) -> DictionaryElementSyntax {
    var result = DictionaryElementSyntax(unexpectedBeforeKeyExpression?.buildUnexpectedNodes(format: format), keyExpression: keyExpression.buildExpr(format: format), unexpectedBetweenKeyExpressionAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndValueExpression?.buildUnexpectedNodes(format: format), valueExpression: valueExpression.buildExpr(format: format), unexpectedBetweenValueExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDictionaryElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryElement`.
  public func createDictionaryElement() -> DictionaryElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DictionaryElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IntegerLiteralExpr: ExprBuildable, ExpressibleAsIntegerLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDigits: UnexpectedNodes?
  var digits: Token
  /// Creates a `IntegerLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDigits: 
  ///   - digits: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDigits: ExpressibleAsUnexpectedNodes? = nil, digits: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDigits = unexpectedBeforeDigits?.createUnexpectedNodes()
    self.digits = digits
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDigits: ExpressibleAsUnexpectedNodes? = nil, digits: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDigits: unexpectedBeforeDigits, digits: Token.`integerLiteral`(digits))
  }
  /// Builds a `IntegerLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IntegerLiteralExprSyntax`.
  func buildIntegerLiteralExpr(format: Format) -> IntegerLiteralExprSyntax {
    var result = IntegerLiteralExprSyntax(unexpectedBeforeDigits?.buildUnexpectedNodes(format: format), digits: digits.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildIntegerLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIntegerLiteralExpr`.
  public func createIntegerLiteralExpr() -> IntegerLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IntegerLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct BooleanLiteralExpr: ExprBuildable, ExpressibleAsBooleanLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBooleanLiteral: UnexpectedNodes?
  var booleanLiteral: Token
  /// Creates a `BooleanLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBooleanLiteral: 
  ///   - booleanLiteral: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBooleanLiteral: ExpressibleAsUnexpectedNodes? = nil, booleanLiteral: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBooleanLiteral = unexpectedBeforeBooleanLiteral?.createUnexpectedNodes()
    self.booleanLiteral = booleanLiteral
    assert(booleanLiteral.text == #"true"# || booleanLiteral.text == #"false"#)
  }
  /// Builds a `BooleanLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BooleanLiteralExprSyntax`.
  func buildBooleanLiteralExpr(format: Format) -> BooleanLiteralExprSyntax {
    var result = BooleanLiteralExprSyntax(unexpectedBeforeBooleanLiteral?.buildUnexpectedNodes(format: format), booleanLiteral: booleanLiteral.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildBooleanLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsBooleanLiteralExpr`.
  public func createBooleanLiteralExpr() -> BooleanLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `BooleanLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct UnresolvedTernaryExpr: ExprBuildable, ExpressibleAsUnresolvedTernaryExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeQuestionMark: UnexpectedNodes?
  var questionMark: Token
  var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodes?
  var firstChoice: ExprBuildable
  var unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodes?
  var colonMark: Token
  /// Creates a `UnresolvedTernaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeQuestionMark: 
  ///   - questionMark: 
  ///   - unexpectedBetweenQuestionMarkAndFirstChoice: 
  ///   - firstChoice: 
  ///   - unexpectedBetweenFirstChoiceAndColonMark: 
  ///   - colonMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`infixQuestionMark`, unexpectedBetweenQuestionMarkAndFirstChoice: ExpressibleAsUnexpectedNodes? = nil, firstChoice: ExpressibleAsExprBuildable, unexpectedBetweenFirstChoiceAndColonMark: ExpressibleAsUnexpectedNodes? = nil, colonMark: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeQuestionMark = unexpectedBeforeQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
    self.unexpectedBetweenQuestionMarkAndFirstChoice = unexpectedBetweenQuestionMarkAndFirstChoice?.createUnexpectedNodes()
    self.firstChoice = firstChoice.createExprBuildable()
    self.unexpectedBetweenFirstChoiceAndColonMark = unexpectedBetweenFirstChoiceAndColonMark?.createUnexpectedNodes()
    self.colonMark = colonMark
    assert(colonMark.text == #":"#)
  }
  /// Builds a `UnresolvedTernaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedTernaryExprSyntax`.
  func buildUnresolvedTernaryExpr(format: Format) -> UnresolvedTernaryExprSyntax {
    var result = UnresolvedTernaryExprSyntax(unexpectedBeforeQuestionMark?.buildUnexpectedNodes(format: format), questionMark: questionMark.buildToken(format: format), unexpectedBetweenQuestionMarkAndFirstChoice?.buildUnexpectedNodes(format: format), firstChoice: firstChoice.buildExpr(format: format), unexpectedBetweenFirstChoiceAndColonMark?.buildUnexpectedNodes(format: format), colonMark: colonMark.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedTernaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedTernaryExpr`.
  public func createUnresolvedTernaryExpr() -> UnresolvedTernaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedTernaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TernaryExpr: ExprBuildable, ExpressibleAsTernaryExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeConditionExpression: UnexpectedNodes?
  var conditionExpression: ExprBuildable
  var unexpectedBetweenConditionExpressionAndQuestionMark: UnexpectedNodes?
  var questionMark: Token
  var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodes?
  var firstChoice: ExprBuildable
  var unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodes?
  var colonMark: Token
  var unexpectedBetweenColonMarkAndSecondChoice: UnexpectedNodes?
  var secondChoice: ExprBuildable
  /// Creates a `TernaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeConditionExpression: 
  ///   - conditionExpression: 
  ///   - unexpectedBetweenConditionExpressionAndQuestionMark: 
  ///   - questionMark: 
  ///   - unexpectedBetweenQuestionMarkAndFirstChoice: 
  ///   - firstChoice: 
  ///   - unexpectedBetweenFirstChoiceAndColonMark: 
  ///   - colonMark: 
  ///   - unexpectedBetweenColonMarkAndSecondChoice: 
  ///   - secondChoice: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeConditionExpression: ExpressibleAsUnexpectedNodes? = nil, conditionExpression: ExpressibleAsExprBuildable, unexpectedBetweenConditionExpressionAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`infixQuestionMark`, unexpectedBetweenQuestionMarkAndFirstChoice: ExpressibleAsUnexpectedNodes? = nil, firstChoice: ExpressibleAsExprBuildable, unexpectedBetweenFirstChoiceAndColonMark: ExpressibleAsUnexpectedNodes? = nil, colonMark: Token = Token.`colon`, unexpectedBetweenColonMarkAndSecondChoice: ExpressibleAsUnexpectedNodes? = nil, secondChoice: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeConditionExpression = unexpectedBeforeConditionExpression?.createUnexpectedNodes()
    self.conditionExpression = conditionExpression.createExprBuildable()
    self.unexpectedBetweenConditionExpressionAndQuestionMark = unexpectedBetweenConditionExpressionAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
    self.unexpectedBetweenQuestionMarkAndFirstChoice = unexpectedBetweenQuestionMarkAndFirstChoice?.createUnexpectedNodes()
    self.firstChoice = firstChoice.createExprBuildable()
    self.unexpectedBetweenFirstChoiceAndColonMark = unexpectedBetweenFirstChoiceAndColonMark?.createUnexpectedNodes()
    self.colonMark = colonMark
    assert(colonMark.text == #":"#)
    self.unexpectedBetweenColonMarkAndSecondChoice = unexpectedBetweenColonMarkAndSecondChoice?.createUnexpectedNodes()
    self.secondChoice = secondChoice.createExprBuildable()
  }
  /// Builds a `TernaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TernaryExprSyntax`.
  func buildTernaryExpr(format: Format) -> TernaryExprSyntax {
    var result = TernaryExprSyntax(unexpectedBeforeConditionExpression?.buildUnexpectedNodes(format: format), conditionExpression: conditionExpression.buildExpr(format: format), unexpectedBetweenConditionExpressionAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: questionMark.buildToken(format: format), unexpectedBetweenQuestionMarkAndFirstChoice?.buildUnexpectedNodes(format: format), firstChoice: firstChoice.buildExpr(format: format), unexpectedBetweenFirstChoiceAndColonMark?.buildUnexpectedNodes(format: format), colonMark: colonMark.buildToken(format: format), unexpectedBetweenColonMarkAndSecondChoice?.buildUnexpectedNodes(format: format), secondChoice: secondChoice.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTernaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTernaryExpr`.
  public func createTernaryExpr() -> TernaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TernaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct MemberAccessExpr: ExprBuildable, ExpressibleAsMemberAccessExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBase: UnexpectedNodes?
  var base: ExprBuildable?
  var unexpectedBetweenBaseAndDot: UnexpectedNodes?
  var dot: Token
  var unexpectedBetweenDotAndName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodes?
  var declNameArguments: DeclNameArguments?
  /// Creates a `MemberAccessExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBase: 
  ///   - base: 
  ///   - unexpectedBetweenBaseAndDot: 
  ///   - dot: 
  ///   - unexpectedBetweenDotAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDeclNameArguments: 
  ///   - declNameArguments: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBase: ExpressibleAsUnexpectedNodes? = nil, base: ExpressibleAsExprBuildable? = nil, unexpectedBetweenBaseAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token, unexpectedBetweenDotAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBase = unexpectedBeforeBase?.createUnexpectedNodes()
    self.base = base?.createExprBuildable()
    self.unexpectedBetweenBaseAndDot = unexpectedBetweenBaseAndDot?.createUnexpectedNodes()
    self.dot = dot
    assert(dot.text == #"."# || dot.text == #"."#)
    self.unexpectedBetweenDotAndName = unexpectedBetweenDotAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndDeclNameArguments = unexpectedBetweenNameAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `MemberAccessExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberAccessExprSyntax`.
  func buildMemberAccessExpr(format: Format) -> MemberAccessExprSyntax {
    var result = MemberAccessExprSyntax(unexpectedBeforeBase?.buildUnexpectedNodes(format: format), base: base?.buildExpr(format: format), unexpectedBetweenBaseAndDot?.buildUnexpectedNodes(format: format), dot: dot.buildToken(format: format), unexpectedBetweenDotAndName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildMemberAccessExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsMemberAccessExpr`.
  public func createMemberAccessExpr() -> MemberAccessExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `MemberAccessExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct UnresolvedIsExpr: ExprBuildable, ExpressibleAsUnresolvedIsExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIsTok: UnexpectedNodes?
  var isTok: Token
  /// Creates a `UnresolvedIsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIsTok: 
  ///   - isTok: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIsTok: ExpressibleAsUnexpectedNodes? = nil, isTok: Token = Token.`is`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIsTok = unexpectedBeforeIsTok?.createUnexpectedNodes()
    self.isTok = isTok
    assert(isTok.text == #"is"#)
  }
  /// Builds a `UnresolvedIsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedIsExprSyntax`.
  func buildUnresolvedIsExpr(format: Format) -> UnresolvedIsExprSyntax {
    var result = UnresolvedIsExprSyntax(unexpectedBeforeIsTok?.buildUnexpectedNodes(format: format), isTok: isTok.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedIsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedIsExpr`.
  public func createUnresolvedIsExpr() -> UnresolvedIsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedIsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IsExpr: ExprBuildable, ExpressibleAsIsExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndIsTok: UnexpectedNodes?
  var isTok: Token
  var unexpectedBetweenIsTokAndTypeName: UnexpectedNodes?
  var typeName: TypeBuildable
  /// Creates a `IsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndIsTok: 
  ///   - isTok: 
  ///   - unexpectedBetweenIsTokAndTypeName: 
  ///   - typeName: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndIsTok: ExpressibleAsUnexpectedNodes? = nil, isTok: Token = Token.`is`, unexpectedBetweenIsTokAndTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndIsTok = unexpectedBetweenExpressionAndIsTok?.createUnexpectedNodes()
    self.isTok = isTok
    assert(isTok.text == #"is"#)
    self.unexpectedBetweenIsTokAndTypeName = unexpectedBetweenIsTokAndTypeName?.createUnexpectedNodes()
    self.typeName = typeName.createTypeBuildable()
  }
  /// Builds a `IsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IsExprSyntax`.
  func buildIsExpr(format: Format) -> IsExprSyntax {
    var result = IsExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndIsTok?.buildUnexpectedNodes(format: format), isTok: isTok.buildToken(format: format), unexpectedBetweenIsTokAndTypeName?.buildUnexpectedNodes(format: format), typeName: typeName.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildIsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIsExpr`.
  public func createIsExpr() -> IsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct UnresolvedAsExpr: ExprBuildable, ExpressibleAsUnresolvedAsExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAsTok: UnexpectedNodes?
  var asTok: Token
  var unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodes?
  var questionOrExclamationMark: Token?
  /// Creates a `UnresolvedAsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAsTok: 
  ///   - asTok: 
  ///   - unexpectedBetweenAsTokAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAsTok: ExpressibleAsUnexpectedNodes? = nil, asTok: Token = Token.`as`, unexpectedBetweenAsTokAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAsTok = unexpectedBeforeAsTok?.createUnexpectedNodes()
    self.asTok = asTok
    assert(asTok.text == #"as"#)
    self.unexpectedBetweenAsTokAndQuestionOrExclamationMark = unexpectedBetweenAsTokAndQuestionOrExclamationMark?.createUnexpectedNodes()
    self.questionOrExclamationMark = questionOrExclamationMark
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
  }
  /// Builds a `UnresolvedAsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedAsExprSyntax`.
  func buildUnresolvedAsExpr(format: Format) -> UnresolvedAsExprSyntax {
    var result = UnresolvedAsExprSyntax(unexpectedBeforeAsTok?.buildUnexpectedNodes(format: format), asTok: asTok.buildToken(format: format), unexpectedBetweenAsTokAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format), questionOrExclamationMark: questionOrExclamationMark?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedAsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedAsExpr`.
  public func createUnresolvedAsExpr() -> UnresolvedAsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedAsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AsExpr: ExprBuildable, ExpressibleAsAsExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndAsTok: UnexpectedNodes?
  var asTok: Token
  var unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodes?
  var questionOrExclamationMark: Token?
  var unexpectedBetweenQuestionOrExclamationMarkAndTypeName: UnexpectedNodes?
  var typeName: TypeBuildable
  /// Creates a `AsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndAsTok: 
  ///   - asTok: 
  ///   - unexpectedBetweenAsTokAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  ///   - unexpectedBetweenQuestionOrExclamationMarkAndTypeName: 
  ///   - typeName: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndAsTok: ExpressibleAsUnexpectedNodes? = nil, asTok: Token = Token.`as`, unexpectedBetweenAsTokAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil, unexpectedBetweenQuestionOrExclamationMarkAndTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndAsTok = unexpectedBetweenExpressionAndAsTok?.createUnexpectedNodes()
    self.asTok = asTok
    assert(asTok.text == #"as"#)
    self.unexpectedBetweenAsTokAndQuestionOrExclamationMark = unexpectedBetweenAsTokAndQuestionOrExclamationMark?.createUnexpectedNodes()
    self.questionOrExclamationMark = questionOrExclamationMark
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
    self.unexpectedBetweenQuestionOrExclamationMarkAndTypeName = unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.createUnexpectedNodes()
    self.typeName = typeName.createTypeBuildable()
  }
  /// Builds a `AsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AsExprSyntax`.
  func buildAsExpr(format: Format) -> AsExprSyntax {
    var result = AsExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndAsTok?.buildUnexpectedNodes(format: format), asTok: asTok.buildToken(format: format), unexpectedBetweenAsTokAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format), questionOrExclamationMark: questionOrExclamationMark?.buildToken(format: format), unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.buildUnexpectedNodes(format: format), typeName: typeName.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildAsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAsExpr`.
  public func createAsExpr() -> AsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TypeExpr: ExprBuildable, ExpressibleAsTypeExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeType: UnexpectedNodes?
  var type: TypeBuildable
  /// Creates a `TypeExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `TypeExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeExprSyntax`.
  func buildTypeExpr(format: Format) -> TypeExprSyntax {
    var result = TypeExprSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: type.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTypeExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTypeExpr`.
  public func createTypeExpr() -> TypeExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TypeExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ClosureCaptureItem: SyntaxBuildable, ExpressibleAsClosureCaptureItem, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeSpecifier: UnexpectedNodes?
  var specifier: TokenList?
  var unexpectedBetweenSpecifierAndName: UnexpectedNodes?
  var name: Token?
  var unexpectedBetweenNameAndAssignToken: UnexpectedNodes?
  var assignToken: Token?
  var unexpectedBetweenAssignTokenAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `ClosureCaptureItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSpecifier: 
  ///   - specifier: 
  ///   - unexpectedBetweenSpecifierAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndAssignToken: 
  ///   - assignToken: 
  ///   - unexpectedBetweenAssignTokenAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: ExpressibleAsTokenList? = nil, unexpectedBetweenSpecifierAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token? = nil, unexpectedBetweenAssignTokenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeSpecifier = unexpectedBeforeSpecifier?.createUnexpectedNodes()
    self.specifier = specifier?.createTokenList()
    self.unexpectedBetweenSpecifierAndName = unexpectedBetweenSpecifierAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndAssignToken = unexpectedBetweenNameAndAssignToken?.createUnexpectedNodes()
    self.assignToken = assignToken
    assert(assignToken == nil || assignToken!.text == #"="#)
    self.unexpectedBetweenAssignTokenAndExpression = unexpectedBetweenAssignTokenAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndTrailingComma = unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: ExpressibleAsTokenList? = nil, unexpectedBetweenSpecifierAndName: ExpressibleAsUnexpectedNodes? = nil, name: String?, unexpectedBetweenNameAndAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token? = nil, unexpectedBetweenAssignTokenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSpecifier: unexpectedBeforeSpecifier, specifier: specifier, unexpectedBetweenSpecifierAndName: unexpectedBetweenSpecifierAndName, name: name.map {
      Token.`identifier`($0)
    }, unexpectedBetweenNameAndAssignToken: unexpectedBetweenNameAndAssignToken, assignToken: assignToken, unexpectedBetweenAssignTokenAndExpression: unexpectedBetweenAssignTokenAndExpression, expression: expression, unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `ClosureCaptureItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureCaptureItemSyntax`.
  func buildClosureCaptureItem(format: Format) -> ClosureCaptureItemSyntax {
    var result = ClosureCaptureItemSyntax(unexpectedBeforeSpecifier?.buildUnexpectedNodes(format: format), specifier: specifier?.buildTokenList(format: format), unexpectedBetweenSpecifierAndName?.buildUnexpectedNodes(format: format), name: name?.buildToken(format: format), unexpectedBetweenNameAndAssignToken?.buildUnexpectedNodes(format: format), assignToken: assignToken?.buildToken(format: format), unexpectedBetweenAssignTokenAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureCaptureItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureCaptureItem`.
  public func createClosureCaptureItem() -> ClosureCaptureItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureCaptureItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ClosureCaptureSignature: SyntaxBuildable, ExpressibleAsClosureCaptureSignature {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftSquare: UnexpectedNodes?
  var leftSquare: Token
  var unexpectedBetweenLeftSquareAndItems: UnexpectedNodes?
  var items: ClosureCaptureItemList?
  var unexpectedBetweenItemsAndRightSquare: UnexpectedNodes?
  var rightSquare: Token
  /// Creates a `ClosureCaptureSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndItems: 
  ///   - items: 
  ///   - unexpectedBetweenItemsAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndItems: ExpressibleAsUnexpectedNodes? = nil, items: ExpressibleAsClosureCaptureItemList? = nil, unexpectedBetweenItemsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftSquare = unexpectedBeforeLeftSquare?.createUnexpectedNodes()
    self.leftSquare = leftSquare
    assert(leftSquare.text == #"["#)
    self.unexpectedBetweenLeftSquareAndItems = unexpectedBetweenLeftSquareAndItems?.createUnexpectedNodes()
    self.items = items?.createClosureCaptureItemList()
    self.unexpectedBetweenItemsAndRightSquare = unexpectedBetweenItemsAndRightSquare?.createUnexpectedNodes()
    self.rightSquare = rightSquare
    assert(rightSquare.text == #"]"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndItems: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenItemsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`, @ClosureCaptureItemListBuilder itemsBuilder: () -> ExpressibleAsClosureCaptureItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare, leftSquare: leftSquare, unexpectedBetweenLeftSquareAndItems: unexpectedBetweenLeftSquareAndItems, items: itemsBuilder(), unexpectedBetweenItemsAndRightSquare: unexpectedBetweenItemsAndRightSquare, rightSquare: rightSquare)
  }
  /// Builds a `ClosureCaptureSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureCaptureSignatureSyntax`.
  func buildClosureCaptureSignature(format: Format) -> ClosureCaptureSignatureSyntax {
    var result = ClosureCaptureSignatureSyntax(unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format), leftSquare: leftSquare.buildToken(format: format), unexpectedBetweenLeftSquareAndItems?.buildUnexpectedNodes(format: format), items: items?.buildClosureCaptureItemList(format: format), unexpectedBetweenItemsAndRightSquare?.buildUnexpectedNodes(format: format), rightSquare: rightSquare.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureCaptureSignature(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureCaptureSignature`.
  public func createClosureCaptureSignature() -> ClosureCaptureSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureCaptureSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ClosureParam: SyntaxBuildable, ExpressibleAsClosureParam, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `ClosureParam` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingComma = unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `ClosureParamSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureParamSyntax`.
  func buildClosureParam(format: Format) -> ClosureParamSyntax {
    var result = ClosureParamSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureParam(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureParam`.
  public func createClosureParam() -> ClosureParam {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureParam` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ClosureSignature: SyntaxBuildable, ExpressibleAsClosureSignature {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndCapture: UnexpectedNodes?
  var capture: ClosureCaptureSignature?
  var unexpectedBetweenCaptureAndInput: UnexpectedNodes?
  var input: SyntaxBuildable?
  var unexpectedBetweenInputAndAsyncKeyword: UnexpectedNodes?
  var asyncKeyword: Token?
  var unexpectedBetweenAsyncKeywordAndThrowsTok: UnexpectedNodes?
  var throwsTok: Token?
  var unexpectedBetweenThrowsTokAndOutput: UnexpectedNodes?
  var output: ReturnClause?
  var unexpectedBetweenOutputAndInTok: UnexpectedNodes?
  var inTok: Token
  /// Creates a `ClosureSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndCapture: 
  ///   - capture: 
  ///   - unexpectedBetweenCaptureAndInput: 
  ///   - input: 
  ///   - unexpectedBetweenInputAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsTok: 
  ///   - throwsTok: 
  ///   - unexpectedBetweenThrowsTokAndOutput: 
  ///   - output: 
  ///   - unexpectedBetweenOutputAndInTok: 
  ///   - inTok: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndCapture: ExpressibleAsUnexpectedNodes? = nil, capture: ExpressibleAsClosureCaptureSignature? = nil, unexpectedBetweenCaptureAndInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenInputAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsTok: ExpressibleAsUnexpectedNodes? = nil, throwsTok: Token? = nil, unexpectedBetweenThrowsTokAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil, unexpectedBetweenOutputAndInTok: ExpressibleAsUnexpectedNodes? = nil, inTok: Token = Token.`in`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndCapture = unexpectedBetweenAttributesAndCapture?.createUnexpectedNodes()
    self.capture = capture?.createClosureCaptureSignature()
    self.unexpectedBetweenCaptureAndInput = unexpectedBetweenCaptureAndInput?.createUnexpectedNodes()
    self.input = input?.createSyntaxBuildable()
    self.unexpectedBetweenInputAndAsyncKeyword = unexpectedBetweenInputAndAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsTok = unexpectedBetweenAsyncKeywordAndThrowsTok?.createUnexpectedNodes()
    self.throwsTok = throwsTok
    assert(throwsTok == nil || throwsTok!.text == #"throws"#)
    self.unexpectedBetweenThrowsTokAndOutput = unexpectedBetweenThrowsTokAndOutput?.createUnexpectedNodes()
    self.output = output?.createReturnClause()
    self.unexpectedBetweenOutputAndInTok = unexpectedBetweenOutputAndInTok?.createUnexpectedNodes()
    self.inTok = inTok
    assert(inTok.text == #"in"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndCapture: ExpressibleAsUnexpectedNodes? = nil, capture: ExpressibleAsClosureCaptureSignature? = nil, unexpectedBetweenCaptureAndInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenInputAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsTok: ExpressibleAsUnexpectedNodes? = nil, throwsTok: Token? = nil, unexpectedBetweenThrowsTokAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil, unexpectedBetweenOutputAndInTok: ExpressibleAsUnexpectedNodes? = nil, inTok: Token = Token.`in`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndCapture: unexpectedBetweenAttributesAndCapture, capture: capture, unexpectedBetweenCaptureAndInput: unexpectedBetweenCaptureAndInput, input: input, unexpectedBetweenInputAndAsyncKeyword: unexpectedBetweenInputAndAsyncKeyword, asyncKeyword: asyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncKeywordAndThrowsTok: unexpectedBetweenAsyncKeywordAndThrowsTok, throwsTok: throwsTok, unexpectedBetweenThrowsTokAndOutput: unexpectedBetweenThrowsTokAndOutput, output: output, unexpectedBetweenOutputAndInTok: unexpectedBetweenOutputAndInTok, inTok: inTok)
  }
  /// Builds a `ClosureSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureSignatureSyntax`.
  func buildClosureSignature(format: Format) -> ClosureSignatureSyntax {
    var result = ClosureSignatureSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndCapture?.buildUnexpectedNodes(format: format), capture: capture?.buildClosureCaptureSignature(format: format), unexpectedBetweenCaptureAndInput?.buildUnexpectedNodes(format: format), input: input?.buildSyntax(format: format), unexpectedBetweenInputAndAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: asyncKeyword?.buildToken(format: format), unexpectedBetweenAsyncKeywordAndThrowsTok?.buildUnexpectedNodes(format: format), throwsTok: throwsTok?.buildToken(format: format), unexpectedBetweenThrowsTokAndOutput?.buildUnexpectedNodes(format: format), output: output?.buildReturnClause(format: format), unexpectedBetweenOutputAndInTok?.buildUnexpectedNodes(format: format), inTok: inTok.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureSignature(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureSignature`.
  public func createClosureSignature() -> ClosureSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ClosureExpr: ExprBuildable, ExpressibleAsClosureExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftBrace: UnexpectedNodes?
  var leftBrace: Token
  var unexpectedBetweenLeftBraceAndSignature: UnexpectedNodes?
  var signature: ClosureSignature?
  var unexpectedBetweenSignatureAndStatements: UnexpectedNodes?
  var statements: CodeBlockItemList
  var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodes?
  var rightBrace: Token
  /// Creates a `ClosureExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsClosureSignature? = nil, unexpectedBetweenSignatureAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndSignature = unexpectedBetweenLeftBraceAndSignature?.createUnexpectedNodes()
    self.signature = signature?.createClosureSignature()
    self.unexpectedBetweenSignatureAndStatements = unexpectedBetweenSignatureAndStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
    self.unexpectedBetweenStatementsAndRightBrace = unexpectedBetweenStatementsAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsClosureSignature? = nil, unexpectedBetweenSignatureAndStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndSignature: unexpectedBetweenLeftBraceAndSignature, signature: signature, unexpectedBetweenSignatureAndStatements: unexpectedBetweenSignatureAndStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `ClosureExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureExprSyntax`.
  func buildClosureExpr(format: Format) -> ClosureExprSyntax {
    var result = ClosureExprSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: leftBrace.buildToken(format: format), unexpectedBetweenLeftBraceAndSignature?.buildUnexpectedNodes(format: format), signature: signature?.buildClosureSignature(format: format), unexpectedBetweenSignatureAndStatements?.buildUnexpectedNodes(format: format), statements: statements.buildCodeBlockItemList(format: format._indented), unexpectedBetweenStatementsAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: rightBrace.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildClosureExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsClosureExpr`.
  public func createClosureExpr() -> ClosureExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ClosureExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct UnresolvedPatternExpr: ExprBuildable, ExpressibleAsUnresolvedPatternExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePattern: UnexpectedNodes?
  var pattern: PatternBuildable
  /// Creates a `UnresolvedPatternExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
  }
  /// Builds a `UnresolvedPatternExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedPatternExprSyntax`.
  func buildUnresolvedPatternExpr(format: Format) -> UnresolvedPatternExprSyntax {
    var result = UnresolvedPatternExprSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedPatternExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedPatternExpr`.
  public func createUnresolvedPatternExpr() -> UnresolvedPatternExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedPatternExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct MultipleTrailingClosureElement: SyntaxBuildable, ExpressibleAsMultipleTrailingClosureElement {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabel: UnexpectedNodes?
  var label: Token
  var unexpectedBetweenLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndClosure: UnexpectedNodes?
  var closure: ClosureExpr
  /// Creates a `MultipleTrailingClosureElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndClosure: 
  ///   - closure: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndClosure: ExpressibleAsUnexpectedNodes? = nil, closure: ExpressibleAsClosureExpr) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndClosure = unexpectedBetweenColonAndClosure?.createUnexpectedNodes()
    self.closure = closure.createClosureExpr()
  }
  /// Builds a `MultipleTrailingClosureElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MultipleTrailingClosureElementSyntax`.
  func buildMultipleTrailingClosureElement(format: Format) -> MultipleTrailingClosureElementSyntax {
    var result = MultipleTrailingClosureElementSyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: label.buildToken(format: format), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndClosure?.buildUnexpectedNodes(format: format), closure: closure.buildClosureExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMultipleTrailingClosureElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMultipleTrailingClosureElement`.
  public func createMultipleTrailingClosureElement() -> MultipleTrailingClosureElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MultipleTrailingClosureElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct FunctionCallExpr: ExprBuildable, ExpressibleAsFunctionCallExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeCalledExpression: UnexpectedNodes?
  var calledExpression: ExprBuildable
  var unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodes?
  var leftParen: Token?
  var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodes?
  var argumentList: TupleExprElementList
  var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodes?
  var rightParen: Token?
  var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodes?
  var trailingClosure: ClosureExpr?
  var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodes?
  var additionalTrailingClosures: MultipleTrailingClosureElementList?
  /// Creates a `FunctionCallExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCalledExpression: 
  ///   - calledExpression: 
  ///   - unexpectedBetweenCalledExpressionAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightParen: 
  ///   - rightParen: 
  ///   - unexpectedBetweenRightParenAndTrailingClosure: 
  ///   - trailingClosure: 
  ///   - unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: 
  ///   - additionalTrailingClosures: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeCalledExpression = unexpectedBeforeCalledExpression?.createUnexpectedNodes()
    self.calledExpression = calledExpression.createExprBuildable()
    self.unexpectedBetweenCalledExpressionAndLeftParen = unexpectedBetweenCalledExpressionAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgumentList = unexpectedBetweenLeftParenAndArgumentList?.createUnexpectedNodes()
    self.argumentList = argumentList.createTupleExprElementList()
    self.unexpectedBetweenArgumentListAndRightParen = unexpectedBetweenArgumentListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.unexpectedBetweenRightParenAndTrailingClosure = unexpectedBetweenRightParenAndTrailingClosure?.createUnexpectedNodes()
    self.trailingClosure = trailingClosure?.createClosureExpr()
    self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures = unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.createUnexpectedNodes()
    self.additionalTrailingClosures = additionalTrailingClosures?.createMultipleTrailingClosureElementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression, calledExpression: calledExpression, unexpectedBetweenCalledExpressionAndLeftParen: unexpectedBetweenCalledExpressionAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen, rightParen: rightParen, unexpectedBetweenRightParenAndTrailingClosure: unexpectedBetweenRightParenAndTrailingClosure, trailingClosure: trailingClosure, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, additionalTrailingClosures: additionalTrailingClosures)
  }
  /// Builds a `FunctionCallExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionCallExprSyntax`.
  func buildFunctionCallExpr(format: Format) -> FunctionCallExprSyntax {
    var result = FunctionCallExprSyntax(unexpectedBeforeCalledExpression?.buildUnexpectedNodes(format: format), calledExpression: calledExpression.buildExpr(format: format), unexpectedBetweenCalledExpressionAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen?.buildToken(format: format), unexpectedBetweenLeftParenAndArgumentList?.buildUnexpectedNodes(format: format), argumentList: argumentList.buildTupleExprElementList(format: format), unexpectedBetweenArgumentListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen?.buildToken(format: format), unexpectedBetweenRightParenAndTrailingClosure?.buildUnexpectedNodes(format: format), trailingClosure: trailingClosure?.buildClosureExpr(format: format), unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.buildUnexpectedNodes(format: format), additionalTrailingClosures: additionalTrailingClosures?.buildMultipleTrailingClosureElementList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildFunctionCallExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionCallExpr`.
  public func createFunctionCallExpr() -> FunctionCallExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `FunctionCallExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SubscriptExpr: ExprBuildable, ExpressibleAsSubscriptExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeCalledExpression: UnexpectedNodes?
  var calledExpression: ExprBuildable
  var unexpectedBetweenCalledExpressionAndLeftBracket: UnexpectedNodes?
  var leftBracket: Token
  var unexpectedBetweenLeftBracketAndArgumentList: UnexpectedNodes?
  var argumentList: TupleExprElementList
  var unexpectedBetweenArgumentListAndRightBracket: UnexpectedNodes?
  var rightBracket: Token
  var unexpectedBetweenRightBracketAndTrailingClosure: UnexpectedNodes?
  var trailingClosure: ClosureExpr?
  var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodes?
  var additionalTrailingClosures: MultipleTrailingClosureElementList?
  /// Creates a `SubscriptExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCalledExpression: 
  ///   - calledExpression: 
  ///   - unexpectedBetweenCalledExpressionAndLeftBracket: 
  ///   - leftBracket: 
  ///   - unexpectedBetweenLeftBracketAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightBracket: 
  ///   - rightBracket: 
  ///   - unexpectedBetweenRightBracketAndTrailingClosure: 
  ///   - trailingClosure: 
  ///   - unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: 
  ///   - additionalTrailingClosures: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`, unexpectedBetweenRightBracketAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeCalledExpression = unexpectedBeforeCalledExpression?.createUnexpectedNodes()
    self.calledExpression = calledExpression.createExprBuildable()
    self.unexpectedBetweenCalledExpressionAndLeftBracket = unexpectedBetweenCalledExpressionAndLeftBracket?.createUnexpectedNodes()
    self.leftBracket = leftBracket
    assert(leftBracket.text == #"["#)
    self.unexpectedBetweenLeftBracketAndArgumentList = unexpectedBetweenLeftBracketAndArgumentList?.createUnexpectedNodes()
    self.argumentList = argumentList.createTupleExprElementList()
    self.unexpectedBetweenArgumentListAndRightBracket = unexpectedBetweenArgumentListAndRightBracket?.createUnexpectedNodes()
    self.rightBracket = rightBracket
    assert(rightBracket.text == #"]"#)
    self.unexpectedBetweenRightBracketAndTrailingClosure = unexpectedBetweenRightBracketAndTrailingClosure?.createUnexpectedNodes()
    self.trailingClosure = trailingClosure?.createClosureExpr()
    self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures = unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.createUnexpectedNodes()
    self.additionalTrailingClosures = additionalTrailingClosures?.createMultipleTrailingClosureElementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`, unexpectedBetweenRightBracketAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression, calledExpression: calledExpression, unexpectedBetweenCalledExpressionAndLeftBracket: unexpectedBetweenCalledExpressionAndLeftBracket, leftBracket: leftBracket, unexpectedBetweenLeftBracketAndArgumentList: unexpectedBetweenLeftBracketAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightBracket: unexpectedBetweenArgumentListAndRightBracket, rightBracket: rightBracket, unexpectedBetweenRightBracketAndTrailingClosure: unexpectedBetweenRightBracketAndTrailingClosure, trailingClosure: trailingClosure, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, additionalTrailingClosures: additionalTrailingClosures)
  }
  /// Builds a `SubscriptExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SubscriptExprSyntax`.
  func buildSubscriptExpr(format: Format) -> SubscriptExprSyntax {
    var result = SubscriptExprSyntax(unexpectedBeforeCalledExpression?.buildUnexpectedNodes(format: format), calledExpression: calledExpression.buildExpr(format: format), unexpectedBetweenCalledExpressionAndLeftBracket?.buildUnexpectedNodes(format: format), leftBracket: leftBracket.buildToken(format: format), unexpectedBetweenLeftBracketAndArgumentList?.buildUnexpectedNodes(format: format), argumentList: argumentList.buildTupleExprElementList(format: format), unexpectedBetweenArgumentListAndRightBracket?.buildUnexpectedNodes(format: format), rightBracket: rightBracket.buildToken(format: format), unexpectedBetweenRightBracketAndTrailingClosure?.buildUnexpectedNodes(format: format), trailingClosure: trailingClosure?.buildClosureExpr(format: format), unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.buildUnexpectedNodes(format: format), additionalTrailingClosures: additionalTrailingClosures?.buildMultipleTrailingClosureElementList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSubscriptExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSubscriptExpr`.
  public func createSubscriptExpr() -> SubscriptExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SubscriptExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct OptionalChainingExpr: ExprBuildable, ExpressibleAsOptionalChainingExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodes?
  var questionMark: Token
  /// Creates a `OptionalChainingExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndQuestionMark = unexpectedBetweenExpressionAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
  }
  /// Builds a `OptionalChainingExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalChainingExprSyntax`.
  func buildOptionalChainingExpr(format: Format) -> OptionalChainingExprSyntax {
    var result = OptionalChainingExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: questionMark.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildOptionalChainingExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalChainingExpr`.
  public func createOptionalChainingExpr() -> OptionalChainingExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `OptionalChainingExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ForcedValueExpr: ExprBuildable, ExpressibleAsForcedValueExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodes?
  var exclamationMark: Token
  /// Creates a `ForcedValueExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndExclamationMark: 
  ///   - exclamationMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndExclamationMark: ExpressibleAsUnexpectedNodes? = nil, exclamationMark: Token = Token.`exclamationMark`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndExclamationMark = unexpectedBetweenExpressionAndExclamationMark?.createUnexpectedNodes()
    self.exclamationMark = exclamationMark
    assert(exclamationMark.text == #"!"#)
  }
  /// Builds a `ForcedValueExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ForcedValueExprSyntax`.
  func buildForcedValueExpr(format: Format) -> ForcedValueExprSyntax {
    var result = ForcedValueExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndExclamationMark?.buildUnexpectedNodes(format: format), exclamationMark: exclamationMark.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildForcedValueExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsForcedValueExpr`.
  public func createForcedValueExpr() -> ForcedValueExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ForcedValueExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PostfixUnaryExpr: ExprBuildable, ExpressibleAsPostfixUnaryExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndOperatorToken: UnexpectedNodes?
  var operatorToken: Token
  /// Creates a `PostfixUnaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndOperatorToken: 
  ///   - operatorToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndOperatorToken = unexpectedBetweenExpressionAndOperatorToken?.createUnexpectedNodes()
    self.operatorToken = operatorToken
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression, expression: expression, unexpectedBetweenExpressionAndOperatorToken: unexpectedBetweenExpressionAndOperatorToken, operatorToken: Token.`postfixOperator`(operatorToken))
  }
  /// Builds a `PostfixUnaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PostfixUnaryExprSyntax`.
  func buildPostfixUnaryExpr(format: Format) -> PostfixUnaryExprSyntax {
    var result = PostfixUnaryExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndOperatorToken?.buildUnexpectedNodes(format: format), operatorToken: operatorToken.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPostfixUnaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPostfixUnaryExpr`.
  public func createPostfixUnaryExpr() -> PostfixUnaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PostfixUnaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SpecializeExpr: ExprBuildable, ExpressibleAsSpecializeExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodes?
  var genericArgumentClause: GenericArgumentClause
  /// Creates a `SpecializeExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndGenericArgumentClause = unexpectedBetweenExpressionAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause.createGenericArgumentClause()
  }
  /// Builds a `SpecializeExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SpecializeExprSyntax`.
  func buildSpecializeExpr(format: Format) -> SpecializeExprSyntax {
    var result = SpecializeExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: genericArgumentClause.buildGenericArgumentClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSpecializeExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSpecializeExpr`.
  public func createSpecializeExpr() -> SpecializeExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SpecializeExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct StringSegment: SyntaxBuildable, ExpressibleAsStringSegment {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeContent: UnexpectedNodes?
  var content: Token
  /// Creates a `StringSegment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeContent: 
  ///   - content: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeContent: ExpressibleAsUnexpectedNodes? = nil, content: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeContent = unexpectedBeforeContent?.createUnexpectedNodes()
    self.content = content
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContent: ExpressibleAsUnexpectedNodes? = nil, content: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeContent: unexpectedBeforeContent, content: Token.`stringSegment`(content))
  }
  /// Builds a `StringSegmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StringSegmentSyntax`.
  func buildStringSegment(format: Format) -> StringSegmentSyntax {
    var result = StringSegmentSyntax(unexpectedBeforeContent?.buildUnexpectedNodes(format: format), content: content.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildStringSegment(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsStringSegment`.
  public func createStringSegment() -> StringSegment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StringSegment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ExpressionSegment: SyntaxBuildable, ExpressibleAsExpressionSegment {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBackslash: UnexpectedNodes?
  var backslash: Token
  var unexpectedBetweenBackslashAndDelimiter: UnexpectedNodes?
  var delimiter: Token?
  var unexpectedBetweenDelimiterAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndExpressions: UnexpectedNodes?
  var expressions: TupleExprElementList
  var unexpectedBetweenExpressionsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `ExpressionSegment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBackslash: 
  ///   - backslash: 
  ///   - unexpectedBetweenBackslashAndDelimiter: 
  ///   - delimiter: 
  ///   - unexpectedBetweenDelimiterAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndExpressions: 
  ///   - expressions: 
  ///   - unexpectedBetweenExpressionsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndDelimiter: ExpressibleAsUnexpectedNodes? = nil, delimiter: Token? = nil, unexpectedBetweenDelimiterAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpressions: ExpressibleAsUnexpectedNodes? = nil, expressions: ExpressibleAsTupleExprElementList, unexpectedBetweenExpressionsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`stringInterpolationAnchor`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBackslash = unexpectedBeforeBackslash?.createUnexpectedNodes()
    self.backslash = backslash
    assert(backslash.text == #"\"#)
    self.unexpectedBetweenBackslashAndDelimiter = unexpectedBetweenBackslashAndDelimiter?.createUnexpectedNodes()
    self.delimiter = delimiter
    self.unexpectedBetweenDelimiterAndLeftParen = unexpectedBetweenDelimiterAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndExpressions = unexpectedBetweenLeftParenAndExpressions?.createUnexpectedNodes()
    self.expressions = expressions.createTupleExprElementList()
    self.unexpectedBetweenExpressionsAndRightParen = unexpectedBetweenExpressionsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndDelimiter: ExpressibleAsUnexpectedNodes? = nil, delimiter: String?, unexpectedBetweenDelimiterAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpressions: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenExpressionsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`stringInterpolationAnchor`, @TupleExprElementListBuilder expressionsBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBackslash: unexpectedBeforeBackslash, backslash: backslash, unexpectedBetweenBackslashAndDelimiter: unexpectedBetweenBackslashAndDelimiter, delimiter: delimiter.map {
      Token.`rawStringDelimiter`($0)
    }, unexpectedBetweenDelimiterAndLeftParen: unexpectedBetweenDelimiterAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndExpressions: unexpectedBetweenLeftParenAndExpressions, expressions: expressionsBuilder(), unexpectedBetweenExpressionsAndRightParen: unexpectedBetweenExpressionsAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ExpressionSegmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionSegmentSyntax`.
  func buildExpressionSegment(format: Format) -> ExpressionSegmentSyntax {
    var result = ExpressionSegmentSyntax(unexpectedBeforeBackslash?.buildUnexpectedNodes(format: format), backslash: backslash.buildToken(format: format), unexpectedBetweenBackslashAndDelimiter?.buildUnexpectedNodes(format: format), delimiter: delimiter?.buildToken(format: format), unexpectedBetweenDelimiterAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndExpressions?.buildUnexpectedNodes(format: format), expressions: expressions.buildTupleExprElementList(format: format), unexpectedBetweenExpressionsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildExpressionSegment(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionSegment`.
  public func createExpressionSegment() -> ExpressionSegment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExpressionSegment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct StringLiteralExpr: ExprBuildable, ExpressibleAsStringLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeOpenDelimiter: UnexpectedNodes?
  var openDelimiter: Token?
  var unexpectedBetweenOpenDelimiterAndOpenQuote: UnexpectedNodes?
  var openQuote: Token
  var unexpectedBetweenOpenQuoteAndSegments: UnexpectedNodes?
  var segments: StringLiteralSegments
  var unexpectedBetweenSegmentsAndCloseQuote: UnexpectedNodes?
  var closeQuote: Token
  var unexpectedBetweenCloseQuoteAndCloseDelimiter: UnexpectedNodes?
  var closeDelimiter: Token?
  /// Creates a `StringLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOpenDelimiter: 
  ///   - openDelimiter: 
  ///   - unexpectedBetweenOpenDelimiterAndOpenQuote: 
  ///   - openQuote: 
  ///   - unexpectedBetweenOpenQuoteAndSegments: 
  ///   - segments: 
  ///   - unexpectedBetweenSegmentsAndCloseQuote: 
  ///   - closeQuote: 
  ///   - unexpectedBetweenCloseQuoteAndCloseDelimiter: 
  ///   - closeDelimiter: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOpenDelimiter: ExpressibleAsUnexpectedNodes? = nil, openDelimiter: Token? = nil, unexpectedBetweenOpenDelimiterAndOpenQuote: ExpressibleAsUnexpectedNodes? = nil, openQuote: Token, unexpectedBetweenOpenQuoteAndSegments: ExpressibleAsUnexpectedNodes? = nil, segments: ExpressibleAsStringLiteralSegments, unexpectedBetweenSegmentsAndCloseQuote: ExpressibleAsUnexpectedNodes? = nil, closeQuote: Token, unexpectedBetweenCloseQuoteAndCloseDelimiter: ExpressibleAsUnexpectedNodes? = nil, closeDelimiter: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeOpenDelimiter = unexpectedBeforeOpenDelimiter?.createUnexpectedNodes()
    self.openDelimiter = openDelimiter
    self.unexpectedBetweenOpenDelimiterAndOpenQuote = unexpectedBetweenOpenDelimiterAndOpenQuote?.createUnexpectedNodes()
    self.openQuote = openQuote
    assert(openQuote.text == #"""# || openQuote.text == #"""""#)
    self.unexpectedBetweenOpenQuoteAndSegments = unexpectedBetweenOpenQuoteAndSegments?.createUnexpectedNodes()
    self.segments = segments.createStringLiteralSegments()
    self.unexpectedBetweenSegmentsAndCloseQuote = unexpectedBetweenSegmentsAndCloseQuote?.createUnexpectedNodes()
    self.closeQuote = closeQuote
    assert(closeQuote.text == #"""# || closeQuote.text == #"""""#)
    self.unexpectedBetweenCloseQuoteAndCloseDelimiter = unexpectedBetweenCloseQuoteAndCloseDelimiter?.createUnexpectedNodes()
    self.closeDelimiter = closeDelimiter
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOpenDelimiter: ExpressibleAsUnexpectedNodes? = nil, openDelimiter: String?, unexpectedBetweenOpenDelimiterAndOpenQuote: ExpressibleAsUnexpectedNodes? = nil, openQuote: Token, unexpectedBetweenOpenQuoteAndSegments: ExpressibleAsUnexpectedNodes? = nil, segments: ExpressibleAsStringLiteralSegments, unexpectedBetweenSegmentsAndCloseQuote: ExpressibleAsUnexpectedNodes? = nil, closeQuote: Token, unexpectedBetweenCloseQuoteAndCloseDelimiter: ExpressibleAsUnexpectedNodes? = nil, closeDelimiter: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOpenDelimiter: unexpectedBeforeOpenDelimiter, openDelimiter: openDelimiter.map {
      Token.`rawStringDelimiter`($0)
    }, unexpectedBetweenOpenDelimiterAndOpenQuote: unexpectedBetweenOpenDelimiterAndOpenQuote, openQuote: openQuote, unexpectedBetweenOpenQuoteAndSegments: unexpectedBetweenOpenQuoteAndSegments, segments: segments, unexpectedBetweenSegmentsAndCloseQuote: unexpectedBetweenSegmentsAndCloseQuote, closeQuote: closeQuote, unexpectedBetweenCloseQuoteAndCloseDelimiter: unexpectedBetweenCloseQuoteAndCloseDelimiter, closeDelimiter: closeDelimiter.map {
      Token.`rawStringDelimiter`($0)
    })
  }
  /// Builds a `StringLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StringLiteralExprSyntax`.
  func buildStringLiteralExpr(format: Format) -> StringLiteralExprSyntax {
    var result = StringLiteralExprSyntax(unexpectedBeforeOpenDelimiter?.buildUnexpectedNodes(format: format), openDelimiter: openDelimiter?.buildToken(format: format), unexpectedBetweenOpenDelimiterAndOpenQuote?.buildUnexpectedNodes(format: format), openQuote: openQuote.buildToken(format: format), unexpectedBetweenOpenQuoteAndSegments?.buildUnexpectedNodes(format: format), segments: segments.buildStringLiteralSegments(format: format), unexpectedBetweenSegmentsAndCloseQuote?.buildUnexpectedNodes(format: format), closeQuote: closeQuote.buildToken(format: format), unexpectedBetweenCloseQuoteAndCloseDelimiter?.buildUnexpectedNodes(format: format), closeDelimiter: closeDelimiter?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildStringLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsStringLiteralExpr`.
  public func createStringLiteralExpr() -> StringLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `StringLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct RegexLiteralExpr: ExprBuildable, ExpressibleAsRegexLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeRegex: UnexpectedNodes?
  var regex: Token
  /// Creates a `RegexLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeRegex: 
  ///   - regex: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeRegex: ExpressibleAsUnexpectedNodes? = nil, regex: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeRegex = unexpectedBeforeRegex?.createUnexpectedNodes()
    self.regex = regex
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRegex: ExpressibleAsUnexpectedNodes? = nil, regex: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeRegex: unexpectedBeforeRegex, regex: Token.`regexLiteral`(regex))
  }
  /// Builds a `RegexLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `RegexLiteralExprSyntax`.
  func buildRegexLiteralExpr(format: Format) -> RegexLiteralExprSyntax {
    var result = RegexLiteralExprSyntax(unexpectedBeforeRegex?.buildUnexpectedNodes(format: format), regex: regex.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildRegexLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsRegexLiteralExpr`.
  public func createRegexLiteralExpr() -> RegexLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `RegexLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct KeyPathExpr: ExprBuildable, ExpressibleAsKeyPathExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBackslash: UnexpectedNodes?
  var backslash: Token
  var unexpectedBetweenBackslashAndRootExpr: UnexpectedNodes?
  var rootExpr: ExprBuildable?
  var unexpectedBetweenRootExprAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `KeyPathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBackslash: 
  ///   - backslash: 
  ///   - unexpectedBetweenBackslashAndRootExpr: 
  ///   - rootExpr: 
  ///   - unexpectedBetweenRootExprAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndRootExpr: ExpressibleAsUnexpectedNodes? = nil, rootExpr: ExpressibleAsExprBuildable? = nil, unexpectedBetweenRootExprAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBackslash = unexpectedBeforeBackslash?.createUnexpectedNodes()
    self.backslash = backslash
    assert(backslash.text == #"\"#)
    self.unexpectedBetweenBackslashAndRootExpr = unexpectedBetweenBackslashAndRootExpr?.createUnexpectedNodes()
    self.rootExpr = rootExpr?.createExprBuildable()
    self.unexpectedBetweenRootExprAndExpression = unexpectedBetweenRootExprAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `KeyPathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathExprSyntax`.
  func buildKeyPathExpr(format: Format) -> KeyPathExprSyntax {
    var result = KeyPathExprSyntax(unexpectedBeforeBackslash?.buildUnexpectedNodes(format: format), backslash: backslash.buildToken(format: format), unexpectedBetweenBackslashAndRootExpr?.buildUnexpectedNodes(format: format), rootExpr: rootExpr?.buildExpr(format: format), unexpectedBetweenRootExprAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildKeyPathExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathExpr`.
  public func createKeyPathExpr() -> KeyPathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `KeyPathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct KeyPathBaseExpr: ExprBuildable, ExpressibleAsKeyPathBaseExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePeriod: UnexpectedNodes?
  var period: Token
  /// Creates a `KeyPathBaseExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePeriod: 
  ///   - period: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePeriod = unexpectedBeforePeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."#)
  }
  /// Builds a `KeyPathBaseExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathBaseExprSyntax`.
  func buildKeyPathBaseExpr(format: Format) -> KeyPathBaseExprSyntax {
    var result = KeyPathBaseExprSyntax(unexpectedBeforePeriod?.buildUnexpectedNodes(format: format), period: period.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildKeyPathBaseExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathBaseExpr`.
  public func createKeyPathBaseExpr() -> KeyPathBaseExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `KeyPathBaseExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ObjcNamePiece: SyntaxBuildable, ExpressibleAsObjcNamePiece {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndDot: UnexpectedNodes?
  var dot: Token?
  /// Creates a `ObjcNamePiece` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDot: 
  ///   - dot: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndDot = unexpectedBetweenNameAndDot?.createUnexpectedNodes()
    self.dot = dot
    assert(dot == nil || dot!.text == #"."#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndDot: unexpectedBetweenNameAndDot, dot: dot)
  }
  /// Builds a `ObjcNamePieceSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcNamePieceSyntax`.
  func buildObjcNamePiece(format: Format) -> ObjcNamePieceSyntax {
    var result = ObjcNamePieceSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndDot?.buildUnexpectedNodes(format: format), dot: dot?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildObjcNamePiece(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsObjcNamePiece`.
  public func createObjcNamePiece() -> ObjcNamePiece {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ObjcNamePiece` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ObjcKeyPathExpr: ExprBuildable, ExpressibleAsObjcKeyPathExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeKeyPath: UnexpectedNodes?
  var keyPath: Token
  var unexpectedBetweenKeyPathAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndName: UnexpectedNodes?
  var name: ObjcName
  var unexpectedBetweenNameAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `ObjcKeyPathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeKeyPath: 
  ///   - keyPath: 
  ///   - unexpectedBetweenKeyPathAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeKeyPath: ExpressibleAsUnexpectedNodes? = nil, keyPath: Token = Token.`poundKeyPath`, unexpectedBetweenKeyPathAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsObjcName, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeKeyPath = unexpectedBeforeKeyPath?.createUnexpectedNodes()
    self.keyPath = keyPath
    assert(keyPath.text == #"#keyPath"#)
    self.unexpectedBetweenKeyPathAndLeftParen = unexpectedBetweenKeyPathAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndName = unexpectedBetweenLeftParenAndName?.createUnexpectedNodes()
    self.name = name.createObjcName()
    self.unexpectedBetweenNameAndRightParen = unexpectedBetweenNameAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `ObjcKeyPathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcKeyPathExprSyntax`.
  func buildObjcKeyPathExpr(format: Format) -> ObjcKeyPathExprSyntax {
    var result = ObjcKeyPathExprSyntax(unexpectedBeforeKeyPath?.buildUnexpectedNodes(format: format), keyPath: keyPath.buildToken(format: format), unexpectedBetweenKeyPathAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndName?.buildUnexpectedNodes(format: format), name: name.buildObjcName(format: format), unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildObjcKeyPathExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjcKeyPathExpr`.
  public func createObjcKeyPathExpr() -> ObjcKeyPathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjcKeyPathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ObjcSelectorExpr: ExprBuildable, ExpressibleAsObjcSelectorExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundSelector: UnexpectedNodes?
  var poundSelector: Token
  var unexpectedBetweenPoundSelectorAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndKind: UnexpectedNodes?
  var kind: Token?
  var unexpectedBetweenKindAndColon: UnexpectedNodes?
  var colon: Token?
  var unexpectedBetweenColonAndName: UnexpectedNodes?
  var name: ExprBuildable
  var unexpectedBetweenNameAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `ObjcSelectorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundSelector: 
  ///   - poundSelector: 
  ///   - unexpectedBetweenPoundSelectorAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndKind: 
  ///   - kind: 
  ///   - unexpectedBetweenKindAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundSelector: ExpressibleAsUnexpectedNodes? = nil, poundSelector: Token = Token.`poundSelector`, unexpectedBetweenPoundSelectorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndKind: ExpressibleAsUnexpectedNodes? = nil, kind: Token? = nil, unexpectedBetweenKindAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsExprBuildable, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundSelector = unexpectedBeforePoundSelector?.createUnexpectedNodes()
    self.poundSelector = poundSelector
    assert(poundSelector.text == #"#selector"#)
    self.unexpectedBetweenPoundSelectorAndLeftParen = unexpectedBetweenPoundSelectorAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndKind = unexpectedBetweenLeftParenAndKind?.createUnexpectedNodes()
    self.kind = kind
    assert(kind == nil || kind!.text == #"getter"# || kind!.text == #"setter"#)
    self.unexpectedBetweenKindAndColon = unexpectedBetweenKindAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndName = unexpectedBetweenColonAndName?.createUnexpectedNodes()
    self.name = name.createExprBuildable()
    self.unexpectedBetweenNameAndRightParen = unexpectedBetweenNameAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundSelector: ExpressibleAsUnexpectedNodes? = nil, poundSelector: Token = Token.`poundSelector`, unexpectedBetweenPoundSelectorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndKind: ExpressibleAsUnexpectedNodes? = nil, kind: String?, unexpectedBetweenKindAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsExprBuildable, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePoundSelector: unexpectedBeforePoundSelector, poundSelector: poundSelector, unexpectedBetweenPoundSelectorAndLeftParen: unexpectedBetweenPoundSelectorAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndKind: unexpectedBetweenLeftParenAndKind, kind: kind.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenKindAndColon: unexpectedBetweenKindAndColon, colon: colon, unexpectedBetweenColonAndName: unexpectedBetweenColonAndName, name: name, unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ObjcSelectorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcSelectorExprSyntax`.
  func buildObjcSelectorExpr(format: Format) -> ObjcSelectorExprSyntax {
    var result = ObjcSelectorExprSyntax(unexpectedBeforePoundSelector?.buildUnexpectedNodes(format: format), poundSelector: poundSelector.buildToken(format: format), unexpectedBetweenPoundSelectorAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndKind?.buildUnexpectedNodes(format: format), kind: kind?.buildToken(format: format), unexpectedBetweenKindAndColon?.buildUnexpectedNodes(format: format), colon: colon?.buildToken(format: format), unexpectedBetweenColonAndName?.buildUnexpectedNodes(format: format), name: name.buildExpr(format: format), unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildObjcSelectorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjcSelectorExpr`.
  public func createObjcSelectorExpr() -> ObjcSelectorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjcSelectorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PostfixIfConfigExpr: ExprBuildable, ExpressibleAsPostfixIfConfigExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBase: UnexpectedNodes?
  var base: ExprBuildable?
  var unexpectedBetweenBaseAndConfig: UnexpectedNodes?
  var config: IfConfigDecl
  /// Creates a `PostfixIfConfigExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBase: 
  ///   - base: 
  ///   - unexpectedBetweenBaseAndConfig: 
  ///   - config: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBase: ExpressibleAsUnexpectedNodes? = nil, base: ExpressibleAsExprBuildable? = nil, unexpectedBetweenBaseAndConfig: ExpressibleAsUnexpectedNodes? = nil, config: ExpressibleAsIfConfigDecl) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBase = unexpectedBeforeBase?.createUnexpectedNodes()
    self.base = base?.createExprBuildable()
    self.unexpectedBetweenBaseAndConfig = unexpectedBetweenBaseAndConfig?.createUnexpectedNodes()
    self.config = config.createIfConfigDecl()
  }
  /// Builds a `PostfixIfConfigExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PostfixIfConfigExprSyntax`.
  func buildPostfixIfConfigExpr(format: Format) -> PostfixIfConfigExprSyntax {
    var result = PostfixIfConfigExprSyntax(unexpectedBeforeBase?.buildUnexpectedNodes(format: format), base: base?.buildExpr(format: format), unexpectedBetweenBaseAndConfig?.buildUnexpectedNodes(format: format), config: config.buildIfConfigDecl(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPostfixIfConfigExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPostfixIfConfigExpr`.
  public func createPostfixIfConfigExpr() -> PostfixIfConfigExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PostfixIfConfigExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct EditorPlaceholderExpr: ExprBuildable, ExpressibleAsEditorPlaceholderExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIdentifier: UnexpectedNodes?
  var identifier: Token
  /// Creates a `EditorPlaceholderExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier))
  }
  /// Builds a `EditorPlaceholderExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EditorPlaceholderExprSyntax`.
  func buildEditorPlaceholderExpr(format: Format) -> EditorPlaceholderExprSyntax {
    var result = EditorPlaceholderExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildEditorPlaceholderExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsEditorPlaceholderExpr`.
  public func createEditorPlaceholderExpr() -> EditorPlaceholderExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `EditorPlaceholderExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ObjectLiteralExpr: ExprBuildable, ExpressibleAsObjectLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
  var arguments: TupleExprElementList
  var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `ObjectLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    assert(identifier.text == #"#colorLiteral"# || identifier.text == #"#fileLiteral"# || identifier.text == #"#imageLiteral"#)
    self.unexpectedBetweenIdentifierAndLeftParen = unexpectedBetweenIdentifierAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArguments = unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createTupleExprElementList()
    self.unexpectedBetweenArgumentsAndRightParen = unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TupleExprElementListBuilder argumentsBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: identifier, unexpectedBetweenIdentifierAndLeftParen: unexpectedBetweenIdentifierAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArguments: unexpectedBetweenLeftParenAndArguments, arguments: argumentsBuilder(), unexpectedBetweenArgumentsAndRightParen: unexpectedBetweenArgumentsAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ObjectLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjectLiteralExprSyntax`.
  func buildObjectLiteralExpr(format: Format) -> ObjectLiteralExprSyntax {
    var result = ObjectLiteralExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format), arguments: arguments.buildTupleExprElementList(format: format), unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildObjectLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjectLiteralExpr`.
  public func createObjectLiteralExpr() -> ObjectLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjectLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TypeInitializerClause: SyntaxBuildable, ExpressibleAsTypeInitializerClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeEqual: UnexpectedNodes?
  var equal: Token
  var unexpectedBetweenEqualAndValue: UnexpectedNodes?
  var value: TypeBuildable
  /// Creates a `TypeInitializerClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEqual: 
  ///   - equal: 
  ///   - unexpectedBetweenEqualAndValue: 
  ///   - value: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeEqual: ExpressibleAsUnexpectedNodes? = nil, equal: Token = Token.`equal`, unexpectedBetweenEqualAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeEqual = unexpectedBeforeEqual?.createUnexpectedNodes()
    self.equal = equal
    assert(equal.text == #"="#)
    self.unexpectedBetweenEqualAndValue = unexpectedBetweenEqualAndValue?.createUnexpectedNodes()
    self.value = value.createTypeBuildable()
  }
  /// Builds a `TypeInitializerClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeInitializerClauseSyntax`.
  func buildTypeInitializerClause(format: Format) -> TypeInitializerClauseSyntax {
    var result = TypeInitializerClauseSyntax(unexpectedBeforeEqual?.buildUnexpectedNodes(format: format), equal: equal.buildToken(format: format), unexpectedBetweenEqualAndValue?.buildUnexpectedNodes(format: format), value: value.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTypeInitializerClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeInitializerClause`.
  public func createTypeInitializerClause() -> TypeInitializerClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeInitializerClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TypealiasDecl: DeclBuildable, ExpressibleAsTypealiasDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndTypealiasKeyword: UnexpectedNodes?
  var typealiasKeyword: Token
  var unexpectedBetweenTypealiasKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  var genericParameterClause: GenericParameterClause?
  var unexpectedBetweenGenericParameterClauseAndInitializer: UnexpectedNodes?
  var initializer: TypeInitializerClause
  var unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  /// Creates a `TypealiasDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndTypealiasKeyword: 
  ///   - typealiasKeyword: 
  ///   - unexpectedBetweenTypealiasKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndGenericWhereClause: 
  ///   - genericWhereClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndTypealiasKeyword: ExpressibleAsUnexpectedNodes? = nil, typealiasKeyword: Token = Token.`typealias`, unexpectedBetweenTypealiasKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndTypealiasKeyword = unexpectedBetweenModifiersAndTypealiasKeyword?.createUnexpectedNodes()
    self.typealiasKeyword = typealiasKeyword
    assert(typealiasKeyword.text == #"typealias"#)
    self.unexpectedBetweenTypealiasKeywordAndIdentifier = unexpectedBetweenTypealiasKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInitializer = unexpectedBetweenGenericParameterClauseAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer.createTypeInitializerClause()
    self.unexpectedBetweenInitializerAndGenericWhereClause = unexpectedBetweenInitializerAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndTypealiasKeyword: ExpressibleAsUnexpectedNodes? = nil, typealiasKeyword: Token = Token.`typealias`, unexpectedBetweenTypealiasKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndTypealiasKeyword: unexpectedBetweenModifiersAndTypealiasKeyword, typealiasKeyword: typealiasKeyword, unexpectedBetweenTypealiasKeywordAndIdentifier: unexpectedBetweenTypealiasKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInitializer: unexpectedBetweenGenericParameterClauseAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause, genericWhereClause: genericWhereClause)
  }
  /// Builds a `TypealiasDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypealiasDeclSyntax`.
  func buildTypealiasDecl(format: Format) -> TypealiasDeclSyntax {
    var result = TypealiasDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndTypealiasKeyword?.buildUnexpectedNodes(format: format), typealiasKeyword: typealiasKeyword.buildToken(format: format), unexpectedBetweenTypealiasKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParameterClauseAndInitializer?.buildUnexpectedNodes(format: format), initializer: initializer.buildTypeInitializerClause(format: format), unexpectedBetweenInitializerAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildTypealiasDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsTypealiasDecl`.
  public func createTypealiasDecl() -> TypealiasDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `TypealiasDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AssociatedtypeDecl: DeclBuildable, ExpressibleAsAssociatedtypeDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndAssociatedtypeKeyword: UnexpectedNodes?
  var associatedtypeKeyword: Token
  var unexpectedBetweenAssociatedtypeKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndInheritanceClause: UnexpectedNodes?
  var inheritanceClause: TypeInheritanceClause?
  var unexpectedBetweenInheritanceClauseAndInitializer: UnexpectedNodes?
  var initializer: TypeInitializerClause?
  var unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  /// Creates a `AssociatedtypeDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndAssociatedtypeKeyword: 
  ///   - associatedtypeKeyword: 
  ///   - unexpectedBetweenAssociatedtypeKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndGenericWhereClause: 
  ///   - genericWhereClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndAssociatedtypeKeyword: ExpressibleAsUnexpectedNodes? = nil, associatedtypeKeyword: Token = Token.`associatedtype`, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause? = nil, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndAssociatedtypeKeyword = unexpectedBetweenModifiersAndAssociatedtypeKeyword?.createUnexpectedNodes()
    self.associatedtypeKeyword = associatedtypeKeyword
    assert(associatedtypeKeyword.text == #"associatedtype"#)
    self.unexpectedBetweenAssociatedtypeKeywordAndIdentifier = unexpectedBetweenAssociatedtypeKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndInheritanceClause = unexpectedBetweenIdentifierAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndInitializer = unexpectedBetweenInheritanceClauseAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createTypeInitializerClause()
    self.unexpectedBetweenInitializerAndGenericWhereClause = unexpectedBetweenInitializerAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndAssociatedtypeKeyword: ExpressibleAsUnexpectedNodes? = nil, associatedtypeKeyword: Token = Token.`associatedtype`, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause? = nil, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndAssociatedtypeKeyword: unexpectedBetweenModifiersAndAssociatedtypeKeyword, associatedtypeKeyword: associatedtypeKeyword, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: unexpectedBetweenAssociatedtypeKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndInheritanceClause: unexpectedBetweenIdentifierAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndInitializer: unexpectedBetweenInheritanceClauseAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause, genericWhereClause: genericWhereClause)
  }
  /// Builds a `AssociatedtypeDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AssociatedtypeDeclSyntax`.
  func buildAssociatedtypeDecl(format: Format) -> AssociatedtypeDeclSyntax {
    var result = AssociatedtypeDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndAssociatedtypeKeyword?.buildUnexpectedNodes(format: format), associatedtypeKeyword: associatedtypeKeyword.buildToken(format: format), unexpectedBetweenAssociatedtypeKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format), unexpectedBetweenInheritanceClauseAndInitializer?.buildUnexpectedNodes(format: format), initializer: initializer?.buildTypeInitializerClause(format: format), unexpectedBetweenInitializerAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildAssociatedtypeDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsAssociatedtypeDecl`.
  public func createAssociatedtypeDecl() -> AssociatedtypeDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `AssociatedtypeDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ParameterClause: SyntaxBuildable, ExpressibleAsParameterClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndParameterList: UnexpectedNodes?
  var parameterList: FunctionParameterList
  var unexpectedBetweenParameterListAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `ParameterClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndParameterList: 
  ///   - parameterList: 
  ///   - unexpectedBetweenParameterListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndParameterList: ExpressibleAsUnexpectedNodes? = nil, parameterList: ExpressibleAsFunctionParameterList, unexpectedBetweenParameterListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndParameterList = unexpectedBetweenLeftParenAndParameterList?.createUnexpectedNodes()
    self.parameterList = parameterList.createFunctionParameterList()
    self.unexpectedBetweenParameterListAndRightParen = unexpectedBetweenParameterListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndParameterList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenParameterListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @FunctionParameterListBuilder parameterListBuilder: () -> ExpressibleAsFunctionParameterList =  {
    FunctionParameterList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndParameterList: unexpectedBetweenLeftParenAndParameterList, parameterList: parameterListBuilder(), unexpectedBetweenParameterListAndRightParen: unexpectedBetweenParameterListAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ParameterClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ParameterClauseSyntax`.
  func buildParameterClause(format: Format) -> ParameterClauseSyntax {
    var result = ParameterClauseSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndParameterList?.buildUnexpectedNodes(format: format), parameterList: parameterList.buildFunctionParameterList(format: format), unexpectedBetweenParameterListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildParameterClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsParameterClause`.
  public func createParameterClause() -> ParameterClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ParameterClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ReturnClause: SyntaxBuildable, ExpressibleAsReturnClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeArrow: UnexpectedNodes?
  var arrow: Token
  var unexpectedBetweenArrowAndReturnType: UnexpectedNodes?
  var returnType: TypeBuildable
  /// Creates a `ReturnClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeArrow: 
  ///   - arrow: 
  ///   - unexpectedBetweenArrowAndReturnType: 
  ///   - returnType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeArrow: ExpressibleAsUnexpectedNodes? = nil, arrow: Token = Token.`arrow`, unexpectedBetweenArrowAndReturnType: ExpressibleAsUnexpectedNodes? = nil, returnType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeArrow = unexpectedBeforeArrow?.createUnexpectedNodes()
    self.arrow = arrow
    assert(arrow.text == #"->"#)
    self.unexpectedBetweenArrowAndReturnType = unexpectedBetweenArrowAndReturnType?.createUnexpectedNodes()
    self.returnType = returnType.createTypeBuildable()
  }
  /// Builds a `ReturnClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ReturnClauseSyntax`.
  func buildReturnClause(format: Format) -> ReturnClauseSyntax {
    var result = ReturnClauseSyntax(unexpectedBeforeArrow?.buildUnexpectedNodes(format: format), arrow: arrow.buildToken(format: format), unexpectedBetweenArrowAndReturnType?.buildUnexpectedNodes(format: format), returnType: returnType.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildReturnClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsReturnClause`.
  public func createReturnClause() -> ReturnClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ReturnClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct FunctionSignature: SyntaxBuildable, ExpressibleAsFunctionSignature {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeInput: UnexpectedNodes?
  var input: ParameterClause
  var unexpectedBetweenInputAndAsyncOrReasyncKeyword: UnexpectedNodes?
  var asyncOrReasyncKeyword: Token?
  var unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: UnexpectedNodes?
  var throwsOrRethrowsKeyword: Token?
  var unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: UnexpectedNodes?
  var output: ReturnClause?
  /// Creates a `FunctionSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeInput: 
  ///   - input: 
  ///   - unexpectedBetweenInputAndAsyncOrReasyncKeyword: 
  ///   - asyncOrReasyncKeyword: 
  ///   - unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: 
  ///   - throwsOrRethrowsKeyword: 
  ///   - unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: 
  ///   - output: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsParameterClause, unexpectedBetweenInputAndAsyncOrReasyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncOrReasyncKeyword: Token? = nil, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeInput = unexpectedBeforeInput?.createUnexpectedNodes()
    self.input = input.createParameterClause()
    self.unexpectedBetweenInputAndAsyncOrReasyncKeyword = unexpectedBetweenInputAndAsyncOrReasyncKeyword?.createUnexpectedNodes()
    self.asyncOrReasyncKeyword = asyncOrReasyncKeyword
    assert(asyncOrReasyncKeyword == nil || asyncOrReasyncKeyword!.text == #"async"# || asyncOrReasyncKeyword!.text == #"reasync"#)
    self.unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword = unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword?.createUnexpectedNodes()
    self.throwsOrRethrowsKeyword = throwsOrRethrowsKeyword
    assert(throwsOrRethrowsKeyword == nil || throwsOrRethrowsKeyword!.text == #"throws"# || throwsOrRethrowsKeyword!.text == #"rethrows"#)
    self.unexpectedBetweenThrowsOrRethrowsKeywordAndOutput = unexpectedBetweenThrowsOrRethrowsKeywordAndOutput?.createUnexpectedNodes()
    self.output = output?.createReturnClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsParameterClause, unexpectedBetweenInputAndAsyncOrReasyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncOrReasyncKeyword: String?, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeInput: unexpectedBeforeInput, input: input, unexpectedBetweenInputAndAsyncOrReasyncKeyword: unexpectedBetweenInputAndAsyncOrReasyncKeyword, asyncOrReasyncKeyword: asyncOrReasyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword, throwsOrRethrowsKeyword: throwsOrRethrowsKeyword, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: unexpectedBetweenThrowsOrRethrowsKeywordAndOutput, output: output)
  }
  /// Builds a `FunctionSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionSignatureSyntax`.
  func buildFunctionSignature(format: Format) -> FunctionSignatureSyntax {
    var result = FunctionSignatureSyntax(unexpectedBeforeInput?.buildUnexpectedNodes(format: format), input: input.buildParameterClause(format: format), unexpectedBetweenInputAndAsyncOrReasyncKeyword?.buildUnexpectedNodes(format: format), asyncOrReasyncKeyword: asyncOrReasyncKeyword?.buildToken(format: format), unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword?.buildUnexpectedNodes(format: format), throwsOrRethrowsKeyword: throwsOrRethrowsKeyword?.buildToken(format: format), unexpectedBetweenThrowsOrRethrowsKeywordAndOutput?.buildUnexpectedNodes(format: format), output: output?.buildReturnClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildFunctionSignature(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionSignature`.
  public func createFunctionSignature() -> FunctionSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IfConfigClause: SyntaxBuildable, ExpressibleAsIfConfigClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundKeyword: UnexpectedNodes?
  var poundKeyword: Token
  var unexpectedBetweenPoundKeywordAndCondition: UnexpectedNodes?
  var condition: ExprBuildable?
  var unexpectedBetweenConditionAndElements: UnexpectedNodes?
  var elements: SyntaxBuildable
  /// Creates a `IfConfigClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundKeyword: 
  ///   - poundKeyword: 
  ///   - unexpectedBetweenPoundKeywordAndCondition: 
  ///   - condition: 
  ///   - unexpectedBetweenConditionAndElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundKeyword: ExpressibleAsUnexpectedNodes? = nil, poundKeyword: Token, unexpectedBetweenPoundKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable? = nil, unexpectedBetweenConditionAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundKeyword = unexpectedBeforePoundKeyword?.createUnexpectedNodes()
    self.poundKeyword = poundKeyword
    assert(poundKeyword.text == #"#if"# || poundKeyword.text == #"#elseif"# || poundKeyword.text == #"#else"#)
    self.unexpectedBetweenPoundKeywordAndCondition = unexpectedBetweenPoundKeywordAndCondition?.createUnexpectedNodes()
    self.condition = condition?.createExprBuildable()
    self.unexpectedBetweenConditionAndElements = unexpectedBetweenConditionAndElements?.createUnexpectedNodes()
    self.elements = elements.createSyntaxBuildable()
  }
  /// Builds a `IfConfigClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfConfigClauseSyntax`.
  func buildIfConfigClause(format: Format) -> IfConfigClauseSyntax {
    var result = IfConfigClauseSyntax(unexpectedBeforePoundKeyword?.buildUnexpectedNodes(format: format), poundKeyword: poundKeyword.buildToken(format: format), unexpectedBetweenPoundKeywordAndCondition?.buildUnexpectedNodes(format: format), condition: condition?.buildExpr(format: format), unexpectedBetweenConditionAndElements?.buildUnexpectedNodes(format: format), elements: elements.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildIfConfigClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsIfConfigClause`.
  public func createIfConfigClause() -> IfConfigClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `IfConfigClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IfConfigDecl: DeclBuildable, ExpressibleAsIfConfigDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeClauses: UnexpectedNodes?
  var clauses: IfConfigClauseList
  var unexpectedBetweenClausesAndPoundEndif: UnexpectedNodes?
  var poundEndif: Token
  /// Creates a `IfConfigDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeClauses: 
  ///   - clauses: 
  ///   - unexpectedBetweenClausesAndPoundEndif: 
  ///   - poundEndif: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeClauses: ExpressibleAsUnexpectedNodes? = nil, clauses: ExpressibleAsIfConfigClauseList, unexpectedBetweenClausesAndPoundEndif: ExpressibleAsUnexpectedNodes? = nil, poundEndif: Token = Token.`poundEndif`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeClauses = unexpectedBeforeClauses?.createUnexpectedNodes()
    self.clauses = clauses.createIfConfigClauseList()
    self.unexpectedBetweenClausesAndPoundEndif = unexpectedBetweenClausesAndPoundEndif?.createUnexpectedNodes()
    self.poundEndif = poundEndif
    assert(poundEndif.text == #"#endif"#)
  }
  /// Builds a `IfConfigDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfConfigDeclSyntax`.
  func buildIfConfigDecl(format: Format) -> IfConfigDeclSyntax {
    var result = IfConfigDeclSyntax(unexpectedBeforeClauses?.buildUnexpectedNodes(format: format), clauses: clauses.buildIfConfigClauseList(format: format), unexpectedBetweenClausesAndPoundEndif?.buildUnexpectedNodes(format: format), poundEndif: poundEndif.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildIfConfigDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsIfConfigDecl`.
  public func createIfConfigDecl() -> IfConfigDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `IfConfigDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundErrorDecl: DeclBuildable, ExpressibleAsPoundErrorDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundError: UnexpectedNodes?
  var poundError: Token
  var unexpectedBetweenPoundErrorAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndMessage: UnexpectedNodes?
  var message: StringLiteralExpr
  var unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `PoundErrorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundError: 
  ///   - poundError: 
  ///   - unexpectedBetweenPoundErrorAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndMessage: 
  ///   - message: 
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundError: ExpressibleAsUnexpectedNodes? = nil, poundError: Token = Token.`poundError`, unexpectedBetweenPoundErrorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: ExpressibleAsStringLiteralExpr, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundError = unexpectedBeforePoundError?.createUnexpectedNodes()
    self.poundError = poundError
    assert(poundError.text == #"#error"#)
    self.unexpectedBetweenPoundErrorAndLeftParen = unexpectedBetweenPoundErrorAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndMessage = unexpectedBetweenLeftParenAndMessage?.createUnexpectedNodes()
    self.message = message.createStringLiteralExpr()
    self.unexpectedBetweenMessageAndRightParen = unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `PoundErrorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundErrorDeclSyntax`.
  func buildPoundErrorDecl(format: Format) -> PoundErrorDeclSyntax {
    var result = PoundErrorDeclSyntax(unexpectedBeforePoundError?.buildUnexpectedNodes(format: format), poundError: poundError.buildToken(format: format), unexpectedBetweenPoundErrorAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndMessage?.buildUnexpectedNodes(format: format), message: message.buildStringLiteralExpr(format: format), unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPoundErrorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundErrorDecl`.
  public func createPoundErrorDecl() -> PoundErrorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundErrorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundWarningDecl: DeclBuildable, ExpressibleAsPoundWarningDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundWarning: UnexpectedNodes?
  var poundWarning: Token
  var unexpectedBetweenPoundWarningAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndMessage: UnexpectedNodes?
  var message: StringLiteralExpr
  var unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `PoundWarningDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundWarning: 
  ///   - poundWarning: 
  ///   - unexpectedBetweenPoundWarningAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndMessage: 
  ///   - message: 
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundWarning: ExpressibleAsUnexpectedNodes? = nil, poundWarning: Token = Token.`poundWarning`, unexpectedBetweenPoundWarningAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: ExpressibleAsStringLiteralExpr, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundWarning = unexpectedBeforePoundWarning?.createUnexpectedNodes()
    self.poundWarning = poundWarning
    assert(poundWarning.text == #"#warning"#)
    self.unexpectedBetweenPoundWarningAndLeftParen = unexpectedBetweenPoundWarningAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndMessage = unexpectedBetweenLeftParenAndMessage?.createUnexpectedNodes()
    self.message = message.createStringLiteralExpr()
    self.unexpectedBetweenMessageAndRightParen = unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `PoundWarningDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundWarningDeclSyntax`.
  func buildPoundWarningDecl(format: Format) -> PoundWarningDeclSyntax {
    var result = PoundWarningDeclSyntax(unexpectedBeforePoundWarning?.buildUnexpectedNodes(format: format), poundWarning: poundWarning.buildToken(format: format), unexpectedBetweenPoundWarningAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndMessage?.buildUnexpectedNodes(format: format), message: message.buildStringLiteralExpr(format: format), unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPoundWarningDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundWarningDecl`.
  public func createPoundWarningDecl() -> PoundWarningDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundWarningDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundSourceLocation: DeclBuildable, ExpressibleAsPoundSourceLocation {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundSourceLocation: UnexpectedNodes?
  var poundSourceLocation: Token
  var unexpectedBetweenPoundSourceLocationAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndArgs: UnexpectedNodes?
  var args: PoundSourceLocationArgs?
  var unexpectedBetweenArgsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `PoundSourceLocation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundSourceLocation: 
  ///   - poundSourceLocation: 
  ///   - unexpectedBetweenPoundSourceLocationAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgs: 
  ///   - args: 
  ///   - unexpectedBetweenArgsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundSourceLocation: ExpressibleAsUnexpectedNodes? = nil, poundSourceLocation: Token = Token.`poundSourceLocation`, unexpectedBetweenPoundSourceLocationAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArgs: ExpressibleAsUnexpectedNodes? = nil, args: ExpressibleAsPoundSourceLocationArgs? = nil, unexpectedBetweenArgsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundSourceLocation = unexpectedBeforePoundSourceLocation?.createUnexpectedNodes()
    self.poundSourceLocation = poundSourceLocation
    assert(poundSourceLocation.text == #"#sourceLocation"#)
    self.unexpectedBetweenPoundSourceLocationAndLeftParen = unexpectedBetweenPoundSourceLocationAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgs = unexpectedBetweenLeftParenAndArgs?.createUnexpectedNodes()
    self.args = args?.createPoundSourceLocationArgs()
    self.unexpectedBetweenArgsAndRightParen = unexpectedBetweenArgsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `PoundSourceLocationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundSourceLocationSyntax`.
  func buildPoundSourceLocation(format: Format) -> PoundSourceLocationSyntax {
    var result = PoundSourceLocationSyntax(unexpectedBeforePoundSourceLocation?.buildUnexpectedNodes(format: format), poundSourceLocation: poundSourceLocation.buildToken(format: format), unexpectedBetweenPoundSourceLocationAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndArgs?.buildUnexpectedNodes(format: format), args: args?.buildPoundSourceLocationArgs(format: format), unexpectedBetweenArgsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPoundSourceLocation(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundSourceLocation`.
  public func createPoundSourceLocation() -> PoundSourceLocation {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundSourceLocation` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundSourceLocationArgs: SyntaxBuildable, ExpressibleAsPoundSourceLocationArgs {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeFileArgLabel: UnexpectedNodes?
  var fileArgLabel: Token
  var unexpectedBetweenFileArgLabelAndFileArgColon: UnexpectedNodes?
  var fileArgColon: Token
  var unexpectedBetweenFileArgColonAndFileName: UnexpectedNodes?
  var fileName: Token
  var unexpectedBetweenFileNameAndComma: UnexpectedNodes?
  var comma: Token
  var unexpectedBetweenCommaAndLineArgLabel: UnexpectedNodes?
  var lineArgLabel: Token
  var unexpectedBetweenLineArgLabelAndLineArgColon: UnexpectedNodes?
  var lineArgColon: Token
  var unexpectedBetweenLineArgColonAndLineNumber: UnexpectedNodes?
  var lineNumber: Token
  /// Creates a `PoundSourceLocationArgs` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFileArgLabel: 
  ///   - fileArgLabel: 
  ///   - unexpectedBetweenFileArgLabelAndFileArgColon: 
  ///   - fileArgColon: 
  ///   - unexpectedBetweenFileArgColonAndFileName: 
  ///   - fileName: 
  ///   - unexpectedBetweenFileNameAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndLineArgLabel: 
  ///   - lineArgLabel: 
  ///   - unexpectedBetweenLineArgLabelAndLineArgColon: 
  ///   - lineArgColon: 
  ///   - unexpectedBetweenLineArgColonAndLineNumber: 
  ///   - lineNumber: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeFileArgLabel: ExpressibleAsUnexpectedNodes? = nil, fileArgLabel: Token, unexpectedBetweenFileArgLabelAndFileArgColon: ExpressibleAsUnexpectedNodes? = nil, fileArgColon: Token = Token.`colon`, unexpectedBetweenFileArgColonAndFileName: ExpressibleAsUnexpectedNodes? = nil, fileName: Token, unexpectedBetweenFileNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndLineArgLabel: ExpressibleAsUnexpectedNodes? = nil, lineArgLabel: Token, unexpectedBetweenLineArgLabelAndLineArgColon: ExpressibleAsUnexpectedNodes? = nil, lineArgColon: Token = Token.`colon`, unexpectedBetweenLineArgColonAndLineNumber: ExpressibleAsUnexpectedNodes? = nil, lineNumber: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeFileArgLabel = unexpectedBeforeFileArgLabel?.createUnexpectedNodes()
    self.fileArgLabel = fileArgLabel
    assert(fileArgLabel.text == #"file"#)
    self.unexpectedBetweenFileArgLabelAndFileArgColon = unexpectedBetweenFileArgLabelAndFileArgColon?.createUnexpectedNodes()
    self.fileArgColon = fileArgColon
    assert(fileArgColon.text == #":"#)
    self.unexpectedBetweenFileArgColonAndFileName = unexpectedBetweenFileArgColonAndFileName?.createUnexpectedNodes()
    self.fileName = fileName
    self.unexpectedBetweenFileNameAndComma = unexpectedBetweenFileNameAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma.text == #","#)
    self.unexpectedBetweenCommaAndLineArgLabel = unexpectedBetweenCommaAndLineArgLabel?.createUnexpectedNodes()
    self.lineArgLabel = lineArgLabel
    assert(lineArgLabel.text == #"line"#)
    self.unexpectedBetweenLineArgLabelAndLineArgColon = unexpectedBetweenLineArgLabelAndLineArgColon?.createUnexpectedNodes()
    self.lineArgColon = lineArgColon
    assert(lineArgColon.text == #":"#)
    self.unexpectedBetweenLineArgColonAndLineNumber = unexpectedBetweenLineArgColonAndLineNumber?.createUnexpectedNodes()
    self.lineNumber = lineNumber
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFileArgLabel: ExpressibleAsUnexpectedNodes? = nil, fileArgLabel: String, unexpectedBetweenFileArgLabelAndFileArgColon: ExpressibleAsUnexpectedNodes? = nil, fileArgColon: Token = Token.`colon`, unexpectedBetweenFileArgColonAndFileName: ExpressibleAsUnexpectedNodes? = nil, fileName: String, unexpectedBetweenFileNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndLineArgLabel: ExpressibleAsUnexpectedNodes? = nil, lineArgLabel: String, unexpectedBetweenLineArgLabelAndLineArgColon: ExpressibleAsUnexpectedNodes? = nil, lineArgColon: Token = Token.`colon`, unexpectedBetweenLineArgColonAndLineNumber: ExpressibleAsUnexpectedNodes? = nil, lineNumber: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeFileArgLabel: unexpectedBeforeFileArgLabel, fileArgLabel: Token.`identifier`(fileArgLabel), unexpectedBetweenFileArgLabelAndFileArgColon: unexpectedBetweenFileArgLabelAndFileArgColon, fileArgColon: fileArgColon, unexpectedBetweenFileArgColonAndFileName: unexpectedBetweenFileArgColonAndFileName, fileName: Token.`stringLiteral`(fileName), unexpectedBetweenFileNameAndComma: unexpectedBetweenFileNameAndComma, comma: comma, unexpectedBetweenCommaAndLineArgLabel: unexpectedBetweenCommaAndLineArgLabel, lineArgLabel: Token.`identifier`(lineArgLabel), unexpectedBetweenLineArgLabelAndLineArgColon: unexpectedBetweenLineArgLabelAndLineArgColon, lineArgColon: lineArgColon, unexpectedBetweenLineArgColonAndLineNumber: unexpectedBetweenLineArgColonAndLineNumber, lineNumber: Token.`integerLiteral`(lineNumber))
  }
  /// Builds a `PoundSourceLocationArgsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundSourceLocationArgsSyntax`.
  func buildPoundSourceLocationArgs(format: Format) -> PoundSourceLocationArgsSyntax {
    var result = PoundSourceLocationArgsSyntax(unexpectedBeforeFileArgLabel?.buildUnexpectedNodes(format: format), fileArgLabel: fileArgLabel.buildToken(format: format), unexpectedBetweenFileArgLabelAndFileArgColon?.buildUnexpectedNodes(format: format), fileArgColon: fileArgColon.buildToken(format: format), unexpectedBetweenFileArgColonAndFileName?.buildUnexpectedNodes(format: format), fileName: fileName.buildToken(format: format), unexpectedBetweenFileNameAndComma?.buildUnexpectedNodes(format: format), comma: comma.buildToken(format: format), unexpectedBetweenCommaAndLineArgLabel?.buildUnexpectedNodes(format: format), lineArgLabel: lineArgLabel.buildToken(format: format), unexpectedBetweenLineArgLabelAndLineArgColon?.buildUnexpectedNodes(format: format), lineArgColon: lineArgColon.buildToken(format: format), unexpectedBetweenLineArgColonAndLineNumber?.buildUnexpectedNodes(format: format), lineNumber: lineNumber.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPoundSourceLocationArgs(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPoundSourceLocationArgs`.
  public func createPoundSourceLocationArgs() -> PoundSourceLocationArgs {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PoundSourceLocationArgs` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeclModifierDetail: SyntaxBuildable, ExpressibleAsDeclModifierDetail {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndDetail: UnexpectedNodes?
  var detail: Token
  var unexpectedBetweenDetailAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `DeclModifierDetail` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndDetail: 
  ///   - detail: 
  ///   - unexpectedBetweenDetailAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: Token, unexpectedBetweenDetailAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndDetail = unexpectedBetweenLeftParenAndDetail?.createUnexpectedNodes()
    self.detail = detail
    self.unexpectedBetweenDetailAndRightParen = unexpectedBetweenDetailAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: String, unexpectedBetweenDetailAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndDetail: unexpectedBetweenLeftParenAndDetail, detail: Token.`identifier`(detail), unexpectedBetweenDetailAndRightParen: unexpectedBetweenDetailAndRightParen, rightParen: rightParen)
  }
  /// Builds a `DeclModifierDetailSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclModifierDetailSyntax`.
  func buildDeclModifierDetail(format: Format) -> DeclModifierDetailSyntax {
    var result = DeclModifierDetailSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndDetail?.buildUnexpectedNodes(format: format), detail: detail.buildToken(format: format), unexpectedBetweenDetailAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclModifierDetail(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclModifierDetail`.
  public func createDeclModifierDetail() -> DeclModifierDetail {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclModifierDetail` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeclModifier: SyntaxBuildable, ExpressibleAsDeclModifier {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndDetail: UnexpectedNodes?
  var detail: DeclModifierDetail?
  /// Creates a `DeclModifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDetail: 
  ///   - detail: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: ExpressibleAsDeclModifierDetail? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    assert(name.text == #"class"# || name.text == #"convenience"# || name.text == #"dynamic"# || name.text == #"final"# || name.text == #"infix"# || name.text == #"lazy"# || name.text == #"optional"# || name.text == #"override"# || name.text == #"postfix"# || name.text == #"prefix"# || name.text == #"required"# || name.text == #"static"# || name.text == #"unowned"# || name.text == #"weak"# || name.text == #"private"# || name.text == #"fileprivate"# || name.text == #"internal"# || name.text == #"public"# || name.text == #"open"# || name.text == #"mutating"# || name.text == #"nonmutating"# || name.text == #"indirect"# || name.text == #"__consuming"# || name.text == #"actor"# || name.text == #"async"# || name.text == #"distributed"# || name.text == #"isolated"# || name.text == #"nonisolated"# || name.text == #"_const"# || name.text == #"_local"#)
    self.unexpectedBetweenNameAndDetail = unexpectedBetweenNameAndDetail?.createUnexpectedNodes()
    self.detail = detail?.createDeclModifierDetail()
  }
  /// Builds a `DeclModifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclModifierSyntax`.
  func buildDeclModifier(format: Format) -> DeclModifierSyntax {
    var result = DeclModifierSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndDetail?.buildUnexpectedNodes(format: format), detail: detail?.buildDeclModifierDetail(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclModifier(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclModifier`.
  public func createDeclModifier() -> DeclModifier {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclModifier` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct InheritedType: SyntaxBuildable, ExpressibleAsInheritedType, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeTypeName: UnexpectedNodes?
  var typeName: TypeBuildable
  var unexpectedBetweenTypeNameAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `InheritedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTypeName: 
  ///   - typeName: 
  ///   - unexpectedBetweenTypeNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable, unexpectedBetweenTypeNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeTypeName = unexpectedBeforeTypeName?.createUnexpectedNodes()
    self.typeName = typeName.createTypeBuildable()
    self.unexpectedBetweenTypeNameAndTrailingComma = unexpectedBetweenTypeNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `InheritedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InheritedTypeSyntax`.
  func buildInheritedType(format: Format) -> InheritedTypeSyntax {
    var result = InheritedTypeSyntax(unexpectedBeforeTypeName?.buildUnexpectedNodes(format: format), typeName: typeName.buildType(format: format), unexpectedBetweenTypeNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildInheritedType(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsInheritedType`.
  public func createInheritedType() -> InheritedType {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `InheritedType` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TypeInheritanceClause: SyntaxBuildable, ExpressibleAsTypeInheritanceClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndInheritedTypeCollection: UnexpectedNodes?
  var inheritedTypeCollection: InheritedTypeList
  /// Creates a `TypeInheritanceClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndInheritedTypeCollection: 
  ///   - inheritedTypeCollection: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndInheritedTypeCollection: ExpressibleAsUnexpectedNodes? = nil, inheritedTypeCollection: ExpressibleAsInheritedTypeList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeColon = unexpectedBeforeColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndInheritedTypeCollection = unexpectedBetweenColonAndInheritedTypeCollection?.createUnexpectedNodes()
    self.inheritedTypeCollection = inheritedTypeCollection.createInheritedTypeList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndInheritedTypeCollection: ExpressibleAsUnexpectedNodes? = nil, @InheritedTypeListBuilder inheritedTypeCollectionBuilder: () -> ExpressibleAsInheritedTypeList =  {
    InheritedTypeList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeColon: unexpectedBeforeColon, colon: colon, unexpectedBetweenColonAndInheritedTypeCollection: unexpectedBetweenColonAndInheritedTypeCollection, inheritedTypeCollection: inheritedTypeCollectionBuilder())
  }
  /// Builds a `TypeInheritanceClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeInheritanceClauseSyntax`.
  func buildTypeInheritanceClause(format: Format) -> TypeInheritanceClauseSyntax {
    var result = TypeInheritanceClauseSyntax(unexpectedBeforeColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndInheritedTypeCollection?.buildUnexpectedNodes(format: format), inheritedTypeCollection: inheritedTypeCollection.buildInheritedTypeList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTypeInheritanceClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeInheritanceClause`.
  public func createTypeInheritanceClause() -> TypeInheritanceClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeInheritanceClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ClassDecl: DeclBuildable, ExpressibleAsClassDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndClassKeyword: UnexpectedNodes?
  var classKeyword: Token
  var unexpectedBetweenClassKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  var genericParameterClause: GenericParameterClause?
  var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
  var inheritanceClause: TypeInheritanceClause?
  var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  var members: MemberDeclBlock
  /// Creates a `ClassDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndClassKeyword: 
  ///   - classKeyword: 
  ///   - unexpectedBetweenClassKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`, unexpectedBetweenClassKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndClassKeyword = unexpectedBetweenModifiersAndClassKeyword?.createUnexpectedNodes()
    self.classKeyword = classKeyword
    assert(classKeyword.text == #"class"#)
    self.unexpectedBetweenClassKeywordAndIdentifier = unexpectedBetweenClassKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInheritanceClause = unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`, unexpectedBetweenClassKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndClassKeyword: unexpectedBetweenModifiersAndClassKeyword, classKeyword: classKeyword, unexpectedBetweenClassKeywordAndIdentifier: unexpectedBetweenClassKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ClassDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClassDeclSyntax`.
  func buildClassDecl(format: Format) -> ClassDeclSyntax {
    var result = ClassDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndClassKeyword?.buildUnexpectedNodes(format: format), classKeyword: classKeyword.buildToken(format: format), unexpectedBetweenClassKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: members.buildMemberDeclBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildClassDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsClassDecl`.
  public func createClassDecl() -> ClassDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ClassDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ActorDecl: DeclBuildable, ExpressibleAsActorDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndActorKeyword: UnexpectedNodes?
  var actorKeyword: Token
  var unexpectedBetweenActorKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  var genericParameterClause: GenericParameterClause?
  var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
  var inheritanceClause: TypeInheritanceClause?
  var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  var members: MemberDeclBlock
  /// Creates a `ActorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndActorKeyword: 
  ///   - actorKeyword: 
  ///   - unexpectedBetweenActorKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndActorKeyword: ExpressibleAsUnexpectedNodes? = nil, actorKeyword: Token, unexpectedBetweenActorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndActorKeyword = unexpectedBetweenModifiersAndActorKeyword?.createUnexpectedNodes()
    self.actorKeyword = actorKeyword
    assert(actorKeyword.text == #"actor"#)
    self.unexpectedBetweenActorKeywordAndIdentifier = unexpectedBetweenActorKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInheritanceClause = unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndActorKeyword: ExpressibleAsUnexpectedNodes? = nil, actorKeyword: String, unexpectedBetweenActorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndActorKeyword: unexpectedBetweenModifiersAndActorKeyword, actorKeyword: Token.`contextualKeyword`(actorKeyword), unexpectedBetweenActorKeywordAndIdentifier: unexpectedBetweenActorKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ActorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ActorDeclSyntax`.
  func buildActorDecl(format: Format) -> ActorDeclSyntax {
    var result = ActorDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndActorKeyword?.buildUnexpectedNodes(format: format), actorKeyword: actorKeyword.buildToken(format: format), unexpectedBetweenActorKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: members.buildMemberDeclBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildActorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsActorDecl`.
  public func createActorDecl() -> ActorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ActorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct StructDecl: DeclBuildable, ExpressibleAsStructDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndStructKeyword: UnexpectedNodes?
  var structKeyword: Token
  var unexpectedBetweenStructKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  var genericParameterClause: GenericParameterClause?
  var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
  var inheritanceClause: TypeInheritanceClause?
  var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  var members: MemberDeclBlock
  /// Creates a `StructDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndStructKeyword: 
  ///   - structKeyword: 
  ///   - unexpectedBetweenStructKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndStructKeyword: ExpressibleAsUnexpectedNodes? = nil, structKeyword: Token = Token.`struct`, unexpectedBetweenStructKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndStructKeyword = unexpectedBetweenModifiersAndStructKeyword?.createUnexpectedNodes()
    self.structKeyword = structKeyword
    assert(structKeyword.text == #"struct"#)
    self.unexpectedBetweenStructKeywordAndIdentifier = unexpectedBetweenStructKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInheritanceClause = unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndStructKeyword: ExpressibleAsUnexpectedNodes? = nil, structKeyword: Token = Token.`struct`, unexpectedBetweenStructKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndStructKeyword: unexpectedBetweenModifiersAndStructKeyword, structKeyword: structKeyword, unexpectedBetweenStructKeywordAndIdentifier: unexpectedBetweenStructKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `StructDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StructDeclSyntax`.
  func buildStructDecl(format: Format) -> StructDeclSyntax {
    var result = StructDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndStructKeyword?.buildUnexpectedNodes(format: format), structKeyword: structKeyword.buildToken(format: format), unexpectedBetweenStructKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: members.buildMemberDeclBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildStructDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsStructDecl`.
  public func createStructDecl() -> StructDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `StructDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ProtocolDecl: DeclBuildable, ExpressibleAsProtocolDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndProtocolKeyword: UnexpectedNodes?
  var protocolKeyword: Token
  var unexpectedBetweenProtocolKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: UnexpectedNodes?
  var primaryAssociatedTypeClause: PrimaryAssociatedTypeClause?
  var unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: UnexpectedNodes?
  var inheritanceClause: TypeInheritanceClause?
  var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  var members: MemberDeclBlock
  /// Creates a `ProtocolDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndProtocolKeyword: 
  ///   - protocolKeyword: 
  ///   - unexpectedBetweenProtocolKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: 
  ///   - primaryAssociatedTypeClause: 
  ///   - unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndProtocolKeyword: ExpressibleAsUnexpectedNodes? = nil, protocolKeyword: Token = Token.`protocol`, unexpectedBetweenProtocolKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeClause: ExpressibleAsPrimaryAssociatedTypeClause? = nil, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndProtocolKeyword = unexpectedBetweenModifiersAndProtocolKeyword?.createUnexpectedNodes()
    self.protocolKeyword = protocolKeyword
    assert(protocolKeyword.text == #"protocol"#)
    self.unexpectedBetweenProtocolKeywordAndIdentifier = unexpectedBetweenProtocolKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause = unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause?.createUnexpectedNodes()
    self.primaryAssociatedTypeClause = primaryAssociatedTypeClause?.createPrimaryAssociatedTypeClause()
    self.unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause = unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndProtocolKeyword: ExpressibleAsUnexpectedNodes? = nil, protocolKeyword: Token = Token.`protocol`, unexpectedBetweenProtocolKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeClause: ExpressibleAsPrimaryAssociatedTypeClause? = nil, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndProtocolKeyword: unexpectedBetweenModifiersAndProtocolKeyword, protocolKeyword: protocolKeyword, unexpectedBetweenProtocolKeywordAndIdentifier: unexpectedBetweenProtocolKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause, primaryAssociatedTypeClause: primaryAssociatedTypeClause, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ProtocolDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ProtocolDeclSyntax`.
  func buildProtocolDecl(format: Format) -> ProtocolDeclSyntax {
    var result = ProtocolDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndProtocolKeyword?.buildUnexpectedNodes(format: format), protocolKeyword: protocolKeyword.buildToken(format: format), unexpectedBetweenProtocolKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause?.buildUnexpectedNodes(format: format), primaryAssociatedTypeClause: primaryAssociatedTypeClause?.buildPrimaryAssociatedTypeClause(format: format), unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: members.buildMemberDeclBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildProtocolDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsProtocolDecl`.
  public func createProtocolDecl() -> ProtocolDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ProtocolDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ExtensionDecl: DeclBuildable, ExpressibleAsExtensionDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndExtensionKeyword: UnexpectedNodes?
  var extensionKeyword: Token
  var unexpectedBetweenExtensionKeywordAndExtendedType: UnexpectedNodes?
  var extendedType: TypeBuildable
  var unexpectedBetweenExtendedTypeAndInheritanceClause: UnexpectedNodes?
  var inheritanceClause: TypeInheritanceClause?
  var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  var members: MemberDeclBlock
  /// Creates a `ExtensionDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndExtensionKeyword: 
  ///   - extensionKeyword: 
  ///   - unexpectedBetweenExtensionKeywordAndExtendedType: 
  ///   - extendedType: 
  ///   - unexpectedBetweenExtendedTypeAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndExtensionKeyword: ExpressibleAsUnexpectedNodes? = nil, extensionKeyword: Token = Token.`extension`, unexpectedBetweenExtensionKeywordAndExtendedType: ExpressibleAsUnexpectedNodes? = nil, extendedType: ExpressibleAsTypeBuildable, unexpectedBetweenExtendedTypeAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndExtensionKeyword = unexpectedBetweenModifiersAndExtensionKeyword?.createUnexpectedNodes()
    self.extensionKeyword = extensionKeyword
    assert(extensionKeyword.text == #"extension"#)
    self.unexpectedBetweenExtensionKeywordAndExtendedType = unexpectedBetweenExtensionKeywordAndExtendedType?.createUnexpectedNodes()
    self.extendedType = extendedType.createTypeBuildable()
    self.unexpectedBetweenExtendedTypeAndInheritanceClause = unexpectedBetweenExtendedTypeAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndExtensionKeyword: ExpressibleAsUnexpectedNodes? = nil, extensionKeyword: Token = Token.`extension`, unexpectedBetweenExtensionKeywordAndExtendedType: ExpressibleAsUnexpectedNodes? = nil, extendedType: ExpressibleAsTypeBuildable, unexpectedBetweenExtendedTypeAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndExtensionKeyword: unexpectedBetweenModifiersAndExtensionKeyword, extensionKeyword: extensionKeyword, unexpectedBetweenExtensionKeywordAndExtendedType: unexpectedBetweenExtensionKeywordAndExtendedType, extendedType: extendedType, unexpectedBetweenExtendedTypeAndInheritanceClause: unexpectedBetweenExtendedTypeAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ExtensionDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExtensionDeclSyntax`.
  func buildExtensionDecl(format: Format) -> ExtensionDeclSyntax {
    var result = ExtensionDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndExtensionKeyword?.buildUnexpectedNodes(format: format), extensionKeyword: extensionKeyword.buildToken(format: format), unexpectedBetweenExtensionKeywordAndExtendedType?.buildUnexpectedNodes(format: format), extendedType: extendedType.buildType(format: format), unexpectedBetweenExtendedTypeAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: members.buildMemberDeclBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildExtensionDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsExtensionDecl`.
  public func createExtensionDecl() -> ExtensionDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ExtensionDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct MemberDeclBlock: SyntaxBuildable, ExpressibleAsMemberDeclBlock {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftBrace: UnexpectedNodes?
  var leftBrace: Token
  var unexpectedBetweenLeftBraceAndMembers: UnexpectedNodes?
  var members: MemberDeclList
  var unexpectedBetweenMembersAndRightBrace: UnexpectedNodes?
  var rightBrace: Token
  /// Creates a `MemberDeclBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndMembers: 
  ///   - members: 
  ///   - unexpectedBetweenMembersAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclList, unexpectedBetweenMembersAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndMembers = unexpectedBetweenLeftBraceAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclList()
    self.unexpectedBetweenMembersAndRightBrace = unexpectedBetweenMembersAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndMembers: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenMembersAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndMembers: unexpectedBetweenLeftBraceAndMembers, members: membersBuilder(), unexpectedBetweenMembersAndRightBrace: unexpectedBetweenMembersAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `MemberDeclBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberDeclBlockSyntax`.
  func buildMemberDeclBlock(format: Format) -> MemberDeclBlockSyntax {
    var result = MemberDeclBlockSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: leftBrace.buildToken(format: format), unexpectedBetweenLeftBraceAndMembers?.buildUnexpectedNodes(format: format), members: members.buildMemberDeclList(format: format._indented), unexpectedBetweenMembersAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: rightBrace.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMemberDeclBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMemberDeclBlock`.
  public func createMemberDeclBlock() -> MemberDeclBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MemberDeclBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A member declaration of a type consisting of a declaration and anoptional semicolon;
public struct MemberDeclListItem: SyntaxBuildable, ExpressibleAsMemberDeclListItem {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDecl: UnexpectedNodes?
  var decl: DeclBuildable
  var unexpectedBetweenDeclAndSemicolon: UnexpectedNodes?
  var semicolon: Token?
  /// Creates a `MemberDeclListItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDecl: 
  ///   - decl: The declaration of the type member.
  ///   - unexpectedBetweenDeclAndSemicolon: 
  ///   - semicolon: An optional trailing semicolon.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDecl: ExpressibleAsUnexpectedNodes? = nil, decl: ExpressibleAsDeclBuildable, unexpectedBetweenDeclAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDecl = unexpectedBeforeDecl?.createUnexpectedNodes()
    self.decl = decl.createDeclBuildable()
    self.unexpectedBetweenDeclAndSemicolon = unexpectedBetweenDeclAndSemicolon?.createUnexpectedNodes()
    self.semicolon = semicolon
    assert(semicolon == nil || semicolon!.text == #";"#)
  }
  /// Builds a `MemberDeclListItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberDeclListItemSyntax`.
  func buildMemberDeclListItem(format: Format) -> MemberDeclListItemSyntax {
    var result = MemberDeclListItemSyntax(unexpectedBeforeDecl?.buildUnexpectedNodes(format: format), decl: decl.buildDecl(format: format), unexpectedBetweenDeclAndSemicolon?.buildUnexpectedNodes(format: format), semicolon: semicolon?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMemberDeclListItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMemberDeclListItem`.
  public func createMemberDeclListItem() -> MemberDeclListItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MemberDeclListItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SourceFile: SyntaxBuildable, ExpressibleAsSourceFile {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeStatements: UnexpectedNodes?
  var statements: CodeBlockItemList
  var unexpectedBetweenStatementsAndEOFToken: UnexpectedNodes?
  var eofToken: Token
  /// Creates a `SourceFile` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndEOFToken: 
  ///   - eofToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndEOFToken: ExpressibleAsUnexpectedNodes? = nil, eofToken: Token = Token.eof) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeStatements = unexpectedBeforeStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
    self.unexpectedBetweenStatementsAndEOFToken = unexpectedBetweenStatementsAndEOFToken?.createUnexpectedNodes()
    self.eofToken = eofToken
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndEOFToken: ExpressibleAsUnexpectedNodes? = nil, eofToken: Token = Token.eof, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeStatements: unexpectedBeforeStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndEOFToken: unexpectedBetweenStatementsAndEOFToken, eofToken: eofToken)
  }
  /// Builds a `SourceFileSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SourceFileSyntax`.
  func buildSourceFile(format: Format) -> SourceFileSyntax {
    var result = SourceFileSyntax(unexpectedBeforeStatements?.buildUnexpectedNodes(format: format), statements: statements.buildCodeBlockItemList(format: format), unexpectedBetweenStatementsAndEOFToken?.buildUnexpectedNodes(format: format), eofToken: eofToken.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSourceFile(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSourceFile`.
  public func createSourceFile() -> SourceFile {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SourceFile` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct InitializerClause: SyntaxBuildable, ExpressibleAsInitializerClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeEqual: UnexpectedNodes?
  var equal: Token
  var unexpectedBetweenEqualAndValue: UnexpectedNodes?
  var value: ExprBuildable
  /// Creates a `InitializerClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEqual: 
  ///   - equal: 
  ///   - unexpectedBetweenEqualAndValue: 
  ///   - value: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeEqual: ExpressibleAsUnexpectedNodes? = nil, equal: Token = Token.`equal`, unexpectedBetweenEqualAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeEqual = unexpectedBeforeEqual?.createUnexpectedNodes()
    self.equal = equal
    assert(equal.text == #"="#)
    self.unexpectedBetweenEqualAndValue = unexpectedBetweenEqualAndValue?.createUnexpectedNodes()
    self.value = value.createExprBuildable()
  }
  /// Builds a `InitializerClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InitializerClauseSyntax`.
  func buildInitializerClause(format: Format) -> InitializerClauseSyntax {
    var result = InitializerClauseSyntax(unexpectedBeforeEqual?.buildUnexpectedNodes(format: format), equal: equal.buildToken(format: format), unexpectedBetweenEqualAndValue?.buildUnexpectedNodes(format: format), value: value.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildInitializerClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsInitializerClause`.
  public func createInitializerClause() -> InitializerClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `InitializerClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct FunctionParameter: SyntaxBuildable, ExpressibleAsFunctionParameter, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndIsolated: UnexpectedNodes?
  var isolated: Token?
  var unexpectedBetweenIsolatedAndConst: UnexpectedNodes?
  var const: Token?
  var unexpectedBetweenConstAndFirstName: UnexpectedNodes?
  var firstName: Token?
  var unexpectedBetweenFirstNameAndSecondName: UnexpectedNodes?
  var secondName: Token?
  var unexpectedBetweenSecondNameAndColon: UnexpectedNodes?
  var colon: Token?
  var unexpectedBetweenColonAndType: UnexpectedNodes?
  var type: TypeBuildable?
  var unexpectedBetweenTypeAndEllipsis: UnexpectedNodes?
  var ellipsis: Token?
  var unexpectedBetweenEllipsisAndDefaultArgument: UnexpectedNodes?
  var defaultArgument: InitializerClause?
  var unexpectedBetweenDefaultArgumentAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `FunctionParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndIsolated: 
  ///   - isolated: 
  ///   - unexpectedBetweenIsolatedAndConst: 
  ///   - const: 
  ///   - unexpectedBetweenConstAndFirstName: 
  ///   - firstName: 
  ///   - unexpectedBetweenFirstNameAndSecondName: 
  ///   - secondName: 
  ///   - unexpectedBetweenSecondNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndEllipsis: 
  ///   - ellipsis: 
  ///   - unexpectedBetweenEllipsisAndDefaultArgument: 
  ///   - defaultArgument: 
  ///   - unexpectedBetweenDefaultArgumentAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndIsolated: ExpressibleAsUnexpectedNodes? = nil, isolated: Token? = nil, unexpectedBetweenIsolatedAndConst: ExpressibleAsUnexpectedNodes? = nil, const: Token? = nil, unexpectedBetweenConstAndFirstName: ExpressibleAsUnexpectedNodes? = nil, firstName: Token? = nil, unexpectedBetweenFirstNameAndSecondName: ExpressibleAsUnexpectedNodes? = nil, secondName: Token? = nil, unexpectedBetweenSecondNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token? = nil, unexpectedBetweenEllipsisAndDefaultArgument: ExpressibleAsUnexpectedNodes? = nil, defaultArgument: ExpressibleAsInitializerClause? = nil, unexpectedBetweenDefaultArgumentAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndIsolated = unexpectedBetweenAttributesAndIsolated?.createUnexpectedNodes()
    self.isolated = isolated
    self.unexpectedBetweenIsolatedAndConst = unexpectedBetweenIsolatedAndConst?.createUnexpectedNodes()
    self.const = const
    self.unexpectedBetweenConstAndFirstName = unexpectedBetweenConstAndFirstName?.createUnexpectedNodes()
    self.firstName = firstName
    self.unexpectedBetweenFirstNameAndSecondName = unexpectedBetweenFirstNameAndSecondName?.createUnexpectedNodes()
    self.secondName = secondName
    self.unexpectedBetweenSecondNameAndColon = unexpectedBetweenSecondNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndType = unexpectedBetweenColonAndType?.createUnexpectedNodes()
    self.type = type?.createTypeBuildable()
    self.unexpectedBetweenTypeAndEllipsis = unexpectedBetweenTypeAndEllipsis?.createUnexpectedNodes()
    self.ellipsis = ellipsis
    assert(ellipsis == nil || ellipsis!.text == #"..."#)
    self.unexpectedBetweenEllipsisAndDefaultArgument = unexpectedBetweenEllipsisAndDefaultArgument?.createUnexpectedNodes()
    self.defaultArgument = defaultArgument?.createInitializerClause()
    self.unexpectedBetweenDefaultArgumentAndTrailingComma = unexpectedBetweenDefaultArgumentAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `FunctionParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionParameterSyntax`.
  func buildFunctionParameter(format: Format) -> FunctionParameterSyntax {
    var result = FunctionParameterSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndIsolated?.buildUnexpectedNodes(format: format), isolated: isolated?.buildToken(format: format), unexpectedBetweenIsolatedAndConst?.buildUnexpectedNodes(format: format), const: const?.buildToken(format: format), unexpectedBetweenConstAndFirstName?.buildUnexpectedNodes(format: format), firstName: firstName?.buildToken(format: format), unexpectedBetweenFirstNameAndSecondName?.buildUnexpectedNodes(format: format), secondName: secondName?.buildToken(format: format), unexpectedBetweenSecondNameAndColon?.buildUnexpectedNodes(format: format), colon: colon?.buildToken(format: format), unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format), type: type?.buildType(format: format), unexpectedBetweenTypeAndEllipsis?.buildUnexpectedNodes(format: format), ellipsis: ellipsis?.buildToken(format: format), unexpectedBetweenEllipsisAndDefaultArgument?.buildUnexpectedNodes(format: format), defaultArgument: defaultArgument?.buildInitializerClause(format: format), unexpectedBetweenDefaultArgumentAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildFunctionParameter(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionParameter`.
  public func createFunctionParameter() -> FunctionParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct FunctionDecl: DeclBuildable, ExpressibleAsFunctionDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndFuncKeyword: UnexpectedNodes?
  var funcKeyword: Token
  var unexpectedBetweenFuncKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  var genericParameterClause: GenericParameterClause?
  var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodes?
  var signature: FunctionSignature
  var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodes?
  var body: CodeBlock?
  /// Creates a `FunctionDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndFuncKeyword: 
  ///   - funcKeyword: 
  ///   - unexpectedBetweenFuncKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndFuncKeyword: ExpressibleAsUnexpectedNodes? = nil, funcKeyword: Token = Token.`func`, unexpectedBetweenFuncKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndFuncKeyword = unexpectedBetweenModifiersAndFuncKeyword?.createUnexpectedNodes()
    self.funcKeyword = funcKeyword
    assert(funcKeyword.text == #"func"#)
    self.unexpectedBetweenFuncKeywordAndIdentifier = unexpectedBetweenFuncKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndSignature = unexpectedBetweenGenericParameterClauseAndSignature?.createUnexpectedNodes()
    self.signature = signature.createFunctionSignature()
    self.unexpectedBetweenSignatureAndGenericWhereClause = unexpectedBetweenSignatureAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndBody = unexpectedBetweenGenericWhereClauseAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndFuncKeyword: ExpressibleAsUnexpectedNodes? = nil, funcKeyword: Token = Token.`func`, unexpectedBetweenFuncKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndFuncKeyword: unexpectedBetweenModifiersAndFuncKeyword, funcKeyword: funcKeyword, unexpectedBetweenFuncKeywordAndIdentifier: unexpectedBetweenFuncKeywordAndIdentifier, identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature, signature: signature, unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody, body: bodyBuilder())
  }
  /// Builds a `FunctionDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionDeclSyntax`.
  func buildFunctionDecl(format: Format) -> FunctionDeclSyntax {
    var result = FunctionDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndFuncKeyword?.buildUnexpectedNodes(format: format), funcKeyword: funcKeyword.buildToken(format: format), unexpectedBetweenFuncKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParameterClauseAndSignature?.buildUnexpectedNodes(format: format), signature: signature.buildFunctionSignature(format: format), unexpectedBetweenSignatureAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndBody?.buildUnexpectedNodes(format: format), body: body?.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildFunctionDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionDecl`.
  public func createFunctionDecl() -> FunctionDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `FunctionDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct InitializerDecl: DeclBuildable, ExpressibleAsInitializerDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndInitKeyword: UnexpectedNodes?
  var initKeyword: Token
  var unexpectedBetweenInitKeywordAndOptionalMark: UnexpectedNodes?
  var optionalMark: Token?
  var unexpectedBetweenOptionalMarkAndGenericParameterClause: UnexpectedNodes?
  var genericParameterClause: GenericParameterClause?
  var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodes?
  var signature: FunctionSignature
  var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodes?
  var body: CodeBlock?
  /// Creates a `InitializerDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndInitKeyword: 
  ///   - initKeyword: 
  ///   - unexpectedBetweenInitKeywordAndOptionalMark: 
  ///   - optionalMark: 
  ///   - unexpectedBetweenOptionalMarkAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndInitKeyword: ExpressibleAsUnexpectedNodes? = nil, initKeyword: Token = Token.`init`, unexpectedBetweenInitKeywordAndOptionalMark: ExpressibleAsUnexpectedNodes? = nil, optionalMark: Token? = nil, unexpectedBetweenOptionalMarkAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndInitKeyword = unexpectedBetweenModifiersAndInitKeyword?.createUnexpectedNodes()
    self.initKeyword = initKeyword
    assert(initKeyword.text == #"init"#)
    self.unexpectedBetweenInitKeywordAndOptionalMark = unexpectedBetweenInitKeywordAndOptionalMark?.createUnexpectedNodes()
    self.optionalMark = optionalMark
    assert(optionalMark == nil || optionalMark!.text == #"?"# || optionalMark!.text == #"?"# || optionalMark!.text == #"!"#)
    self.unexpectedBetweenOptionalMarkAndGenericParameterClause = unexpectedBetweenOptionalMarkAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndSignature = unexpectedBetweenGenericParameterClauseAndSignature?.createUnexpectedNodes()
    self.signature = signature.createFunctionSignature()
    self.unexpectedBetweenSignatureAndGenericWhereClause = unexpectedBetweenSignatureAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndBody = unexpectedBetweenGenericWhereClauseAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndInitKeyword: ExpressibleAsUnexpectedNodes? = nil, initKeyword: Token = Token.`init`, unexpectedBetweenInitKeywordAndOptionalMark: ExpressibleAsUnexpectedNodes? = nil, optionalMark: Token? = nil, unexpectedBetweenOptionalMarkAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndInitKeyword: unexpectedBetweenModifiersAndInitKeyword, initKeyword: initKeyword, unexpectedBetweenInitKeywordAndOptionalMark: unexpectedBetweenInitKeywordAndOptionalMark, optionalMark: optionalMark, unexpectedBetweenOptionalMarkAndGenericParameterClause: unexpectedBetweenOptionalMarkAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature, signature: signature, unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody, body: bodyBuilder())
  }
  /// Builds a `InitializerDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InitializerDeclSyntax`.
  func buildInitializerDecl(format: Format) -> InitializerDeclSyntax {
    var result = InitializerDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndInitKeyword?.buildUnexpectedNodes(format: format), initKeyword: initKeyword.buildToken(format: format), unexpectedBetweenInitKeywordAndOptionalMark?.buildUnexpectedNodes(format: format), optionalMark: optionalMark?.buildToken(format: format), unexpectedBetweenOptionalMarkAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParameterClauseAndSignature?.buildUnexpectedNodes(format: format), signature: signature.buildFunctionSignature(format: format), unexpectedBetweenSignatureAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndBody?.buildUnexpectedNodes(format: format), body: body?.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildInitializerDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsInitializerDecl`.
  public func createInitializerDecl() -> InitializerDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `InitializerDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeinitializerDecl: DeclBuildable, ExpressibleAsDeinitializerDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndDeinitKeyword: UnexpectedNodes?
  var deinitKeyword: Token
  var unexpectedBetweenDeinitKeywordAndBody: UnexpectedNodes?
  var body: CodeBlock?
  /// Creates a `DeinitializerDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndDeinitKeyword: 
  ///   - deinitKeyword: 
  ///   - unexpectedBetweenDeinitKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndDeinitKeyword: ExpressibleAsUnexpectedNodes? = nil, deinitKeyword: Token = Token.`deinit`, unexpectedBetweenDeinitKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndDeinitKeyword = unexpectedBetweenModifiersAndDeinitKeyword?.createUnexpectedNodes()
    self.deinitKeyword = deinitKeyword
    assert(deinitKeyword.text == #"deinit"#)
    self.unexpectedBetweenDeinitKeywordAndBody = unexpectedBetweenDeinitKeywordAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndDeinitKeyword: ExpressibleAsUnexpectedNodes? = nil, deinitKeyword: Token = Token.`deinit`, unexpectedBetweenDeinitKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndDeinitKeyword: unexpectedBetweenModifiersAndDeinitKeyword, deinitKeyword: deinitKeyword, unexpectedBetweenDeinitKeywordAndBody: unexpectedBetweenDeinitKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `DeinitializerDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeinitializerDeclSyntax`.
  func buildDeinitializerDecl(format: Format) -> DeinitializerDeclSyntax {
    var result = DeinitializerDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndDeinitKeyword?.buildUnexpectedNodes(format: format), deinitKeyword: deinitKeyword.buildToken(format: format), unexpectedBetweenDeinitKeywordAndBody?.buildUnexpectedNodes(format: format), body: body?.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildDeinitializerDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeinitializerDecl`.
  public func createDeinitializerDecl() -> DeinitializerDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `DeinitializerDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SubscriptDecl: DeclBuildable, ExpressibleAsSubscriptDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndSubscriptKeyword: UnexpectedNodes?
  var subscriptKeyword: Token
  var unexpectedBetweenSubscriptKeywordAndGenericParameterClause: UnexpectedNodes?
  var genericParameterClause: GenericParameterClause?
  var unexpectedBetweenGenericParameterClauseAndIndices: UnexpectedNodes?
  var indices: ParameterClause
  var unexpectedBetweenIndicesAndResult: UnexpectedNodes?
  var result: ReturnClause
  var unexpectedBetweenResultAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndAccessor: UnexpectedNodes?
  var accessor: SyntaxBuildable?
  /// Creates a `SubscriptDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndSubscriptKeyword: 
  ///   - subscriptKeyword: 
  ///   - unexpectedBetweenSubscriptKeywordAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndIndices: 
  ///   - indices: 
  ///   - unexpectedBetweenIndicesAndResult: 
  ///   - result: 
  ///   - unexpectedBetweenResultAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndAccessor: 
  ///   - accessor: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndSubscriptKeyword: ExpressibleAsUnexpectedNodes? = nil, subscriptKeyword: Token = Token.`subscript`, unexpectedBetweenSubscriptKeywordAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndIndices: ExpressibleAsUnexpectedNodes? = nil, indices: ExpressibleAsParameterClause, unexpectedBetweenIndicesAndResult: ExpressibleAsUnexpectedNodes? = nil, result: ExpressibleAsReturnClause, unexpectedBetweenResultAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndAccessor: ExpressibleAsUnexpectedNodes? = nil, accessor: ExpressibleAsSyntaxBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndSubscriptKeyword = unexpectedBetweenModifiersAndSubscriptKeyword?.createUnexpectedNodes()
    self.subscriptKeyword = subscriptKeyword
    assert(subscriptKeyword.text == #"subscript"#)
    self.unexpectedBetweenSubscriptKeywordAndGenericParameterClause = unexpectedBetweenSubscriptKeywordAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndIndices = unexpectedBetweenGenericParameterClauseAndIndices?.createUnexpectedNodes()
    self.indices = indices.createParameterClause()
    self.unexpectedBetweenIndicesAndResult = unexpectedBetweenIndicesAndResult?.createUnexpectedNodes()
    self.result = result.createReturnClause()
    self.unexpectedBetweenResultAndGenericWhereClause = unexpectedBetweenResultAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndAccessor = unexpectedBetweenGenericWhereClauseAndAccessor?.createUnexpectedNodes()
    self.accessor = accessor?.createSyntaxBuildable()
  }
  /// Builds a `SubscriptDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SubscriptDeclSyntax`.
  func buildSubscriptDecl(format: Format) -> SubscriptDeclSyntax {
    var result = SubscriptDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndSubscriptKeyword?.buildUnexpectedNodes(format: format), subscriptKeyword: subscriptKeyword.buildToken(format: format), unexpectedBetweenSubscriptKeywordAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParameterClauseAndIndices?.buildUnexpectedNodes(format: format), indices: indices.buildParameterClause(format: format), unexpectedBetweenIndicesAndResult?.buildUnexpectedNodes(format: format), result: result.buildReturnClause(format: format), unexpectedBetweenResultAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndAccessor?.buildUnexpectedNodes(format: format), accessor: accessor?.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildSubscriptDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsSubscriptDecl`.
  public func createSubscriptDecl() -> SubscriptDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `SubscriptDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AccessLevelModifier: SyntaxBuildable, ExpressibleAsAccessLevelModifier {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndModifier: UnexpectedNodes?
  var modifier: DeclModifierDetail?
  /// Creates a `AccessLevelModifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndModifier: 
  ///   - modifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifierDetail? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndModifier = unexpectedBetweenNameAndModifier?.createUnexpectedNodes()
    self.modifier = modifier?.createDeclModifierDetail()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifierDetail? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndModifier: unexpectedBetweenNameAndModifier, modifier: modifier)
  }
  /// Builds a `AccessLevelModifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessLevelModifierSyntax`.
  func buildAccessLevelModifier(format: Format) -> AccessLevelModifierSyntax {
    var result = AccessLevelModifierSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndModifier?.buildUnexpectedNodes(format: format), modifier: modifier?.buildDeclModifierDetail(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessLevelModifier(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessLevelModifier`.
  public func createAccessLevelModifier() -> AccessLevelModifier {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessLevelModifier` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AccessPathComponent: SyntaxBuildable, ExpressibleAsAccessPathComponent {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndTrailingDot: UnexpectedNodes?
  var trailingDot: Token?
  /// Creates a `AccessPathComponent` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingDot: 
  ///   - trailingDot: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingDot: ExpressibleAsUnexpectedNodes? = nil, trailingDot: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingDot = unexpectedBetweenNameAndTrailingDot?.createUnexpectedNodes()
    self.trailingDot = trailingDot
    assert(trailingDot == nil || trailingDot!.text == #"."#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingDot: ExpressibleAsUnexpectedNodes? = nil, trailingDot: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingDot: unexpectedBetweenNameAndTrailingDot, trailingDot: trailingDot)
  }
  /// Builds a `AccessPathComponentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessPathComponentSyntax`.
  func buildAccessPathComponent(format: Format) -> AccessPathComponentSyntax {
    var result = AccessPathComponentSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndTrailingDot?.buildUnexpectedNodes(format: format), trailingDot: trailingDot?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessPathComponent(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessPathComponent`.
  public func createAccessPathComponent() -> AccessPathComponent {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessPathComponent` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ImportDecl: DeclBuildable, ExpressibleAsImportDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndImportTok: UnexpectedNodes?
  var importTok: Token
  var unexpectedBetweenImportTokAndImportKind: UnexpectedNodes?
  var importKind: Token?
  var unexpectedBetweenImportKindAndPath: UnexpectedNodes?
  var path: AccessPath
  /// Creates a `ImportDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndImportTok: 
  ///   - importTok: 
  ///   - unexpectedBetweenImportTokAndImportKind: 
  ///   - importKind: 
  ///   - unexpectedBetweenImportKindAndPath: 
  ///   - path: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndImportTok: ExpressibleAsUnexpectedNodes? = nil, importTok: Token = Token.`import`, unexpectedBetweenImportTokAndImportKind: ExpressibleAsUnexpectedNodes? = nil, importKind: Token? = nil, unexpectedBetweenImportKindAndPath: ExpressibleAsUnexpectedNodes? = nil, path: ExpressibleAsAccessPath) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndImportTok = unexpectedBetweenModifiersAndImportTok?.createUnexpectedNodes()
    self.importTok = importTok
    assert(importTok.text == #"import"#)
    self.unexpectedBetweenImportTokAndImportKind = unexpectedBetweenImportTokAndImportKind?.createUnexpectedNodes()
    self.importKind = importKind
    assert(importKind == nil || importKind!.text == #"typealias"# || importKind!.text == #"struct"# || importKind!.text == #"class"# || importKind!.text == #"enum"# || importKind!.text == #"protocol"# || importKind!.text == #"var"# || importKind!.text == #"let"# || importKind!.text == #"func"#)
    self.unexpectedBetweenImportKindAndPath = unexpectedBetweenImportKindAndPath?.createUnexpectedNodes()
    self.path = path.createAccessPath()
  }
  /// Builds a `ImportDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImportDeclSyntax`.
  func buildImportDecl(format: Format) -> ImportDeclSyntax {
    var result = ImportDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndImportTok?.buildUnexpectedNodes(format: format), importTok: importTok.buildToken(format: format), unexpectedBetweenImportTokAndImportKind?.buildUnexpectedNodes(format: format), importKind: importKind?.buildToken(format: format), unexpectedBetweenImportKindAndPath?.buildUnexpectedNodes(format: format), path: path.buildAccessPath(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildImportDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsImportDecl`.
  public func createImportDecl() -> ImportDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ImportDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AccessorParameter: SyntaxBuildable, ExpressibleAsAccessorParameter {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `AccessorParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndName = unexpectedBetweenLeftParenAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndRightParen = unexpectedBetweenNameAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndName: unexpectedBetweenLeftParenAndName, name: Token.`identifier`(name), unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen, rightParen: rightParen)
  }
  /// Builds a `AccessorParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorParameterSyntax`.
  func buildAccessorParameter(format: Format) -> AccessorParameterSyntax {
    var result = AccessorParameterSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessorParameter(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorParameter`.
  public func createAccessorParameter() -> AccessorParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessorParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AccessorDecl: DeclBuildable, ExpressibleAsAccessorDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifier: UnexpectedNodes?
  var modifier: DeclModifier?
  var unexpectedBetweenModifierAndAccessorKind: UnexpectedNodes?
  var accessorKind: Token
  var unexpectedBetweenAccessorKindAndParameter: UnexpectedNodes?
  var parameter: AccessorParameter?
  var unexpectedBetweenParameterAndAsyncKeyword: UnexpectedNodes?
  var asyncKeyword: Token?
  var unexpectedBetweenAsyncKeywordAndThrowsKeyword: UnexpectedNodes?
  var throwsKeyword: Token?
  var unexpectedBetweenThrowsKeywordAndBody: UnexpectedNodes?
  var body: CodeBlock?
  /// Creates a `AccessorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifier: 
  ///   - modifier: 
  ///   - unexpectedBetweenModifierAndAccessorKind: 
  ///   - accessorKind: 
  ///   - unexpectedBetweenAccessorKindAndParameter: 
  ///   - parameter: 
  ///   - unexpectedBetweenParameterAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsKeyword: 
  ///   - throwsKeyword: 
  ///   - unexpectedBetweenThrowsKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifier? = nil, unexpectedBetweenModifierAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token, unexpectedBetweenAccessorKindAndParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsAccessorParameter? = nil, unexpectedBetweenParameterAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsKeyword: Token? = nil, unexpectedBetweenThrowsKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifier = unexpectedBetweenAttributesAndModifier?.createUnexpectedNodes()
    self.modifier = modifier?.createDeclModifier()
    self.unexpectedBetweenModifierAndAccessorKind = unexpectedBetweenModifierAndAccessorKind?.createUnexpectedNodes()
    self.accessorKind = accessorKind
    assert(accessorKind.text == #"get"# || accessorKind.text == #"set"# || accessorKind.text == #"didSet"# || accessorKind.text == #"willSet"# || accessorKind.text == #"unsafeAddress"# || accessorKind.text == #"addressWithOwner"# || accessorKind.text == #"addressWithNativeOwner"# || accessorKind.text == #"unsafeMutableAddress"# || accessorKind.text == #"mutableAddressWithOwner"# || accessorKind.text == #"mutableAddressWithNativeOwner"# || accessorKind.text == #"_read"# || accessorKind.text == #"_modify"#)
    self.unexpectedBetweenAccessorKindAndParameter = unexpectedBetweenAccessorKindAndParameter?.createUnexpectedNodes()
    self.parameter = parameter?.createAccessorParameter()
    self.unexpectedBetweenParameterAndAsyncKeyword = unexpectedBetweenParameterAndAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsKeyword = unexpectedBetweenAsyncKeywordAndThrowsKeyword?.createUnexpectedNodes()
    self.throwsKeyword = throwsKeyword
    assert(throwsKeyword == nil || throwsKeyword!.text == #"throws"# || throwsKeyword!.text == #"rethrows"#)
    self.unexpectedBetweenThrowsKeywordAndBody = unexpectedBetweenThrowsKeywordAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifier? = nil, unexpectedBetweenModifierAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token, unexpectedBetweenAccessorKindAndParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsAccessorParameter? = nil, unexpectedBetweenParameterAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsKeyword: Token? = nil, unexpectedBetweenThrowsKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifier: unexpectedBetweenAttributesAndModifier, modifier: modifier, unexpectedBetweenModifierAndAccessorKind: unexpectedBetweenModifierAndAccessorKind, accessorKind: accessorKind, unexpectedBetweenAccessorKindAndParameter: unexpectedBetweenAccessorKindAndParameter, parameter: parameter, unexpectedBetweenParameterAndAsyncKeyword: unexpectedBetweenParameterAndAsyncKeyword, asyncKeyword: asyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncKeywordAndThrowsKeyword: unexpectedBetweenAsyncKeywordAndThrowsKeyword, throwsKeyword: throwsKeyword, unexpectedBetweenThrowsKeywordAndBody: unexpectedBetweenThrowsKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `AccessorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorDeclSyntax`.
  func buildAccessorDecl(format: Format) -> AccessorDeclSyntax {
    var result = AccessorDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifier?.buildUnexpectedNodes(format: format), modifier: modifier?.buildDeclModifier(format: format), unexpectedBetweenModifierAndAccessorKind?.buildUnexpectedNodes(format: format), accessorKind: accessorKind.buildToken(format: format), unexpectedBetweenAccessorKindAndParameter?.buildUnexpectedNodes(format: format), parameter: parameter?.buildAccessorParameter(format: format), unexpectedBetweenParameterAndAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: asyncKeyword?.buildToken(format: format), unexpectedBetweenAsyncKeywordAndThrowsKeyword?.buildUnexpectedNodes(format: format), throwsKeyword: throwsKeyword?.buildToken(format: format), unexpectedBetweenThrowsKeywordAndBody?.buildUnexpectedNodes(format: format), body: body?.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildAccessorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorDecl`.
  public func createAccessorDecl() -> AccessorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `AccessorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AccessorBlock: SyntaxBuildable, ExpressibleAsAccessorBlock {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftBrace: UnexpectedNodes?
  var leftBrace: Token
  var unexpectedBetweenLeftBraceAndAccessors: UnexpectedNodes?
  var accessors: AccessorList
  var unexpectedBetweenAccessorsAndRightBrace: UnexpectedNodes?
  var rightBrace: Token
  /// Creates a `AccessorBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndAccessors: 
  ///   - accessors: 
  ///   - unexpectedBetweenAccessorsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndAccessors: ExpressibleAsUnexpectedNodes? = nil, accessors: ExpressibleAsAccessorList, unexpectedBetweenAccessorsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndAccessors = unexpectedBetweenLeftBraceAndAccessors?.createUnexpectedNodes()
    self.accessors = accessors.createAccessorList()
    self.unexpectedBetweenAccessorsAndRightBrace = unexpectedBetweenAccessorsAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// Builds a `AccessorBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorBlockSyntax`.
  func buildAccessorBlock(format: Format) -> AccessorBlockSyntax {
    var result = AccessorBlockSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: leftBrace.buildToken(format: format), unexpectedBetweenLeftBraceAndAccessors?.buildUnexpectedNodes(format: format), accessors: accessors.buildAccessorList(format: format), unexpectedBetweenAccessorsAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: rightBrace.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessorBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorBlock`.
  public func createAccessorBlock() -> AccessorBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessorBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PatternBinding: SyntaxBuildable, ExpressibleAsPatternBinding, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePattern: UnexpectedNodes?
  var pattern: PatternBuildable
  var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  var typeAnnotation: TypeAnnotation?
  var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
  var initializer: InitializerClause?
  var unexpectedBetweenInitializerAndAccessor: UnexpectedNodes?
  var accessor: SyntaxBuildable?
  var unexpectedBetweenAccessorAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `PatternBinding` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndAccessor: 
  ///   - accessor: 
  ///   - unexpectedBetweenAccessorAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil, unexpectedBetweenInitializerAndAccessor: ExpressibleAsUnexpectedNodes? = nil, accessor: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenAccessorAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInitializer = unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createInitializerClause()
    self.unexpectedBetweenInitializerAndAccessor = unexpectedBetweenInitializerAndAccessor?.createUnexpectedNodes()
    self.accessor = accessor?.createSyntaxBuildable()
    self.unexpectedBetweenAccessorAndTrailingComma = unexpectedBetweenAccessorAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `PatternBindingSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PatternBindingSyntax`.
  func buildPatternBinding(format: Format) -> PatternBindingSyntax {
    var result = PatternBindingSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format), unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format), initializer: initializer?.buildInitializerClause(format: format), unexpectedBetweenInitializerAndAccessor?.buildUnexpectedNodes(format: format), accessor: accessor?.buildSyntax(format: format), unexpectedBetweenAccessorAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPatternBinding(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPatternBinding`.
  public func createPatternBinding() -> PatternBinding {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBinding` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct VariableDecl: DeclBuildable, ExpressibleAsVariableDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndLetOrVarKeyword: UnexpectedNodes?
  var letOrVarKeyword: Token
  var unexpectedBetweenLetOrVarKeywordAndBindings: UnexpectedNodes?
  var bindings: PatternBindingList
  /// Creates a `VariableDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndBindings: 
  ///   - bindings: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndBindings: ExpressibleAsUnexpectedNodes? = nil, bindings: ExpressibleAsPatternBindingList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndLetOrVarKeyword = unexpectedBetweenModifiersAndLetOrVarKeyword?.createUnexpectedNodes()
    self.letOrVarKeyword = letOrVarKeyword
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.unexpectedBetweenLetOrVarKeywordAndBindings = unexpectedBetweenLetOrVarKeywordAndBindings?.createUnexpectedNodes()
    self.bindings = bindings.createPatternBindingList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndBindings: ExpressibleAsUnexpectedNodes? = nil, @PatternBindingListBuilder bindingsBuilder: () -> ExpressibleAsPatternBindingList =  {
    PatternBindingList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndLetOrVarKeyword: unexpectedBetweenModifiersAndLetOrVarKeyword, letOrVarKeyword: letOrVarKeyword, unexpectedBetweenLetOrVarKeywordAndBindings: unexpectedBetweenLetOrVarKeywordAndBindings, bindings: bindingsBuilder())
  }
  /// Builds a `VariableDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `VariableDeclSyntax`.
  func buildVariableDecl(format: Format) -> VariableDeclSyntax {
    var result = VariableDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndLetOrVarKeyword?.buildUnexpectedNodes(format: format), letOrVarKeyword: letOrVarKeyword.buildToken(format: format), unexpectedBetweenLetOrVarKeywordAndBindings?.buildUnexpectedNodes(format: format), bindings: bindings.buildPatternBindingList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildVariableDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsVariableDecl`.
  public func createVariableDecl() -> VariableDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `VariableDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// An element of an enum case, containing the name of the case and,optionally, either associated values or an assignment to a raw value.
public struct EnumCaseElement: SyntaxBuildable, ExpressibleAsEnumCaseElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndAssociatedValue: UnexpectedNodes?
  var associatedValue: ParameterClause?
  var unexpectedBetweenAssociatedValueAndRawValue: UnexpectedNodes?
  var rawValue: InitializerClause?
  var unexpectedBetweenRawValueAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `EnumCaseElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: The name of this case.
  ///   - unexpectedBetweenIdentifierAndAssociatedValue: 
  ///   - associatedValue: The set of associated values of the case.
  ///   - unexpectedBetweenAssociatedValueAndRawValue: 
  ///   - rawValue: The raw value of this enum element, if present.
  ///   - unexpectedBetweenRawValueAndTrailingComma: 
  ///   - trailingComma: The trailing comma of this element, if the case hasmultiple elements.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndAssociatedValue: ExpressibleAsUnexpectedNodes? = nil, associatedValue: ExpressibleAsParameterClause? = nil, unexpectedBetweenAssociatedValueAndRawValue: ExpressibleAsUnexpectedNodes? = nil, rawValue: ExpressibleAsInitializerClause? = nil, unexpectedBetweenRawValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndAssociatedValue = unexpectedBetweenIdentifierAndAssociatedValue?.createUnexpectedNodes()
    self.associatedValue = associatedValue?.createParameterClause()
    self.unexpectedBetweenAssociatedValueAndRawValue = unexpectedBetweenAssociatedValueAndRawValue?.createUnexpectedNodes()
    self.rawValue = rawValue?.createInitializerClause()
    self.unexpectedBetweenRawValueAndTrailingComma = unexpectedBetweenRawValueAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndAssociatedValue: ExpressibleAsUnexpectedNodes? = nil, associatedValue: ExpressibleAsParameterClause? = nil, unexpectedBetweenAssociatedValueAndRawValue: ExpressibleAsUnexpectedNodes? = nil, rawValue: ExpressibleAsInitializerClause? = nil, unexpectedBetweenRawValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndAssociatedValue: unexpectedBetweenIdentifierAndAssociatedValue, associatedValue: associatedValue, unexpectedBetweenAssociatedValueAndRawValue: unexpectedBetweenAssociatedValueAndRawValue, rawValue: rawValue, unexpectedBetweenRawValueAndTrailingComma: unexpectedBetweenRawValueAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `EnumCaseElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCaseElementSyntax`.
  func buildEnumCaseElement(format: Format) -> EnumCaseElementSyntax {
    var result = EnumCaseElementSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndAssociatedValue?.buildUnexpectedNodes(format: format), associatedValue: associatedValue?.buildParameterClause(format: format), unexpectedBetweenAssociatedValueAndRawValue?.buildUnexpectedNodes(format: format), rawValue: rawValue?.buildInitializerClause(format: format), unexpectedBetweenRawValueAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildEnumCaseElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCaseElement`.
  public func createEnumCaseElement() -> EnumCaseElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `EnumCaseElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A `case` declaration of a Swift `enum`. It can have 1 or more`EnumCaseElement`s inside, each declaring a different case of theenum.
public struct EnumCaseDecl: DeclBuildable, ExpressibleAsEnumCaseDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndCaseKeyword: UnexpectedNodes?
  var caseKeyword: Token
  var unexpectedBetweenCaseKeywordAndElements: UnexpectedNodes?
  var elements: EnumCaseElementList
  /// Creates a `EnumCaseDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the case declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the case declaration.
  ///   - unexpectedBetweenModifiersAndCaseKeyword: 
  ///   - caseKeyword: The `case` keyword for this case.
  ///   - unexpectedBetweenCaseKeywordAndElements: 
  ///   - elements: The elements this case declares.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsEnumCaseElementList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndCaseKeyword = unexpectedBetweenModifiersAndCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndElements = unexpectedBetweenCaseKeywordAndElements?.createUnexpectedNodes()
    self.elements = elements.createEnumCaseElementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndElements: ExpressibleAsUnexpectedNodes? = nil, @EnumCaseElementListBuilder elementsBuilder: () -> ExpressibleAsEnumCaseElementList =  {
    EnumCaseElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndCaseKeyword: unexpectedBetweenModifiersAndCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndElements: unexpectedBetweenCaseKeywordAndElements, elements: elementsBuilder())
  }
  /// Builds a `EnumCaseDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCaseDeclSyntax`.
  func buildEnumCaseDecl(format: Format) -> EnumCaseDeclSyntax {
    var result = EnumCaseDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: caseKeyword.buildToken(format: format), unexpectedBetweenCaseKeywordAndElements?.buildUnexpectedNodes(format: format), elements: elements.buildEnumCaseElementList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildEnumCaseDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCaseDecl`.
  public func createEnumCaseDecl() -> EnumCaseDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `EnumCaseDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A Swift `enum` declaration.
public struct EnumDecl: DeclBuildable, ExpressibleAsEnumDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndEnumKeyword: UnexpectedNodes?
  var enumKeyword: Token
  var unexpectedBetweenEnumKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndGenericParameters: UnexpectedNodes?
  var genericParameters: GenericParameterClause?
  var unexpectedBetweenGenericParametersAndInheritanceClause: UnexpectedNodes?
  var inheritanceClause: TypeInheritanceClause?
  var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  var genericWhereClause: GenericWhereClause?
  var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  var members: MemberDeclBlock
  /// Creates a `EnumDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the enum declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the enum declaration.
  ///   - unexpectedBetweenModifiersAndEnumKeyword: 
  ///   - enumKeyword: The `enum` keyword for this declaration.
  ///   - unexpectedBetweenEnumKeywordAndIdentifier: 
  ///   - identifier: The name of this enum.
  ///   - unexpectedBetweenIdentifierAndGenericParameters: 
  ///   - genericParameters: The generic parameters, if any, for this enum.
  ///   - unexpectedBetweenGenericParametersAndInheritanceClause: 
  ///   - inheritanceClause: The inheritance clause describing conformances or rawvalues for this enum.
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters ofthis enum.
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: The cases and other members of this enum.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndEnumKeyword: ExpressibleAsUnexpectedNodes? = nil, enumKeyword: Token = Token.`enum`, unexpectedBetweenEnumKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameters: ExpressibleAsUnexpectedNodes? = nil, genericParameters: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParametersAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndEnumKeyword = unexpectedBetweenModifiersAndEnumKeyword?.createUnexpectedNodes()
    self.enumKeyword = enumKeyword
    assert(enumKeyword.text == #"enum"#)
    self.unexpectedBetweenEnumKeywordAndIdentifier = unexpectedBetweenEnumKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameters = unexpectedBetweenIdentifierAndGenericParameters?.createUnexpectedNodes()
    self.genericParameters = genericParameters?.createGenericParameterClause()
    self.unexpectedBetweenGenericParametersAndInheritanceClause = unexpectedBetweenGenericParametersAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndEnumKeyword: ExpressibleAsUnexpectedNodes? = nil, enumKeyword: Token = Token.`enum`, unexpectedBetweenEnumKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameters: ExpressibleAsUnexpectedNodes? = nil, genericParameters: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParametersAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndEnumKeyword: unexpectedBetweenModifiersAndEnumKeyword, enumKeyword: enumKeyword, unexpectedBetweenEnumKeywordAndIdentifier: unexpectedBetweenEnumKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameters: unexpectedBetweenIdentifierAndGenericParameters, genericParameters: genericParameters, unexpectedBetweenGenericParametersAndInheritanceClause: unexpectedBetweenGenericParametersAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `EnumDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumDeclSyntax`.
  func buildEnumDecl(format: Format) -> EnumDeclSyntax {
    var result = EnumDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndEnumKeyword?.buildUnexpectedNodes(format: format), enumKeyword: enumKeyword.buildToken(format: format), unexpectedBetweenEnumKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndGenericParameters?.buildUnexpectedNodes(format: format), genericParameters: genericParameters?.buildGenericParameterClause(format: format), unexpectedBetweenGenericParametersAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: members.buildMemberDeclBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildEnumDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumDecl`.
  public func createEnumDecl() -> EnumDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `EnumDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A Swift `operator` declaration.
public struct OperatorDecl: DeclBuildable, ExpressibleAsOperatorDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndOperatorKeyword: UnexpectedNodes?
  var operatorKeyword: Token
  var unexpectedBetweenOperatorKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: UnexpectedNodes?
  var operatorPrecedenceAndTypes: OperatorPrecedenceAndTypes?
  /// Creates a `OperatorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the 'operator' declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the 'operator'declaration.
  ///   - unexpectedBetweenModifiersAndOperatorKeyword: 
  ///   - operatorKeyword: 
  ///   - unexpectedBetweenOperatorKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: 
  ///   - operatorPrecedenceAndTypes: Optionally specify a precedence group and designated types.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndOperatorKeyword: ExpressibleAsUnexpectedNodes? = nil, operatorKeyword: Token = Token.`operator`, unexpectedBetweenOperatorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: ExpressibleAsUnexpectedNodes? = nil, operatorPrecedenceAndTypes: ExpressibleAsOperatorPrecedenceAndTypes? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndOperatorKeyword = unexpectedBetweenModifiersAndOperatorKeyword?.createUnexpectedNodes()
    self.operatorKeyword = operatorKeyword
    assert(operatorKeyword.text == #"operator"#)
    self.unexpectedBetweenOperatorKeywordAndIdentifier = unexpectedBetweenOperatorKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes = unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes?.createUnexpectedNodes()
    self.operatorPrecedenceAndTypes = operatorPrecedenceAndTypes?.createOperatorPrecedenceAndTypes()
  }
  /// Builds a `OperatorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OperatorDeclSyntax`.
  func buildOperatorDecl(format: Format) -> OperatorDeclSyntax {
    var result = OperatorDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndOperatorKeyword?.buildUnexpectedNodes(format: format), operatorKeyword: operatorKeyword.buildToken(format: format), unexpectedBetweenOperatorKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes?.buildUnexpectedNodes(format: format), operatorPrecedenceAndTypes: operatorPrecedenceAndTypes?.buildOperatorPrecedenceAndTypes(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildOperatorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsOperatorDecl`.
  public func createOperatorDecl() -> OperatorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `OperatorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DesignatedTypeElement: SyntaxBuildable, ExpressibleAsDesignatedTypeElement {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeadingComma: UnexpectedNodes?
  var leadingComma: Token
  var unexpectedBetweenLeadingCommaAndName: UnexpectedNodes?
  var name: Token
  /// Creates a `DesignatedTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeadingComma: 
  ///   - leadingComma: 
  ///   - unexpectedBetweenLeadingCommaAndName: 
  ///   - name: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeadingComma: ExpressibleAsUnexpectedNodes? = nil, leadingComma: Token = Token.`comma`, unexpectedBetweenLeadingCommaAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeadingComma = unexpectedBeforeLeadingComma?.createUnexpectedNodes()
    self.leadingComma = leadingComma
    assert(leadingComma.text == #","#)
    self.unexpectedBetweenLeadingCommaAndName = unexpectedBetweenLeadingCommaAndName?.createUnexpectedNodes()
    self.name = name
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeadingComma: ExpressibleAsUnexpectedNodes? = nil, leadingComma: Token = Token.`comma`, unexpectedBetweenLeadingCommaAndName: ExpressibleAsUnexpectedNodes? = nil, name: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeadingComma: unexpectedBeforeLeadingComma, leadingComma: leadingComma, unexpectedBetweenLeadingCommaAndName: unexpectedBetweenLeadingCommaAndName, name: Token.`identifier`(name))
  }
  /// Builds a `DesignatedTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DesignatedTypeElementSyntax`.
  func buildDesignatedTypeElement(format: Format) -> DesignatedTypeElementSyntax {
    var result = DesignatedTypeElementSyntax(unexpectedBeforeLeadingComma?.buildUnexpectedNodes(format: format), leadingComma: leadingComma.buildToken(format: format), unexpectedBetweenLeadingCommaAndName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDesignatedTypeElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDesignatedTypeElement`.
  public func createDesignatedTypeElement() -> DesignatedTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DesignatedTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A clause to specify precedence group in infix operator declarations, and designated types in any operator declaration.
public struct OperatorPrecedenceAndTypes: SyntaxBuildable, ExpressibleAsOperatorPrecedenceAndTypes {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndPrecedenceGroup: UnexpectedNodes?
  var precedenceGroup: Token
  var unexpectedBetweenPrecedenceGroupAndDesignatedTypes: UnexpectedNodes?
  var designatedTypes: DesignatedTypeList
  /// Creates a `OperatorPrecedenceAndTypes` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndPrecedenceGroup: 
  ///   - precedenceGroup: The precedence group for this operator
  ///   - unexpectedBetweenPrecedenceGroupAndDesignatedTypes: 
  ///   - designatedTypes: The designated types associated with this operator.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndPrecedenceGroup: ExpressibleAsUnexpectedNodes? = nil, precedenceGroup: Token, unexpectedBetweenPrecedenceGroupAndDesignatedTypes: ExpressibleAsUnexpectedNodes? = nil, designatedTypes: ExpressibleAsDesignatedTypeList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeColon = unexpectedBeforeColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndPrecedenceGroup = unexpectedBetweenColonAndPrecedenceGroup?.createUnexpectedNodes()
    self.precedenceGroup = precedenceGroup
    self.unexpectedBetweenPrecedenceGroupAndDesignatedTypes = unexpectedBetweenPrecedenceGroupAndDesignatedTypes?.createUnexpectedNodes()
    self.designatedTypes = designatedTypes.createDesignatedTypeList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndPrecedenceGroup: ExpressibleAsUnexpectedNodes? = nil, precedenceGroup: String, unexpectedBetweenPrecedenceGroupAndDesignatedTypes: ExpressibleAsUnexpectedNodes? = nil, designatedTypes: ExpressibleAsDesignatedTypeList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeColon: unexpectedBeforeColon, colon: colon, unexpectedBetweenColonAndPrecedenceGroup: unexpectedBetweenColonAndPrecedenceGroup, precedenceGroup: Token.`identifier`(precedenceGroup), unexpectedBetweenPrecedenceGroupAndDesignatedTypes: unexpectedBetweenPrecedenceGroupAndDesignatedTypes, designatedTypes: designatedTypes)
  }
  /// Builds a `OperatorPrecedenceAndTypesSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OperatorPrecedenceAndTypesSyntax`.
  func buildOperatorPrecedenceAndTypes(format: Format) -> OperatorPrecedenceAndTypesSyntax {
    var result = OperatorPrecedenceAndTypesSyntax(unexpectedBeforeColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndPrecedenceGroup?.buildUnexpectedNodes(format: format), precedenceGroup: precedenceGroup.buildToken(format: format), unexpectedBetweenPrecedenceGroupAndDesignatedTypes?.buildUnexpectedNodes(format: format), designatedTypes: designatedTypes.buildDesignatedTypeList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildOperatorPrecedenceAndTypes(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOperatorPrecedenceAndTypes`.
  public func createOperatorPrecedenceAndTypes() -> OperatorPrecedenceAndTypes {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OperatorPrecedenceAndTypes` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A Swift `precedencegroup` declaration.
public struct PrecedenceGroupDecl: DeclBuildable, ExpressibleAsPrecedenceGroupDecl {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  var modifiers: ModifierList?
  var unexpectedBetweenModifiersAndPrecedencegroupKeyword: UnexpectedNodes?
  var precedencegroupKeyword: Token
  var unexpectedBetweenPrecedencegroupKeywordAndIdentifier: UnexpectedNodes?
  var identifier: Token
  var unexpectedBetweenIdentifierAndLeftBrace: UnexpectedNodes?
  var leftBrace: Token
  var unexpectedBetweenLeftBraceAndGroupAttributes: UnexpectedNodes?
  var groupAttributes: PrecedenceGroupAttributeList
  var unexpectedBetweenGroupAttributesAndRightBrace: UnexpectedNodes?
  var rightBrace: Token
  /// Creates a `PrecedenceGroupDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the 'precedencegroup' declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the 'precedencegroup'declaration.
  ///   - unexpectedBetweenModifiersAndPrecedencegroupKeyword: 
  ///   - precedencegroupKeyword: 
  ///   - unexpectedBetweenPrecedencegroupKeywordAndIdentifier: 
  ///   - identifier: The name of this precedence group.
  ///   - unexpectedBetweenIdentifierAndLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndGroupAttributes: 
  ///   - groupAttributes: The characteristics of this precedence group.
  ///   - unexpectedBetweenGroupAttributesAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndPrecedencegroupKeyword: ExpressibleAsUnexpectedNodes? = nil, precedencegroupKeyword: Token = Token.`precedencegroup`, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndGroupAttributes: ExpressibleAsUnexpectedNodes? = nil, groupAttributes: ExpressibleAsPrecedenceGroupAttributeList, unexpectedBetweenGroupAttributesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndPrecedencegroupKeyword = unexpectedBetweenModifiersAndPrecedencegroupKeyword?.createUnexpectedNodes()
    self.precedencegroupKeyword = precedencegroupKeyword
    assert(precedencegroupKeyword.text == #"precedencegroup"#)
    self.unexpectedBetweenPrecedencegroupKeywordAndIdentifier = unexpectedBetweenPrecedencegroupKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndLeftBrace = unexpectedBetweenIdentifierAndLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndGroupAttributes = unexpectedBetweenLeftBraceAndGroupAttributes?.createUnexpectedNodes()
    self.groupAttributes = groupAttributes.createPrecedenceGroupAttributeList()
    self.unexpectedBetweenGroupAttributesAndRightBrace = unexpectedBetweenGroupAttributesAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndPrecedencegroupKeyword: ExpressibleAsUnexpectedNodes? = nil, precedencegroupKeyword: Token = Token.`precedencegroup`, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndGroupAttributes: ExpressibleAsUnexpectedNodes? = nil, groupAttributes: ExpressibleAsPrecedenceGroupAttributeList, unexpectedBetweenGroupAttributesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndPrecedencegroupKeyword: unexpectedBetweenModifiersAndPrecedencegroupKeyword, precedencegroupKeyword: precedencegroupKeyword, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: unexpectedBetweenPrecedencegroupKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndLeftBrace: unexpectedBetweenIdentifierAndLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndGroupAttributes: unexpectedBetweenLeftBraceAndGroupAttributes, groupAttributes: groupAttributes, unexpectedBetweenGroupAttributesAndRightBrace: unexpectedBetweenGroupAttributesAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `PrecedenceGroupDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupDeclSyntax`.
  func buildPrecedenceGroupDecl(format: Format) -> PrecedenceGroupDeclSyntax {
    var result = PrecedenceGroupDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: modifiers?.buildModifierList(format: format), unexpectedBetweenModifiersAndPrecedencegroupKeyword?.buildUnexpectedNodes(format: format), precedencegroupKeyword: precedencegroupKeyword.buildToken(format: format), unexpectedBetweenPrecedencegroupKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format), unexpectedBetweenIdentifierAndLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: leftBrace.buildToken(format: format), unexpectedBetweenLeftBraceAndGroupAttributes?.buildUnexpectedNodes(format: format), groupAttributes: groupAttributes.buildPrecedenceGroupAttributeList(format: format), unexpectedBetweenGroupAttributesAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: rightBrace.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPrecedenceGroupDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupDecl`.
  public func createPrecedenceGroupDecl() -> PrecedenceGroupDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PrecedenceGroupDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// Specify the new precedence group's relation to existing precedencegroups.
public struct PrecedenceGroupRelation: SyntaxBuildable, ExpressibleAsPrecedenceGroupRelation {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeHigherThanOrLowerThan: UnexpectedNodes?
  var higherThanOrLowerThan: Token
  var unexpectedBetweenHigherThanOrLowerThanAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndOtherNames: UnexpectedNodes?
  var otherNames: PrecedenceGroupNameList
  /// Creates a `PrecedenceGroupRelation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeHigherThanOrLowerThan: 
  ///   - higherThanOrLowerThan: The relation to specified other precedence groups.
  ///   - unexpectedBetweenHigherThanOrLowerThanAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndOtherNames: 
  ///   - otherNames: The name of other precedence group to which this precedencegroup relates.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeHigherThanOrLowerThan: ExpressibleAsUnexpectedNodes? = nil, higherThanOrLowerThan: Token, unexpectedBetweenHigherThanOrLowerThanAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOtherNames: ExpressibleAsUnexpectedNodes? = nil, otherNames: ExpressibleAsPrecedenceGroupNameList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeHigherThanOrLowerThan = unexpectedBeforeHigherThanOrLowerThan?.createUnexpectedNodes()
    self.higherThanOrLowerThan = higherThanOrLowerThan
    assert(higherThanOrLowerThan.text == #"higherThan"# || higherThanOrLowerThan.text == #"lowerThan"#)
    self.unexpectedBetweenHigherThanOrLowerThanAndColon = unexpectedBetweenHigherThanOrLowerThanAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndOtherNames = unexpectedBetweenColonAndOtherNames?.createUnexpectedNodes()
    self.otherNames = otherNames.createPrecedenceGroupNameList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeHigherThanOrLowerThan: ExpressibleAsUnexpectedNodes? = nil, higherThanOrLowerThan: String, unexpectedBetweenHigherThanOrLowerThanAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOtherNames: ExpressibleAsUnexpectedNodes? = nil, otherNames: ExpressibleAsPrecedenceGroupNameList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeHigherThanOrLowerThan: unexpectedBeforeHigherThanOrLowerThan, higherThanOrLowerThan: Token.`identifier`(higherThanOrLowerThan), unexpectedBetweenHigherThanOrLowerThanAndColon: unexpectedBetweenHigherThanOrLowerThanAndColon, colon: colon, unexpectedBetweenColonAndOtherNames: unexpectedBetweenColonAndOtherNames, otherNames: otherNames)
  }
  /// Builds a `PrecedenceGroupRelationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupRelationSyntax`.
  func buildPrecedenceGroupRelation(format: Format) -> PrecedenceGroupRelationSyntax {
    var result = PrecedenceGroupRelationSyntax(unexpectedBeforeHigherThanOrLowerThan?.buildUnexpectedNodes(format: format), higherThanOrLowerThan: higherThanOrLowerThan.buildToken(format: format), unexpectedBetweenHigherThanOrLowerThanAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndOtherNames?.buildUnexpectedNodes(format: format), otherNames: otherNames.buildPrecedenceGroupNameList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupRelation(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupRelation`.
  public func createPrecedenceGroupRelation() -> PrecedenceGroupRelation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupRelation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PrecedenceGroupNameElement: SyntaxBuildable, ExpressibleAsPrecedenceGroupNameElement {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `PrecedenceGroupNameElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingComma = unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `PrecedenceGroupNameElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupNameElementSyntax`.
  func buildPrecedenceGroupNameElement(format: Format) -> PrecedenceGroupNameElementSyntax {
    var result = PrecedenceGroupNameElementSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupNameElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupNameElement`.
  public func createPrecedenceGroupNameElement() -> PrecedenceGroupNameElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupNameElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// Specifies the precedence of an operator when used in an operationthat includes optional chaining.
public struct PrecedenceGroupAssignment: SyntaxBuildable, ExpressibleAsPrecedenceGroupAssignment {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAssignmentKeyword: UnexpectedNodes?
  var assignmentKeyword: Token
  var unexpectedBetweenAssignmentKeywordAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndFlag: UnexpectedNodes?
  var flag: Token
  /// Creates a `PrecedenceGroupAssignment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssignmentKeyword: 
  ///   - assignmentKeyword: 
  ///   - unexpectedBetweenAssignmentKeywordAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndFlag: 
  ///   - flag: When true, an operator in the corresponding precedence groupuses the same grouping rules during optional chaining as theassignment operators from the standard library. Otherwise,operators in the precedence group follows the same optionalchaining rules as operators that don't perform assignment.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAssignmentKeyword: ExpressibleAsUnexpectedNodes? = nil, assignmentKeyword: Token, unexpectedBetweenAssignmentKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndFlag: ExpressibleAsUnexpectedNodes? = nil, flag: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAssignmentKeyword = unexpectedBeforeAssignmentKeyword?.createUnexpectedNodes()
    self.assignmentKeyword = assignmentKeyword
    assert(assignmentKeyword.text == #"assignment"#)
    self.unexpectedBetweenAssignmentKeywordAndColon = unexpectedBetweenAssignmentKeywordAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndFlag = unexpectedBetweenColonAndFlag?.createUnexpectedNodes()
    self.flag = flag
    assert(flag.text == #"true"# || flag.text == #"false"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssignmentKeyword: ExpressibleAsUnexpectedNodes? = nil, assignmentKeyword: String, unexpectedBetweenAssignmentKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndFlag: ExpressibleAsUnexpectedNodes? = nil, flag: Token) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAssignmentKeyword: unexpectedBeforeAssignmentKeyword, assignmentKeyword: Token.`identifier`(assignmentKeyword), unexpectedBetweenAssignmentKeywordAndColon: unexpectedBetweenAssignmentKeywordAndColon, colon: colon, unexpectedBetweenColonAndFlag: unexpectedBetweenColonAndFlag, flag: flag)
  }
  /// Builds a `PrecedenceGroupAssignmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupAssignmentSyntax`.
  func buildPrecedenceGroupAssignment(format: Format) -> PrecedenceGroupAssignmentSyntax {
    var result = PrecedenceGroupAssignmentSyntax(unexpectedBeforeAssignmentKeyword?.buildUnexpectedNodes(format: format), assignmentKeyword: assignmentKeyword.buildToken(format: format), unexpectedBetweenAssignmentKeywordAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndFlag?.buildUnexpectedNodes(format: format), flag: flag.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupAssignment(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupAssignment`.
  public func createPrecedenceGroupAssignment() -> PrecedenceGroupAssignment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupAssignment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// Specifies how a sequence of operators with the same precedence levelare grouped together in the absence of grouping parentheses.
public struct PrecedenceGroupAssociativity: SyntaxBuildable, ExpressibleAsPrecedenceGroupAssociativity {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAssociativityKeyword: UnexpectedNodes?
  var associativityKeyword: Token
  var unexpectedBetweenAssociativityKeywordAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndValue: UnexpectedNodes?
  var value: Token
  /// Creates a `PrecedenceGroupAssociativity` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssociativityKeyword: 
  ///   - associativityKeyword: 
  ///   - unexpectedBetweenAssociativityKeywordAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: Operators that are `left`-associative group left-to-right.Operators that are `right`-associative group right-to-left.Operators that are specified with an associativity of `none`don't associate at all
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAssociativityKeyword: ExpressibleAsUnexpectedNodes? = nil, associativityKeyword: Token, unexpectedBetweenAssociativityKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAssociativityKeyword = unexpectedBeforeAssociativityKeyword?.createUnexpectedNodes()
    self.associativityKeyword = associativityKeyword
    assert(associativityKeyword.text == #"associativity"#)
    self.unexpectedBetweenAssociativityKeywordAndColon = unexpectedBetweenAssociativityKeywordAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValue = unexpectedBetweenColonAndValue?.createUnexpectedNodes()
    self.value = value
    assert(value.text == #"left"# || value.text == #"right"# || value.text == #"none"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssociativityKeyword: ExpressibleAsUnexpectedNodes? = nil, associativityKeyword: String, unexpectedBetweenAssociativityKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAssociativityKeyword: unexpectedBeforeAssociativityKeyword, associativityKeyword: Token.`identifier`(associativityKeyword), unexpectedBetweenAssociativityKeywordAndColon: unexpectedBetweenAssociativityKeywordAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: Token.`identifier`(value))
  }
  /// Builds a `PrecedenceGroupAssociativitySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupAssociativitySyntax`.
  func buildPrecedenceGroupAssociativity(format: Format) -> PrecedenceGroupAssociativitySyntax {
    var result = PrecedenceGroupAssociativitySyntax(unexpectedBeforeAssociativityKeyword?.buildUnexpectedNodes(format: format), associativityKeyword: associativityKeyword.buildToken(format: format), unexpectedBetweenAssociativityKeywordAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format), value: value.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupAssociativity(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupAssociativity`.
  public func createPrecedenceGroupAssociativity() -> PrecedenceGroupAssociativity {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupAssociativity` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A custom `@` attribute.
public struct CustomAttribute: SyntaxBuildable, ExpressibleAsCustomAttribute {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAtSignToken: UnexpectedNodes?
  var atSignToken: Token
  var unexpectedBetweenAtSignTokenAndAttributeName: UnexpectedNodes?
  var attributeName: TypeBuildable
  var unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodes?
  var leftParen: Token?
  var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodes?
  var argumentList: TupleExprElementList?
  var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodes?
  var rightParen: Token?
  /// Creates a `CustomAttribute` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAtSignToken: 
  ///   - atSignToken: The `@` sign.
  ///   - unexpectedBetweenAtSignTokenAndAttributeName: 
  ///   - attributeName: The name of the attribute.
  ///   - unexpectedBetweenAttributeNameAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: ExpressibleAsTypeBuildable, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAtSignToken = unexpectedBeforeAtSignToken?.createUnexpectedNodes()
    self.atSignToken = atSignToken
    assert(atSignToken.text == #"@"#)
    self.unexpectedBetweenAtSignTokenAndAttributeName = unexpectedBetweenAtSignTokenAndAttributeName?.createUnexpectedNodes()
    self.attributeName = attributeName.createTypeBuildable()
    self.unexpectedBetweenAttributeNameAndLeftParen = unexpectedBetweenAttributeNameAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgumentList = unexpectedBetweenLeftParenAndArgumentList?.createUnexpectedNodes()
    self.argumentList = argumentList?.createTupleExprElementList()
    self.unexpectedBetweenArgumentListAndRightParen = unexpectedBetweenArgumentListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: ExpressibleAsTypeBuildable, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAtSignToken: unexpectedBeforeAtSignToken, atSignToken: atSignToken, unexpectedBetweenAtSignTokenAndAttributeName: unexpectedBetweenAtSignTokenAndAttributeName, attributeName: attributeName, unexpectedBetweenAttributeNameAndLeftParen: unexpectedBetweenAttributeNameAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen, rightParen: rightParen)
  }
  /// Builds a `CustomAttributeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CustomAttributeSyntax`.
  func buildCustomAttribute(format: Format) -> CustomAttributeSyntax {
    var result = CustomAttributeSyntax(unexpectedBeforeAtSignToken?.buildUnexpectedNodes(format: format), atSignToken: atSignToken.buildToken(format: format), unexpectedBetweenAtSignTokenAndAttributeName?.buildUnexpectedNodes(format: format), attributeName: attributeName.buildType(format: format), unexpectedBetweenAttributeNameAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen?.buildToken(format: format), unexpectedBetweenLeftParenAndArgumentList?.buildUnexpectedNodes(format: format), argumentList: argumentList?.buildTupleExprElementList(format: format), unexpectedBetweenArgumentListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCustomAttribute(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCustomAttribute`.
  public func createCustomAttribute() -> CustomAttribute {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CustomAttribute` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// An `@` attribute.
public struct Attribute: SyntaxBuildable, ExpressibleAsAttribute {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAtSignToken: UnexpectedNodes?
  var atSignToken: Token
  var unexpectedBetweenAtSignTokenAndAttributeName: UnexpectedNodes?
  var attributeName: Token
  var unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodes?
  var leftParen: Token?
  var unexpectedBetweenLeftParenAndArgument: UnexpectedNodes?
  var argument: SyntaxBuildable?
  var unexpectedBetweenArgumentAndRightParen: UnexpectedNodes?
  var rightParen: Token?
  var unexpectedBetweenRightParenAndTokenList: UnexpectedNodes?
  var tokenList: TokenList?
  /// Creates a `Attribute` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAtSignToken: 
  ///   - atSignToken: The `@` sign.
  ///   - unexpectedBetweenAtSignTokenAndAttributeName: 
  ///   - attributeName: The name of the attribute.
  ///   - unexpectedBetweenAttributeNameAndLeftParen: 
  ///   - leftParen: If the attribute takes arguments, the opening parenthesis.
  ///   - unexpectedBetweenLeftParenAndArgument: 
  ///   - argument: The arguments of the attribute. In case the attributetakes multiple arguments, they are gather in theappropriate takes first.
  ///   - unexpectedBetweenArgumentAndRightParen: 
  ///   - rightParen: If the attribute takes arguments, the closing parenthesis.
  ///   - unexpectedBetweenRightParenAndTokenList: 
  ///   - tokenList: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: Token, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgument: ExpressibleAsUnexpectedNodes? = nil, argument: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenArgumentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTokenList: ExpressibleAsUnexpectedNodes? = nil, tokenList: ExpressibleAsTokenList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAtSignToken = unexpectedBeforeAtSignToken?.createUnexpectedNodes()
    self.atSignToken = atSignToken
    assert(atSignToken.text == #"@"#)
    self.unexpectedBetweenAtSignTokenAndAttributeName = unexpectedBetweenAtSignTokenAndAttributeName?.createUnexpectedNodes()
    self.attributeName = attributeName
    self.unexpectedBetweenAttributeNameAndLeftParen = unexpectedBetweenAttributeNameAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgument = unexpectedBetweenLeftParenAndArgument?.createUnexpectedNodes()
    self.argument = argument?.createSyntaxBuildable()
    self.unexpectedBetweenArgumentAndRightParen = unexpectedBetweenArgumentAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.unexpectedBetweenRightParenAndTokenList = unexpectedBetweenRightParenAndTokenList?.createUnexpectedNodes()
    self.tokenList = tokenList?.createTokenList()
  }
  /// Builds a `AttributeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AttributeSyntax`.
  func buildAttribute(format: Format) -> AttributeSyntax {
    var result = AttributeSyntax(unexpectedBeforeAtSignToken?.buildUnexpectedNodes(format: format), atSignToken: atSignToken.buildToken(format: format), unexpectedBetweenAtSignTokenAndAttributeName?.buildUnexpectedNodes(format: format), attributeName: attributeName.buildToken(format: format), unexpectedBetweenAttributeNameAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen?.buildToken(format: format), unexpectedBetweenLeftParenAndArgument?.buildUnexpectedNodes(format: format), argument: argument?.buildSyntax(format: format), unexpectedBetweenArgumentAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen?.buildToken(format: format), unexpectedBetweenRightParenAndTokenList?.buildUnexpectedNodes(format: format), tokenList: tokenList?.buildTokenList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAttribute(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAttribute`.
  public func createAttribute() -> Attribute {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `Attribute` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The availability argument for the _specialize attribute
public struct AvailabilityEntry: SyntaxBuildable, ExpressibleAsAvailabilityEntry {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabel: UnexpectedNodes?
  var label: Token
  var unexpectedBetweenLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndAvailabilityList: UnexpectedNodes?
  var availabilityList: AvailabilitySpecList
  var unexpectedBetweenAvailabilityListAndSemicolon: UnexpectedNodes?
  var semicolon: Token
  /// Creates a `AvailabilityEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndAvailabilityList: 
  ///   - availabilityList: 
  ///   - unexpectedBetweenAvailabilityListAndSemicolon: 
  ///   - semicolon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndAvailabilityList: ExpressibleAsUnexpectedNodes? = nil, availabilityList: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilityListAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token = Token.`semicolon`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndAvailabilityList = unexpectedBetweenColonAndAvailabilityList?.createUnexpectedNodes()
    self.availabilityList = availabilityList.createAvailabilitySpecList()
    self.unexpectedBetweenAvailabilityListAndSemicolon = unexpectedBetweenAvailabilityListAndSemicolon?.createUnexpectedNodes()
    self.semicolon = semicolon
    assert(semicolon.text == #";"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndAvailabilityList: ExpressibleAsUnexpectedNodes? = nil, availabilityList: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilityListAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token = Token.`semicolon`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndAvailabilityList: unexpectedBetweenColonAndAvailabilityList, availabilityList: availabilityList, unexpectedBetweenAvailabilityListAndSemicolon: unexpectedBetweenAvailabilityListAndSemicolon, semicolon: semicolon)
  }
  /// Builds a `AvailabilityEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityEntrySyntax`.
  func buildAvailabilityEntry(format: Format) -> AvailabilityEntrySyntax {
    var result = AvailabilityEntrySyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: label.buildToken(format: format), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndAvailabilityList?.buildUnexpectedNodes(format: format), availabilityList: availabilityList.buildAvailabilitySpecList(format: format), unexpectedBetweenAvailabilityListAndSemicolon?.buildUnexpectedNodes(format: format), semicolon: semicolon.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityEntry(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityEntry`.
  public func createAvailabilityEntry() -> AvailabilityEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A labeled argument for the `@_specialize` attribute like`exported: true`
public struct LabeledSpecializeEntry: SyntaxBuildable, ExpressibleAsLabeledSpecializeEntry, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabel: UnexpectedNodes?
  var label: Token
  var unexpectedBetweenLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndValue: UnexpectedNodes?
  var value: Token
  var unexpectedBetweenValueAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `LabeledSpecializeEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: The value for this argument
  ///   - unexpectedBetweenValueAndTrailingComma: 
  ///   - trailingComma: A trailing comma if this argument is followed by another one
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token, unexpectedBetweenValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValue = unexpectedBetweenColonAndValue?.createUnexpectedNodes()
    self.value = value
    self.unexpectedBetweenValueAndTrailingComma = unexpectedBetweenValueAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token, unexpectedBetweenValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: value, unexpectedBetweenValueAndTrailingComma: unexpectedBetweenValueAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `LabeledSpecializeEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LabeledSpecializeEntrySyntax`.
  func buildLabeledSpecializeEntry(format: Format) -> LabeledSpecializeEntrySyntax {
    var result = LabeledSpecializeEntrySyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: label.buildToken(format: format), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format), value: value.buildToken(format: format), unexpectedBetweenValueAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildLabeledSpecializeEntry(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsLabeledSpecializeEntry`.
  public func createLabeledSpecializeEntry() -> LabeledSpecializeEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `LabeledSpecializeEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A labeled argument for the `@_specialize` attribute with a functiondecl value like`target: myFunc(_:)`
public struct TargetFunctionEntry: SyntaxBuildable, ExpressibleAsTargetFunctionEntry, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabel: UnexpectedNodes?
  var label: Token
  var unexpectedBetweenLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndDeclname: UnexpectedNodes?
  var declname: DeclName
  var unexpectedBetweenDeclnameAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `TargetFunctionEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndDeclname: 
  ///   - declname: The value for this argument
  ///   - unexpectedBetweenDeclnameAndTrailingComma: 
  ///   - trailingComma: A trailing comma if this argument is followed by another one
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndDeclname: ExpressibleAsUnexpectedNodes? = nil, declname: ExpressibleAsDeclName, unexpectedBetweenDeclnameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndDeclname = unexpectedBetweenColonAndDeclname?.createUnexpectedNodes()
    self.declname = declname.createDeclName()
    self.unexpectedBetweenDeclnameAndTrailingComma = unexpectedBetweenDeclnameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndDeclname: ExpressibleAsUnexpectedNodes? = nil, declname: ExpressibleAsDeclName, unexpectedBetweenDeclnameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndDeclname: unexpectedBetweenColonAndDeclname, declname: declname, unexpectedBetweenDeclnameAndTrailingComma: unexpectedBetweenDeclnameAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `TargetFunctionEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TargetFunctionEntrySyntax`.
  func buildTargetFunctionEntry(format: Format) -> TargetFunctionEntrySyntax {
    var result = TargetFunctionEntrySyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: label.buildToken(format: format), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndDeclname?.buildUnexpectedNodes(format: format), declname: declname.buildDeclName(format: format), unexpectedBetweenDeclnameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTargetFunctionEntry(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTargetFunctionEntry`.
  public func createTargetFunctionEntry() -> TargetFunctionEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TargetFunctionEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The argument for the `@_dynamic_replacement` or `@_private`attribute of the form `for: "function()"` or `sourceFile:"Src.swift"`
public struct NamedAttributeStringArgument: SyntaxBuildable, ExpressibleAsNamedAttributeStringArgument {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeNameTok: UnexpectedNodes?
  var nameTok: Token
  var unexpectedBetweenNameTokAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndStringOrDeclname: UnexpectedNodes?
  var stringOrDeclname: SyntaxBuildable
  /// Creates a `NamedAttributeStringArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeNameTok: 
  ///   - nameTok: The label of the argument
  ///   - unexpectedBetweenNameTokAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndStringOrDeclname: 
  ///   - stringOrDeclname: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeNameTok: ExpressibleAsUnexpectedNodes? = nil, nameTok: Token, unexpectedBetweenNameTokAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndStringOrDeclname: ExpressibleAsUnexpectedNodes? = nil, stringOrDeclname: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeNameTok = unexpectedBeforeNameTok?.createUnexpectedNodes()
    self.nameTok = nameTok
    self.unexpectedBetweenNameTokAndColon = unexpectedBetweenNameTokAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndStringOrDeclname = unexpectedBetweenColonAndStringOrDeclname?.createUnexpectedNodes()
    self.stringOrDeclname = stringOrDeclname.createSyntaxBuildable()
  }
  /// Builds a `NamedAttributeStringArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `NamedAttributeStringArgumentSyntax`.
  func buildNamedAttributeStringArgument(format: Format) -> NamedAttributeStringArgumentSyntax {
    var result = NamedAttributeStringArgumentSyntax(unexpectedBeforeNameTok?.buildUnexpectedNodes(format: format), nameTok: nameTok.buildToken(format: format), unexpectedBetweenNameTokAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndStringOrDeclname?.buildUnexpectedNodes(format: format), stringOrDeclname: stringOrDeclname.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildNamedAttributeStringArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsNamedAttributeStringArgument`.
  public func createNamedAttributeStringArgument() -> NamedAttributeStringArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `NamedAttributeStringArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeclName: SyntaxBuildable, ExpressibleAsDeclName {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDeclBaseName: UnexpectedNodes?
  var declBaseName: SyntaxBuildable
  var unexpectedBetweenDeclBaseNameAndDeclNameArguments: UnexpectedNodes?
  var declNameArguments: DeclNameArguments?
  /// Creates a `DeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeclBaseName: 
  ///   - declBaseName: The base name of the protocol's requirement.
  ///   - unexpectedBetweenDeclBaseNameAndDeclNameArguments: 
  ///   - declNameArguments: The argument labels of the protocol's requirement if itis a function requirement.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDeclBaseName: ExpressibleAsUnexpectedNodes? = nil, declBaseName: ExpressibleAsSyntaxBuildable, unexpectedBetweenDeclBaseNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDeclBaseName = unexpectedBeforeDeclBaseName?.createUnexpectedNodes()
    self.declBaseName = declBaseName.createSyntaxBuildable()
    self.unexpectedBetweenDeclBaseNameAndDeclNameArguments = unexpectedBetweenDeclBaseNameAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `DeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameSyntax`.
  func buildDeclName(format: Format) -> DeclNameSyntax {
    var result = DeclNameSyntax(unexpectedBeforeDeclBaseName?.buildUnexpectedNodes(format: format), declBaseName: declBaseName.buildSyntax(format: format), unexpectedBetweenDeclBaseNameAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclName(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclName`.
  public func createDeclName() -> DeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The arguments for the `@_implements` attribute of the form`Type, methodName(arg1Label:arg2Label:)`
public struct ImplementsAttributeArguments: SyntaxBuildable, ExpressibleAsImplementsAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeType: UnexpectedNodes?
  var type: TypeBuildable
  var unexpectedBetweenTypeAndComma: UnexpectedNodes?
  var comma: Token
  var unexpectedBetweenCommaAndDeclBaseName: UnexpectedNodes?
  var declBaseName: Token
  var unexpectedBetweenDeclBaseNameAndDeclNameArguments: UnexpectedNodes?
  var declNameArguments: DeclNameArguments?
  /// Creates a `ImplementsAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: The type for which the method with this attributeimplements a requirement.
  ///   - unexpectedBetweenTypeAndComma: 
  ///   - comma: The comma separating the type and method name
  ///   - unexpectedBetweenCommaAndDeclBaseName: 
  ///   - declBaseName: The base name of the protocol's requirement.
  ///   - unexpectedBetweenDeclBaseNameAndDeclNameArguments: 
  ///   - declNameArguments: The argument labels of the protocol's requirement if itis a function requirement.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndDeclBaseName: ExpressibleAsUnexpectedNodes? = nil, declBaseName: Token, unexpectedBetweenDeclBaseNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
    self.unexpectedBetweenTypeAndComma = unexpectedBetweenTypeAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma.text == #","#)
    self.unexpectedBetweenCommaAndDeclBaseName = unexpectedBetweenCommaAndDeclBaseName?.createUnexpectedNodes()
    self.declBaseName = declBaseName
    self.unexpectedBetweenDeclBaseNameAndDeclNameArguments = unexpectedBetweenDeclBaseNameAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `ImplementsAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImplementsAttributeArgumentsSyntax`.
  func buildImplementsAttributeArguments(format: Format) -> ImplementsAttributeArgumentsSyntax {
    var result = ImplementsAttributeArgumentsSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: type.buildType(format: format), unexpectedBetweenTypeAndComma?.buildUnexpectedNodes(format: format), comma: comma.buildToken(format: format), unexpectedBetweenCommaAndDeclBaseName?.buildUnexpectedNodes(format: format), declBaseName: declBaseName.buildToken(format: format), unexpectedBetweenDeclBaseNameAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildImplementsAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsImplementsAttributeArguments`.
  public func createImplementsAttributeArguments() -> ImplementsAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ImplementsAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A piece of an Objective-C selector. Either consisting of just anidentifier for a nullary selector, an identifier and a colon for alabeled argument or just a colon for an unlabeled argument
public struct ObjCSelectorPiece: SyntaxBuildable, ExpressibleAsObjCSelectorPiece {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token?
  var unexpectedBetweenNameAndColon: UnexpectedNodes?
  var colon: Token?
  /// Creates a `ObjCSelectorPiece` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndColon = unexpectedBetweenNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String?, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: name.map {
      Token.`identifier`($0)
    }, unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon, colon: colon)
  }
  /// Builds a `ObjCSelectorPieceSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjCSelectorPieceSyntax`.
  func buildObjCSelectorPiece(format: Format) -> ObjCSelectorPieceSyntax {
    var result = ObjCSelectorPieceSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name?.buildToken(format: format), unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format), colon: colon?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildObjCSelectorPiece(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsObjCSelectorPiece`.
  public func createObjCSelectorPiece() -> ObjCSelectorPiece {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ObjCSelectorPiece` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The arguments for the `@differentiable` attribute: an optionaldifferentiability kind, an optional differentiability parameter clause,and an optional 'where' clause.
public struct DifferentiableAttributeArguments: SyntaxBuildable, ExpressibleAsDifferentiableAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDiffKind: UnexpectedNodes?
  var diffKind: Token?
  var unexpectedBetweenDiffKindAndDiffKindComma: UnexpectedNodes?
  var diffKindComma: Token?
  var unexpectedBetweenDiffKindCommaAndDiffParams: UnexpectedNodes?
  var diffParams: DifferentiabilityParamsClause?
  var unexpectedBetweenDiffParamsAndDiffParamsComma: UnexpectedNodes?
  var diffParamsComma: Token?
  var unexpectedBetweenDiffParamsCommaAndWhereClause: UnexpectedNodes?
  var whereClause: GenericWhereClause?
  /// Creates a `DifferentiableAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDiffKind: 
  ///   - diffKind: 
  ///   - unexpectedBetweenDiffKindAndDiffKindComma: 
  ///   - diffKindComma: The comma following the differentiability kind, if it exists.
  ///   - unexpectedBetweenDiffKindCommaAndDiffParams: 
  ///   - diffParams: 
  ///   - unexpectedBetweenDiffParamsAndDiffParamsComma: 
  ///   - diffParamsComma: The comma following the differentiability parameters clause,if it exists.
  ///   - unexpectedBetweenDiffParamsCommaAndWhereClause: 
  ///   - whereClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDiffKind: ExpressibleAsUnexpectedNodes? = nil, diffKind: Token? = nil, unexpectedBetweenDiffKindAndDiffKindComma: ExpressibleAsUnexpectedNodes? = nil, diffKindComma: Token? = nil, unexpectedBetweenDiffKindCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil, unexpectedBetweenDiffParamsAndDiffParamsComma: ExpressibleAsUnexpectedNodes? = nil, diffParamsComma: Token? = nil, unexpectedBetweenDiffParamsCommaAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDiffKind = unexpectedBeforeDiffKind?.createUnexpectedNodes()
    self.diffKind = diffKind
    assert(diffKind == nil || diffKind!.text == #"forward"# || diffKind!.text == #"reverse"# || diffKind!.text == #"linear"#)
    self.unexpectedBetweenDiffKindAndDiffKindComma = unexpectedBetweenDiffKindAndDiffKindComma?.createUnexpectedNodes()
    self.diffKindComma = diffKindComma
    assert(diffKindComma == nil || diffKindComma!.text == #","#)
    self.unexpectedBetweenDiffKindCommaAndDiffParams = unexpectedBetweenDiffKindCommaAndDiffParams?.createUnexpectedNodes()
    self.diffParams = diffParams?.createDifferentiabilityParamsClause()
    self.unexpectedBetweenDiffParamsAndDiffParamsComma = unexpectedBetweenDiffParamsAndDiffParamsComma?.createUnexpectedNodes()
    self.diffParamsComma = diffParamsComma
    assert(diffParamsComma == nil || diffParamsComma!.text == #","#)
    self.unexpectedBetweenDiffParamsCommaAndWhereClause = unexpectedBetweenDiffParamsCommaAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createGenericWhereClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDiffKind: ExpressibleAsUnexpectedNodes? = nil, diffKind: String?, unexpectedBetweenDiffKindAndDiffKindComma: ExpressibleAsUnexpectedNodes? = nil, diffKindComma: Token? = nil, unexpectedBetweenDiffKindCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil, unexpectedBetweenDiffParamsAndDiffParamsComma: ExpressibleAsUnexpectedNodes? = nil, diffParamsComma: Token? = nil, unexpectedBetweenDiffParamsCommaAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDiffKind: unexpectedBeforeDiffKind, diffKind: diffKind.map {
      Token.`identifier`($0)
    }, unexpectedBetweenDiffKindAndDiffKindComma: unexpectedBetweenDiffKindAndDiffKindComma, diffKindComma: diffKindComma, unexpectedBetweenDiffKindCommaAndDiffParams: unexpectedBetweenDiffKindCommaAndDiffParams, diffParams: diffParams, unexpectedBetweenDiffParamsAndDiffParamsComma: unexpectedBetweenDiffParamsAndDiffParamsComma, diffParamsComma: diffParamsComma, unexpectedBetweenDiffParamsCommaAndWhereClause: unexpectedBetweenDiffParamsCommaAndWhereClause, whereClause: whereClause)
  }
  /// Builds a `DifferentiableAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiableAttributeArgumentsSyntax`.
  func buildDifferentiableAttributeArguments(format: Format) -> DifferentiableAttributeArgumentsSyntax {
    var result = DifferentiableAttributeArgumentsSyntax(unexpectedBeforeDiffKind?.buildUnexpectedNodes(format: format), diffKind: diffKind?.buildToken(format: format), unexpectedBetweenDiffKindAndDiffKindComma?.buildUnexpectedNodes(format: format), diffKindComma: diffKindComma?.buildToken(format: format), unexpectedBetweenDiffKindCommaAndDiffParams?.buildUnexpectedNodes(format: format), diffParams: diffParams?.buildDifferentiabilityParamsClause(format: format), unexpectedBetweenDiffParamsAndDiffParamsComma?.buildUnexpectedNodes(format: format), diffParamsComma: diffParamsComma?.buildToken(format: format), unexpectedBetweenDiffParamsCommaAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: whereClause?.buildGenericWhereClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiableAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiableAttributeArguments`.
  public func createDifferentiableAttributeArguments() -> DifferentiableAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiableAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A clause containing differentiability parameters.
public struct DifferentiabilityParamsClause: SyntaxBuildable, ExpressibleAsDifferentiabilityParamsClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWrtLabel: UnexpectedNodes?
  var wrtLabel: Token
  var unexpectedBetweenWrtLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndParameters: UnexpectedNodes?
  var parameters: SyntaxBuildable
  /// Creates a `DifferentiabilityParamsClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrtLabel: 
  ///   - wrtLabel: The "wrt" label.
  ///   - unexpectedBetweenWrtLabelAndColon: 
  ///   - colon: The colon separating "wrt" and the parameter list.
  ///   - unexpectedBetweenColonAndParameters: 
  ///   - parameters: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWrtLabel: ExpressibleAsUnexpectedNodes? = nil, wrtLabel: Token, unexpectedBetweenWrtLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndParameters: ExpressibleAsUnexpectedNodes? = nil, parameters: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWrtLabel = unexpectedBeforeWrtLabel?.createUnexpectedNodes()
    self.wrtLabel = wrtLabel
    assert(wrtLabel.text == #"wrt"#)
    self.unexpectedBetweenWrtLabelAndColon = unexpectedBetweenWrtLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndParameters = unexpectedBetweenColonAndParameters?.createUnexpectedNodes()
    self.parameters = parameters.createSyntaxBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWrtLabel: ExpressibleAsUnexpectedNodes? = nil, wrtLabel: String, unexpectedBetweenWrtLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndParameters: ExpressibleAsUnexpectedNodes? = nil, parameters: ExpressibleAsSyntaxBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWrtLabel: unexpectedBeforeWrtLabel, wrtLabel: Token.`identifier`(wrtLabel), unexpectedBetweenWrtLabelAndColon: unexpectedBetweenWrtLabelAndColon, colon: colon, unexpectedBetweenColonAndParameters: unexpectedBetweenColonAndParameters, parameters: parameters)
  }
  /// Builds a `DifferentiabilityParamsClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamsClauseSyntax`.
  func buildDifferentiabilityParamsClause(format: Format) -> DifferentiabilityParamsClauseSyntax {
    var result = DifferentiabilityParamsClauseSyntax(unexpectedBeforeWrtLabel?.buildUnexpectedNodes(format: format), wrtLabel: wrtLabel.buildToken(format: format), unexpectedBetweenWrtLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndParameters?.buildUnexpectedNodes(format: format), parameters: parameters.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiabilityParamsClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParamsClause`.
  public func createDifferentiabilityParamsClause() -> DifferentiabilityParamsClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParamsClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The differentiability parameters.
public struct DifferentiabilityParams: SyntaxBuildable, ExpressibleAsDifferentiabilityParams {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndDiffParams: UnexpectedNodes?
  var diffParams: DifferentiabilityParamList
  var unexpectedBetweenDiffParamsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `DifferentiabilityParams` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndDiffParams: 
  ///   - diffParams: The parameters for differentiation.
  ///   - unexpectedBetweenDiffParamsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamList, unexpectedBetweenDiffParamsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndDiffParams = unexpectedBetweenLeftParenAndDiffParams?.createUnexpectedNodes()
    self.diffParams = diffParams.createDifferentiabilityParamList()
    self.unexpectedBetweenDiffParamsAndRightParen = unexpectedBetweenDiffParamsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `DifferentiabilityParamsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamsSyntax`.
  func buildDifferentiabilityParams(format: Format) -> DifferentiabilityParamsSyntax {
    var result = DifferentiabilityParamsSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndDiffParams?.buildUnexpectedNodes(format: format), diffParams: diffParams.buildDifferentiabilityParamList(format: format), unexpectedBetweenDiffParamsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiabilityParams(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParams`.
  public func createDifferentiabilityParams() -> DifferentiabilityParams {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParams` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A differentiability parameter: either the "self" identifier, a functionparameter name, or a function parameter index.
public struct DifferentiabilityParam: SyntaxBuildable, ExpressibleAsDifferentiabilityParam, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeParameter: UnexpectedNodes?
  var parameter: SyntaxBuildable
  var unexpectedBetweenParameterAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `DifferentiabilityParam` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeParameter: 
  ///   - parameter: 
  ///   - unexpectedBetweenParameterAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsSyntaxBuildable, unexpectedBetweenParameterAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeParameter = unexpectedBeforeParameter?.createUnexpectedNodes()
    self.parameter = parameter.createSyntaxBuildable()
    self.unexpectedBetweenParameterAndTrailingComma = unexpectedBetweenParameterAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `DifferentiabilityParamSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamSyntax`.
  func buildDifferentiabilityParam(format: Format) -> DifferentiabilityParamSyntax {
    var result = DifferentiabilityParamSyntax(unexpectedBeforeParameter?.buildUnexpectedNodes(format: format), parameter: parameter.buildSyntax(format: format), unexpectedBetweenParameterAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiabilityParam(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParam`.
  public func createDifferentiabilityParam() -> DifferentiabilityParam {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParam` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The arguments for the '@derivative(of:)' and '@transpose(of:)'attributes: the 'of:' label, the original declaration name, and anoptional differentiability parameter list.
public struct DerivativeRegistrationAttributeArguments: SyntaxBuildable, ExpressibleAsDerivativeRegistrationAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeOfLabel: UnexpectedNodes?
  var ofLabel: Token
  var unexpectedBetweenOfLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndOriginalDeclName: UnexpectedNodes?
  var originalDeclName: QualifiedDeclName
  var unexpectedBetweenOriginalDeclNameAndPeriod: UnexpectedNodes?
  var period: Token?
  var unexpectedBetweenPeriodAndAccessorKind: UnexpectedNodes?
  var accessorKind: Token?
  var unexpectedBetweenAccessorKindAndComma: UnexpectedNodes?
  var comma: Token?
  var unexpectedBetweenCommaAndDiffParams: UnexpectedNodes?
  var diffParams: DifferentiabilityParamsClause?
  /// Creates a `DerivativeRegistrationAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOfLabel: 
  ///   - ofLabel: The "of" label.
  ///   - unexpectedBetweenOfLabelAndColon: 
  ///   - colon: The colon separating the "of" label and the originaldeclaration name.
  ///   - unexpectedBetweenColonAndOriginalDeclName: 
  ///   - originalDeclName: The referenced original declaration name.
  ///   - unexpectedBetweenOriginalDeclNameAndPeriod: 
  ///   - period: The period separating the original declaration name and theaccessor name.
  ///   - unexpectedBetweenPeriodAndAccessorKind: 
  ///   - accessorKind: The accessor name.
  ///   - unexpectedBetweenAccessorKindAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndDiffParams: 
  ///   - diffParams: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOfLabel: ExpressibleAsUnexpectedNodes? = nil, ofLabel: Token, unexpectedBetweenOfLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOriginalDeclName: ExpressibleAsUnexpectedNodes? = nil, originalDeclName: ExpressibleAsQualifiedDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token? = nil, unexpectedBetweenPeriodAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token? = nil, unexpectedBetweenAccessorKindAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeOfLabel = unexpectedBeforeOfLabel?.createUnexpectedNodes()
    self.ofLabel = ofLabel
    assert(ofLabel.text == #"of"#)
    self.unexpectedBetweenOfLabelAndColon = unexpectedBetweenOfLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndOriginalDeclName = unexpectedBetweenColonAndOriginalDeclName?.createUnexpectedNodes()
    self.originalDeclName = originalDeclName.createQualifiedDeclName()
    self.unexpectedBetweenOriginalDeclNameAndPeriod = unexpectedBetweenOriginalDeclNameAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period == nil || period!.text == #"."#)
    self.unexpectedBetweenPeriodAndAccessorKind = unexpectedBetweenPeriodAndAccessorKind?.createUnexpectedNodes()
    self.accessorKind = accessorKind
    assert(accessorKind == nil || accessorKind!.text == #"get"# || accessorKind!.text == #"set"#)
    self.unexpectedBetweenAccessorKindAndComma = unexpectedBetweenAccessorKindAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma == nil || comma!.text == #","#)
    self.unexpectedBetweenCommaAndDiffParams = unexpectedBetweenCommaAndDiffParams?.createUnexpectedNodes()
    self.diffParams = diffParams?.createDifferentiabilityParamsClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOfLabel: ExpressibleAsUnexpectedNodes? = nil, ofLabel: String, unexpectedBetweenOfLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOriginalDeclName: ExpressibleAsUnexpectedNodes? = nil, originalDeclName: ExpressibleAsQualifiedDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token? = nil, unexpectedBetweenPeriodAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: String?, unexpectedBetweenAccessorKindAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOfLabel: unexpectedBeforeOfLabel, ofLabel: Token.`identifier`(ofLabel), unexpectedBetweenOfLabelAndColon: unexpectedBetweenOfLabelAndColon, colon: colon, unexpectedBetweenColonAndOriginalDeclName: unexpectedBetweenColonAndOriginalDeclName, originalDeclName: originalDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: unexpectedBetweenOriginalDeclNameAndPeriod, period: period, unexpectedBetweenPeriodAndAccessorKind: unexpectedBetweenPeriodAndAccessorKind, accessorKind: accessorKind.map {
      Token.`identifier`($0)
    }, unexpectedBetweenAccessorKindAndComma: unexpectedBetweenAccessorKindAndComma, comma: comma, unexpectedBetweenCommaAndDiffParams: unexpectedBetweenCommaAndDiffParams, diffParams: diffParams)
  }
  /// Builds a `DerivativeRegistrationAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DerivativeRegistrationAttributeArgumentsSyntax`.
  func buildDerivativeRegistrationAttributeArguments(format: Format) -> DerivativeRegistrationAttributeArgumentsSyntax {
    var result = DerivativeRegistrationAttributeArgumentsSyntax(unexpectedBeforeOfLabel?.buildUnexpectedNodes(format: format), ofLabel: ofLabel.buildToken(format: format), unexpectedBetweenOfLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndOriginalDeclName?.buildUnexpectedNodes(format: format), originalDeclName: originalDeclName.buildQualifiedDeclName(format: format), unexpectedBetweenOriginalDeclNameAndPeriod?.buildUnexpectedNodes(format: format), period: period?.buildToken(format: format), unexpectedBetweenPeriodAndAccessorKind?.buildUnexpectedNodes(format: format), accessorKind: accessorKind?.buildToken(format: format), unexpectedBetweenAccessorKindAndComma?.buildUnexpectedNodes(format: format), comma: comma?.buildToken(format: format), unexpectedBetweenCommaAndDiffParams?.buildUnexpectedNodes(format: format), diffParams: diffParams?.buildDifferentiabilityParamsClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDerivativeRegistrationAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDerivativeRegistrationAttributeArguments`.
  public func createDerivativeRegistrationAttributeArguments() -> DerivativeRegistrationAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DerivativeRegistrationAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// An optionally qualified function declaration name (e.g. `+(_:_:)`,`A.B.C.foo(_:_:)`).
public struct QualifiedDeclName: SyntaxBuildable, ExpressibleAsQualifiedDeclName {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBaseType: UnexpectedNodes?
  var baseType: TypeBuildable?
  var unexpectedBetweenBaseTypeAndDot: UnexpectedNodes?
  var dot: Token?
  var unexpectedBetweenDotAndName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndArguments: UnexpectedNodes?
  var arguments: DeclNameArguments?
  /// Creates a `QualifiedDeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: The base type of the qualified name, optionally specified.
  ///   - unexpectedBetweenBaseTypeAndDot: 
  ///   - dot: 
  ///   - unexpectedBetweenDotAndName: 
  ///   - name: The base name of the referenced function.
  ///   - unexpectedBetweenNameAndArguments: 
  ///   - arguments: The argument labels of the referenced function, optionallyspecified.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenBaseTypeAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil, unexpectedBetweenDotAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBaseType = unexpectedBeforeBaseType?.createUnexpectedNodes()
    self.baseType = baseType?.createTypeBuildable()
    self.unexpectedBetweenBaseTypeAndDot = unexpectedBetweenBaseTypeAndDot?.createUnexpectedNodes()
    self.dot = dot
    assert(dot == nil || dot!.text == #"."# || dot!.text == #"."#)
    self.unexpectedBetweenDotAndName = unexpectedBetweenDotAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndArguments = unexpectedBetweenNameAndArguments?.createUnexpectedNodes()
    self.arguments = arguments?.createDeclNameArguments()
  }
  /// Builds a `QualifiedDeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `QualifiedDeclNameSyntax`.
  func buildQualifiedDeclName(format: Format) -> QualifiedDeclNameSyntax {
    var result = QualifiedDeclNameSyntax(unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format), baseType: baseType?.buildType(format: format), unexpectedBetweenBaseTypeAndDot?.buildUnexpectedNodes(format: format), dot: dot?.buildToken(format: format), unexpectedBetweenDotAndName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndArguments?.buildUnexpectedNodes(format: format), arguments: arguments?.buildDeclNameArguments(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildQualifiedDeclName(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsQualifiedDeclName`.
  public func createQualifiedDeclName() -> QualifiedDeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `QualifiedDeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A function declaration name (e.g. `foo(_:_:)`).
public struct FunctionDeclName: SyntaxBuildable, ExpressibleAsFunctionDeclName {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: SyntaxBuildable
  var unexpectedBetweenNameAndArguments: UnexpectedNodes?
  var arguments: DeclNameArguments?
  /// Creates a `FunctionDeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: The base name of the referenced function.
  ///   - unexpectedBetweenNameAndArguments: 
  ///   - arguments: The argument labels of the referenced function, optionallyspecified.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsSyntaxBuildable, unexpectedBetweenNameAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name.createSyntaxBuildable()
    self.unexpectedBetweenNameAndArguments = unexpectedBetweenNameAndArguments?.createUnexpectedNodes()
    self.arguments = arguments?.createDeclNameArguments()
  }
  /// Builds a `FunctionDeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionDeclNameSyntax`.
  func buildFunctionDeclName(format: Format) -> FunctionDeclNameSyntax {
    var result = FunctionDeclNameSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildSyntax(format: format), unexpectedBetweenNameAndArguments?.buildUnexpectedNodes(format: format), arguments: arguments?.buildDeclNameArguments(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildFunctionDeclName(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionDeclName`.
  public func createFunctionDeclName() -> FunctionDeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionDeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A collection of arguments for the `@_backDeploy` attribute
public struct BackDeployAttributeSpecList: SyntaxBuildable, ExpressibleAsBackDeployAttributeSpecList {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBeforeLabel: UnexpectedNodes?
  var beforeLabel: Token
  var unexpectedBetweenBeforeLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndVersionList: UnexpectedNodes?
  var versionList: BackDeployVersionList
  /// Creates a `BackDeployAttributeSpecList` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBeforeLabel: 
  ///   - beforeLabel: The "before" label.
  ///   - unexpectedBetweenBeforeLabelAndColon: 
  ///   - colon: The colon separating "before" and the parameter list.
  ///   - unexpectedBetweenColonAndVersionList: 
  ///   - versionList: The list of OS versions in which the declaration became ABIstable.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, beforeLabel: Token, unexpectedBetweenBeforeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndVersionList: ExpressibleAsUnexpectedNodes? = nil, versionList: ExpressibleAsBackDeployVersionList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBeforeLabel = unexpectedBeforeBeforeLabel?.createUnexpectedNodes()
    self.beforeLabel = beforeLabel
    assert(beforeLabel.text == #"before"#)
    self.unexpectedBetweenBeforeLabelAndColon = unexpectedBetweenBeforeLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndVersionList = unexpectedBetweenColonAndVersionList?.createUnexpectedNodes()
    self.versionList = versionList.createBackDeployVersionList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, beforeLabel: String, unexpectedBetweenBeforeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndVersionList: ExpressibleAsUnexpectedNodes? = nil, versionList: ExpressibleAsBackDeployVersionList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBeforeLabel: unexpectedBeforeBeforeLabel, beforeLabel: Token.`identifier`(beforeLabel), unexpectedBetweenBeforeLabelAndColon: unexpectedBetweenBeforeLabelAndColon, colon: colon, unexpectedBetweenColonAndVersionList: unexpectedBetweenColonAndVersionList, versionList: versionList)
  }
  /// Builds a `BackDeployAttributeSpecListSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BackDeployAttributeSpecListSyntax`.
  func buildBackDeployAttributeSpecList(format: Format) -> BackDeployAttributeSpecListSyntax {
    var result = BackDeployAttributeSpecListSyntax(unexpectedBeforeBeforeLabel?.buildUnexpectedNodes(format: format), beforeLabel: beforeLabel.buildToken(format: format), unexpectedBetweenBeforeLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndVersionList?.buildUnexpectedNodes(format: format), versionList: versionList.buildBackDeployVersionList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildBackDeployAttributeSpecList(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsBackDeployAttributeSpecList`.
  public func createBackDeployAttributeSpecList() -> BackDeployAttributeSpecList {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `BackDeployAttributeSpecList` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A single platform/version pair in a `@_backDeploy` attribute,e.g. `iOS 10.1`.
public struct BackDeployVersionArgument: SyntaxBuildable, ExpressibleAsBackDeployVersionArgument {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAvailabilityVersionRestriction: UnexpectedNodes?
  var availabilityVersionRestriction: AvailabilityVersionRestriction
  var unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `BackDeployVersionArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAvailabilityVersionRestriction: 
  ///   - availabilityVersionRestriction: 
  ///   - unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: 
  ///   - trailingComma: A trailing comma if the argument is followed by anotherargument
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAvailabilityVersionRestriction: ExpressibleAsUnexpectedNodes? = nil, availabilityVersionRestriction: ExpressibleAsAvailabilityVersionRestriction, unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAvailabilityVersionRestriction = unexpectedBeforeAvailabilityVersionRestriction?.createUnexpectedNodes()
    self.availabilityVersionRestriction = availabilityVersionRestriction.createAvailabilityVersionRestriction()
    self.unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma = unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `BackDeployVersionArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BackDeployVersionArgumentSyntax`.
  func buildBackDeployVersionArgument(format: Format) -> BackDeployVersionArgumentSyntax {
    var result = BackDeployVersionArgumentSyntax(unexpectedBeforeAvailabilityVersionRestriction?.buildUnexpectedNodes(format: format), availabilityVersionRestriction: availabilityVersionRestriction.buildAvailabilityVersionRestriction(format: format), unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildBackDeployVersionArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsBackDeployVersionArgument`.
  public func createBackDeployVersionArgument() -> BackDeployVersionArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `BackDeployVersionArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The arguments for the '@_opaqueReturnTypeOf()'.
public struct OpaqueReturnTypeOfAttributeArguments: SyntaxBuildable, ExpressibleAsOpaqueReturnTypeOfAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeMangledName: UnexpectedNodes?
  var mangledName: Token
  var unexpectedBetweenMangledNameAndComma: UnexpectedNodes?
  var comma: Token
  var unexpectedBetweenCommaAndOrdinal: UnexpectedNodes?
  var ordinal: Token
  /// Creates a `OpaqueReturnTypeOfAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMangledName: 
  ///   - mangledName: The mangled name of a declaration.
  ///   - unexpectedBetweenMangledNameAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndOrdinal: 
  ///   - ordinal: The ordinal corresponding to the 'some' keyword that introduced this opaque type.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeMangledName: ExpressibleAsUnexpectedNodes? = nil, mangledName: Token, unexpectedBetweenMangledNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndOrdinal: ExpressibleAsUnexpectedNodes? = nil, ordinal: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeMangledName = unexpectedBeforeMangledName?.createUnexpectedNodes()
    self.mangledName = mangledName
    self.unexpectedBetweenMangledNameAndComma = unexpectedBetweenMangledNameAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma.text == #","#)
    self.unexpectedBetweenCommaAndOrdinal = unexpectedBetweenCommaAndOrdinal?.createUnexpectedNodes()
    self.ordinal = ordinal
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMangledName: ExpressibleAsUnexpectedNodes? = nil, mangledName: String, unexpectedBetweenMangledNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndOrdinal: ExpressibleAsUnexpectedNodes? = nil, ordinal: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMangledName: unexpectedBeforeMangledName, mangledName: Token.`stringLiteral`(mangledName), unexpectedBetweenMangledNameAndComma: unexpectedBetweenMangledNameAndComma, comma: comma, unexpectedBetweenCommaAndOrdinal: unexpectedBetweenCommaAndOrdinal, ordinal: Token.`integerLiteral`(ordinal))
  }
  /// Builds a `OpaqueReturnTypeOfAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OpaqueReturnTypeOfAttributeArgumentsSyntax`.
  func buildOpaqueReturnTypeOfAttributeArguments(format: Format) -> OpaqueReturnTypeOfAttributeArgumentsSyntax {
    var result = OpaqueReturnTypeOfAttributeArgumentsSyntax(unexpectedBeforeMangledName?.buildUnexpectedNodes(format: format), mangledName: mangledName.buildToken(format: format), unexpectedBetweenMangledNameAndComma?.buildUnexpectedNodes(format: format), comma: comma.buildToken(format: format), unexpectedBetweenCommaAndOrdinal?.buildUnexpectedNodes(format: format), ordinal: ordinal.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildOpaqueReturnTypeOfAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOpaqueReturnTypeOfAttributeArguments`.
  public func createOpaqueReturnTypeOfAttributeArguments() -> OpaqueReturnTypeOfAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OpaqueReturnTypeOfAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The arguments for the '@convention(...)'.
public struct ConventionAttributeArguments: SyntaxBuildable, ExpressibleAsConventionAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeConventionLabel: UnexpectedNodes?
  var conventionLabel: Token
  var unexpectedBetweenConventionLabelAndComma: UnexpectedNodes?
  var comma: Token?
  var unexpectedBetweenCommaAndCTypeLabel: UnexpectedNodes?
  var cTypeLabel: Token?
  var unexpectedBetweenCTypeLabelAndColon: UnexpectedNodes?
  var colon: Token?
  var unexpectedBetweenColonAndCTypeString: UnexpectedNodes?
  var cTypeString: Token?
  /// Creates a `ConventionAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeConventionLabel: 
  ///   - conventionLabel: The convention label.
  ///   - unexpectedBetweenConventionLabelAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndCTypeLabel: 
  ///   - cTypeLabel: 
  ///   - unexpectedBetweenCTypeLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndCTypeString: 
  ///   - cTypeString: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeConventionLabel: ExpressibleAsUnexpectedNodes? = nil, conventionLabel: Token, unexpectedBetweenConventionLabelAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndCTypeLabel: ExpressibleAsUnexpectedNodes? = nil, cTypeLabel: Token? = nil, unexpectedBetweenCTypeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndCTypeString: ExpressibleAsUnexpectedNodes? = nil, cTypeString: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeConventionLabel = unexpectedBeforeConventionLabel?.createUnexpectedNodes()
    self.conventionLabel = conventionLabel
    assert(conventionLabel.text == #"block"# || conventionLabel.text == #"c"# || conventionLabel.text == #"objc_method"# || conventionLabel.text == #"thin"# || conventionLabel.text == #"thick"#)
    self.unexpectedBetweenConventionLabelAndComma = unexpectedBetweenConventionLabelAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma == nil || comma!.text == #","#)
    self.unexpectedBetweenCommaAndCTypeLabel = unexpectedBetweenCommaAndCTypeLabel?.createUnexpectedNodes()
    self.cTypeLabel = cTypeLabel
    assert(cTypeLabel == nil || cTypeLabel!.text == #"cType"#)
    self.unexpectedBetweenCTypeLabelAndColon = unexpectedBetweenCTypeLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndCTypeString = unexpectedBetweenColonAndCTypeString?.createUnexpectedNodes()
    self.cTypeString = cTypeString
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeConventionLabel: ExpressibleAsUnexpectedNodes? = nil, conventionLabel: String, unexpectedBetweenConventionLabelAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndCTypeLabel: ExpressibleAsUnexpectedNodes? = nil, cTypeLabel: String?, unexpectedBetweenCTypeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndCTypeString: ExpressibleAsUnexpectedNodes? = nil, cTypeString: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeConventionLabel: unexpectedBeforeConventionLabel, conventionLabel: Token.`identifier`(conventionLabel), unexpectedBetweenConventionLabelAndComma: unexpectedBetweenConventionLabelAndComma, comma: comma, unexpectedBetweenCommaAndCTypeLabel: unexpectedBetweenCommaAndCTypeLabel, cTypeLabel: cTypeLabel.map {
      Token.`identifier`($0)
    }, unexpectedBetweenCTypeLabelAndColon: unexpectedBetweenCTypeLabelAndColon, colon: colon, unexpectedBetweenColonAndCTypeString: unexpectedBetweenColonAndCTypeString, cTypeString: cTypeString.map {
      Token.`stringLiteral`($0)
    })
  }
  /// Builds a `ConventionAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConventionAttributeArgumentsSyntax`.
  func buildConventionAttributeArguments(format: Format) -> ConventionAttributeArgumentsSyntax {
    var result = ConventionAttributeArgumentsSyntax(unexpectedBeforeConventionLabel?.buildUnexpectedNodes(format: format), conventionLabel: conventionLabel.buildToken(format: format), unexpectedBetweenConventionLabelAndComma?.buildUnexpectedNodes(format: format), comma: comma?.buildToken(format: format), unexpectedBetweenCommaAndCTypeLabel?.buildUnexpectedNodes(format: format), cTypeLabel: cTypeLabel?.buildToken(format: format), unexpectedBetweenCTypeLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon?.buildToken(format: format), unexpectedBetweenColonAndCTypeString?.buildUnexpectedNodes(format: format), cTypeString: cTypeString?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConventionAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConventionAttributeArguments`.
  public func createConventionAttributeArguments() -> ConventionAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConventionAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// The arguments for the '@convention(witness_method: ...)'.
public struct ConventionWitnessMethodAttributeArguments: SyntaxBuildable, ExpressibleAsConventionWitnessMethodAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWitnessMethodLabel: UnexpectedNodes?
  var witnessMethodLabel: Token
  var unexpectedBetweenWitnessMethodLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndProtocolName: UnexpectedNodes?
  var protocolName: Token
  /// Creates a `ConventionWitnessMethodAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWitnessMethodLabel: 
  ///   - witnessMethodLabel: 
  ///   - unexpectedBetweenWitnessMethodLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndProtocolName: 
  ///   - protocolName: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWitnessMethodLabel: ExpressibleAsUnexpectedNodes? = nil, witnessMethodLabel: Token, unexpectedBetweenWitnessMethodLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndProtocolName: ExpressibleAsUnexpectedNodes? = nil, protocolName: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWitnessMethodLabel = unexpectedBeforeWitnessMethodLabel?.createUnexpectedNodes()
    self.witnessMethodLabel = witnessMethodLabel
    self.unexpectedBetweenWitnessMethodLabelAndColon = unexpectedBetweenWitnessMethodLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndProtocolName = unexpectedBetweenColonAndProtocolName?.createUnexpectedNodes()
    self.protocolName = protocolName
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWitnessMethodLabel: ExpressibleAsUnexpectedNodes? = nil, witnessMethodLabel: String, unexpectedBetweenWitnessMethodLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndProtocolName: ExpressibleAsUnexpectedNodes? = nil, protocolName: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWitnessMethodLabel: unexpectedBeforeWitnessMethodLabel, witnessMethodLabel: Token.`identifier`(witnessMethodLabel), unexpectedBetweenWitnessMethodLabelAndColon: unexpectedBetweenWitnessMethodLabelAndColon, colon: colon, unexpectedBetweenColonAndProtocolName: unexpectedBetweenColonAndProtocolName, protocolName: Token.`identifier`(protocolName))
  }
  /// Builds a `ConventionWitnessMethodAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConventionWitnessMethodAttributeArgumentsSyntax`.
  func buildConventionWitnessMethodAttributeArguments(format: Format) -> ConventionWitnessMethodAttributeArgumentsSyntax {
    var result = ConventionWitnessMethodAttributeArgumentsSyntax(unexpectedBeforeWitnessMethodLabel?.buildUnexpectedNodes(format: format), witnessMethodLabel: witnessMethodLabel.buildToken(format: format), unexpectedBetweenWitnessMethodLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndProtocolName?.buildUnexpectedNodes(format: format), protocolName: protocolName.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConventionWitnessMethodAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConventionWitnessMethodAttributeArguments`.
  public func createConventionWitnessMethodAttributeArguments() -> ConventionWitnessMethodAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConventionWitnessMethodAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct LabeledStmt: StmtBuildable, ExpressibleAsLabeledStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabelName: UnexpectedNodes?
  var labelName: Token
  var unexpectedBetweenLabelNameAndLabelColon: UnexpectedNodes?
  var labelColon: Token
  var unexpectedBetweenLabelColonAndStatement: UnexpectedNodes?
  var statement: StmtBuildable
  /// Creates a `LabeledStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabelName: 
  ///   - labelName: 
  ///   - unexpectedBetweenLabelNameAndLabelColon: 
  ///   - labelColon: 
  ///   - unexpectedBetweenLabelColonAndStatement: 
  ///   - statement: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: Token, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token = Token.`colon`, unexpectedBetweenLabelColonAndStatement: ExpressibleAsUnexpectedNodes? = nil, statement: ExpressibleAsStmtBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabelName = unexpectedBeforeLabelName?.createUnexpectedNodes()
    self.labelName = labelName
    self.unexpectedBetweenLabelNameAndLabelColon = unexpectedBetweenLabelNameAndLabelColon?.createUnexpectedNodes()
    self.labelColon = labelColon
    assert(labelColon.text == #":"#)
    self.unexpectedBetweenLabelColonAndStatement = unexpectedBetweenLabelColonAndStatement?.createUnexpectedNodes()
    self.statement = statement.createStmtBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: String, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token = Token.`colon`, unexpectedBetweenLabelColonAndStatement: ExpressibleAsUnexpectedNodes? = nil, statement: ExpressibleAsStmtBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName, labelName: Token.`identifier`(labelName), unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon, labelColon: labelColon, unexpectedBetweenLabelColonAndStatement: unexpectedBetweenLabelColonAndStatement, statement: statement)
  }
  /// Builds a `LabeledStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LabeledStmtSyntax`.
  func buildLabeledStmt(format: Format) -> LabeledStmtSyntax {
    var result = LabeledStmtSyntax(unexpectedBeforeLabelName?.buildUnexpectedNodes(format: format), labelName: labelName.buildToken(format: format), unexpectedBetweenLabelNameAndLabelColon?.buildUnexpectedNodes(format: format), labelColon: labelColon.buildToken(format: format), unexpectedBetweenLabelColonAndStatement?.buildUnexpectedNodes(format: format), statement: statement.buildStmt(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildLabeledStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsLabeledStmt`.
  public func createLabeledStmt() -> LabeledStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `LabeledStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ContinueStmt: StmtBuildable, ExpressibleAsContinueStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeContinueKeyword: UnexpectedNodes?
  var continueKeyword: Token
  var unexpectedBetweenContinueKeywordAndLabel: UnexpectedNodes?
  var label: Token?
  /// Creates a `ContinueStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeContinueKeyword: 
  ///   - continueKeyword: 
  ///   - unexpectedBetweenContinueKeywordAndLabel: 
  ///   - label: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeContinueKeyword: ExpressibleAsUnexpectedNodes? = nil, continueKeyword: Token = Token.`continue`, unexpectedBetweenContinueKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeContinueKeyword = unexpectedBeforeContinueKeyword?.createUnexpectedNodes()
    self.continueKeyword = continueKeyword
    assert(continueKeyword.text == #"continue"#)
    self.unexpectedBetweenContinueKeywordAndLabel = unexpectedBetweenContinueKeywordAndLabel?.createUnexpectedNodes()
    self.label = label
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContinueKeyword: ExpressibleAsUnexpectedNodes? = nil, continueKeyword: Token = Token.`continue`, unexpectedBetweenContinueKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeContinueKeyword: unexpectedBeforeContinueKeyword, continueKeyword: continueKeyword, unexpectedBetweenContinueKeywordAndLabel: unexpectedBetweenContinueKeywordAndLabel, label: label.map {
      Token.`identifier`($0)
    })
  }
  /// Builds a `ContinueStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ContinueStmtSyntax`.
  func buildContinueStmt(format: Format) -> ContinueStmtSyntax {
    var result = ContinueStmtSyntax(unexpectedBeforeContinueKeyword?.buildUnexpectedNodes(format: format), continueKeyword: continueKeyword.buildToken(format: format), unexpectedBetweenContinueKeywordAndLabel?.buildUnexpectedNodes(format: format), label: label?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildContinueStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsContinueStmt`.
  public func createContinueStmt() -> ContinueStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ContinueStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct WhileStmt: StmtBuildable, ExpressibleAsWhileStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWhileKeyword: UnexpectedNodes?
  var whileKeyword: Token
  var unexpectedBetweenWhileKeywordAndConditions: UnexpectedNodes?
  var conditions: ConditionElementList
  var unexpectedBetweenConditionsAndBody: UnexpectedNodes?
  var body: CodeBlock
  /// Creates a `WhileStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhileKeyword: 
  ///   - whileKeyword: 
  ///   - unexpectedBetweenWhileKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWhileKeyword = unexpectedBeforeWhileKeyword?.createUnexpectedNodes()
    self.whileKeyword = whileKeyword
    assert(whileKeyword.text == #"while"#)
    self.unexpectedBetweenWhileKeywordAndConditions = unexpectedBetweenWhileKeywordAndConditions?.createUnexpectedNodes()
    self.conditions = conditions.createConditionElementList()
    self.unexpectedBetweenConditionsAndBody = unexpectedBetweenConditionsAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWhileKeyword: unexpectedBeforeWhileKeyword, whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndConditions: unexpectedBetweenWhileKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody, body: bodyBuilder())
  }
  /// Builds a `WhileStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WhileStmtSyntax`.
  func buildWhileStmt(format: Format) -> WhileStmtSyntax {
    var result = WhileStmtSyntax(unexpectedBeforeWhileKeyword?.buildUnexpectedNodes(format: format), whileKeyword: whileKeyword.buildToken(format: format), unexpectedBetweenWhileKeywordAndConditions?.buildUnexpectedNodes(format: format), conditions: conditions.buildConditionElementList(format: format), unexpectedBetweenConditionsAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildWhileStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsWhileStmt`.
  public func createWhileStmt() -> WhileStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `WhileStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeferStmt: StmtBuildable, ExpressibleAsDeferStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDeferKeyword: UnexpectedNodes?
  var deferKeyword: Token
  var unexpectedBetweenDeferKeywordAndBody: UnexpectedNodes?
  var body: CodeBlock
  /// Creates a `DeferStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeferKeyword: 
  ///   - deferKeyword: 
  ///   - unexpectedBetweenDeferKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDeferKeyword: ExpressibleAsUnexpectedNodes? = nil, deferKeyword: Token = Token.`defer`, unexpectedBetweenDeferKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDeferKeyword = unexpectedBeforeDeferKeyword?.createUnexpectedNodes()
    self.deferKeyword = deferKeyword
    assert(deferKeyword.text == #"defer"#)
    self.unexpectedBetweenDeferKeywordAndBody = unexpectedBetweenDeferKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDeferKeyword: ExpressibleAsUnexpectedNodes? = nil, deferKeyword: Token = Token.`defer`, unexpectedBetweenDeferKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDeferKeyword: unexpectedBeforeDeferKeyword, deferKeyword: deferKeyword, unexpectedBetweenDeferKeywordAndBody: unexpectedBetweenDeferKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `DeferStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeferStmtSyntax`.
  func buildDeferStmt(format: Format) -> DeferStmtSyntax {
    var result = DeferStmtSyntax(unexpectedBeforeDeferKeyword?.buildUnexpectedNodes(format: format), deferKeyword: deferKeyword.buildToken(format: format), unexpectedBetweenDeferKeywordAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildDeferStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeferStmt`.
  public func createDeferStmt() -> DeferStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DeferStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ExpressionStmt: StmtBuildable, ExpressibleAsExpressionStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `ExpressionStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `ExpressionStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionStmtSyntax`.
  func buildExpressionStmt(format: Format) -> ExpressionStmtSyntax {
    var result = ExpressionStmtSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildExpressionStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionStmt`.
  public func createExpressionStmt() -> ExpressionStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ExpressionStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct RepeatWhileStmt: StmtBuildable, ExpressibleAsRepeatWhileStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeRepeatKeyword: UnexpectedNodes?
  var repeatKeyword: Token
  var unexpectedBetweenRepeatKeywordAndBody: UnexpectedNodes?
  var body: CodeBlock
  var unexpectedBetweenBodyAndWhileKeyword: UnexpectedNodes?
  var whileKeyword: Token
  var unexpectedBetweenWhileKeywordAndCondition: UnexpectedNodes?
  var condition: ExprBuildable
  /// Creates a `RepeatWhileStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeRepeatKeyword: 
  ///   - repeatKeyword: 
  ///   - unexpectedBetweenRepeatKeywordAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndWhileKeyword: 
  ///   - whileKeyword: 
  ///   - unexpectedBetweenWhileKeywordAndCondition: 
  ///   - condition: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeRepeatKeyword: ExpressibleAsUnexpectedNodes? = nil, repeatKeyword: Token = Token.`repeat`, unexpectedBetweenRepeatKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeRepeatKeyword = unexpectedBeforeRepeatKeyword?.createUnexpectedNodes()
    self.repeatKeyword = repeatKeyword
    assert(repeatKeyword.text == #"repeat"#)
    self.unexpectedBetweenRepeatKeywordAndBody = unexpectedBetweenRepeatKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
    self.unexpectedBetweenBodyAndWhileKeyword = unexpectedBetweenBodyAndWhileKeyword?.createUnexpectedNodes()
    self.whileKeyword = whileKeyword
    assert(whileKeyword.text == #"while"#)
    self.unexpectedBetweenWhileKeywordAndCondition = unexpectedBetweenWhileKeywordAndCondition?.createUnexpectedNodes()
    self.condition = condition.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRepeatKeyword: ExpressibleAsUnexpectedNodes? = nil, repeatKeyword: Token = Token.`repeat`, unexpectedBetweenRepeatKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeRepeatKeyword: unexpectedBeforeRepeatKeyword, repeatKeyword: repeatKeyword, unexpectedBetweenRepeatKeywordAndBody: unexpectedBetweenRepeatKeywordAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndWhileKeyword: unexpectedBetweenBodyAndWhileKeyword, whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndCondition: unexpectedBetweenWhileKeywordAndCondition, condition: condition)
  }
  /// Builds a `RepeatWhileStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `RepeatWhileStmtSyntax`.
  func buildRepeatWhileStmt(format: Format) -> RepeatWhileStmtSyntax {
    var result = RepeatWhileStmtSyntax(unexpectedBeforeRepeatKeyword?.buildUnexpectedNodes(format: format), repeatKeyword: repeatKeyword.buildToken(format: format), unexpectedBetweenRepeatKeywordAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format), unexpectedBetweenBodyAndWhileKeyword?.buildUnexpectedNodes(format: format), whileKeyword: whileKeyword.buildToken(format: format), unexpectedBetweenWhileKeywordAndCondition?.buildUnexpectedNodes(format: format), condition: condition.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildRepeatWhileStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsRepeatWhileStmt`.
  public func createRepeatWhileStmt() -> RepeatWhileStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `RepeatWhileStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct GuardStmt: StmtBuildable, ExpressibleAsGuardStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeGuardKeyword: UnexpectedNodes?
  var guardKeyword: Token
  var unexpectedBetweenGuardKeywordAndConditions: UnexpectedNodes?
  var conditions: ConditionElementList
  var unexpectedBetweenConditionsAndElseKeyword: UnexpectedNodes?
  var elseKeyword: Token
  var unexpectedBetweenElseKeywordAndBody: UnexpectedNodes?
  var body: CodeBlock
  /// Creates a `GuardStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeGuardKeyword: 
  ///   - guardKeyword: 
  ///   - unexpectedBetweenGuardKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeGuardKeyword: ExpressibleAsUnexpectedNodes? = nil, guardKeyword: Token = Token.`guard`, unexpectedBetweenGuardKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeGuardKeyword = unexpectedBeforeGuardKeyword?.createUnexpectedNodes()
    self.guardKeyword = guardKeyword
    assert(guardKeyword.text == #"guard"#)
    self.unexpectedBetweenGuardKeywordAndConditions = unexpectedBetweenGuardKeywordAndConditions?.createUnexpectedNodes()
    self.conditions = conditions.createConditionElementList()
    self.unexpectedBetweenConditionsAndElseKeyword = unexpectedBetweenConditionsAndElseKeyword?.createUnexpectedNodes()
    self.elseKeyword = elseKeyword
    assert(elseKeyword.text == #"else"#)
    self.unexpectedBetweenElseKeywordAndBody = unexpectedBetweenElseKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeGuardKeyword: ExpressibleAsUnexpectedNodes? = nil, guardKeyword: Token = Token.`guard`, unexpectedBetweenGuardKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeGuardKeyword: unexpectedBeforeGuardKeyword, guardKeyword: guardKeyword, unexpectedBetweenGuardKeywordAndConditions: unexpectedBetweenGuardKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndElseKeyword: unexpectedBetweenConditionsAndElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `GuardStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GuardStmtSyntax`.
  func buildGuardStmt(format: Format) -> GuardStmtSyntax {
    var result = GuardStmtSyntax(unexpectedBeforeGuardKeyword?.buildUnexpectedNodes(format: format), guardKeyword: guardKeyword.buildToken(format: format), unexpectedBetweenGuardKeywordAndConditions?.buildUnexpectedNodes(format: format), conditions: conditions.buildConditionElementList(format: format), unexpectedBetweenConditionsAndElseKeyword?.buildUnexpectedNodes(format: format), elseKeyword: elseKeyword.buildToken(format: format), unexpectedBetweenElseKeywordAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildGuardStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsGuardStmt`.
  public func createGuardStmt() -> GuardStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `GuardStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct WhereClause: SyntaxBuildable, ExpressibleAsWhereClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWhereKeyword: UnexpectedNodes?
  var whereKeyword: Token
  var unexpectedBetweenWhereKeywordAndGuardResult: UnexpectedNodes?
  var guardResult: ExprBuildable
  /// Creates a `WhereClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhereKeyword: 
  ///   - whereKeyword: 
  ///   - unexpectedBetweenWhereKeywordAndGuardResult: 
  ///   - guardResult: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndGuardResult: ExpressibleAsUnexpectedNodes? = nil, guardResult: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWhereKeyword = unexpectedBeforeWhereKeyword?.createUnexpectedNodes()
    self.whereKeyword = whereKeyword
    assert(whereKeyword.text == #"where"#)
    self.unexpectedBetweenWhereKeywordAndGuardResult = unexpectedBetweenWhereKeywordAndGuardResult?.createUnexpectedNodes()
    self.guardResult = guardResult.createExprBuildable()
  }
  /// Builds a `WhereClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WhereClauseSyntax`.
  func buildWhereClause(format: Format) -> WhereClauseSyntax {
    var result = WhereClauseSyntax(unexpectedBeforeWhereKeyword?.buildUnexpectedNodes(format: format), whereKeyword: whereKeyword.buildToken(format: format), unexpectedBetweenWhereKeywordAndGuardResult?.buildUnexpectedNodes(format: format), guardResult: guardResult.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildWhereClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsWhereClause`.
  public func createWhereClause() -> WhereClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `WhereClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ForInStmt: StmtBuildable, ExpressibleAsForInStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeForKeyword: UnexpectedNodes?
  var forKeyword: Token
  var unexpectedBetweenForKeywordAndTryKeyword: UnexpectedNodes?
  var tryKeyword: Token?
  var unexpectedBetweenTryKeywordAndAwaitKeyword: UnexpectedNodes?
  var awaitKeyword: Token?
  var unexpectedBetweenAwaitKeywordAndCaseKeyword: UnexpectedNodes?
  var caseKeyword: Token?
  var unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodes?
  var pattern: PatternBuildable
  var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  var typeAnnotation: TypeAnnotation?
  var unexpectedBetweenTypeAnnotationAndInKeyword: UnexpectedNodes?
  var inKeyword: Token
  var unexpectedBetweenInKeywordAndSequenceExpr: UnexpectedNodes?
  var sequenceExpr: ExprBuildable
  var unexpectedBetweenSequenceExprAndWhereClause: UnexpectedNodes?
  var whereClause: WhereClause?
  var unexpectedBetweenWhereClauseAndBody: UnexpectedNodes?
  var body: CodeBlock
  /// Creates a `ForInStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeForKeyword: 
  ///   - forKeyword: 
  ///   - unexpectedBetweenForKeywordAndTryKeyword: 
  ///   - tryKeyword: 
  ///   - unexpectedBetweenTryKeywordAndAwaitKeyword: 
  ///   - awaitKeyword: 
  ///   - unexpectedBetweenAwaitKeywordAndCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInKeyword: 
  ///   - inKeyword: 
  ///   - unexpectedBetweenInKeywordAndSequenceExpr: 
  ///   - sequenceExpr: 
  ///   - unexpectedBetweenSequenceExprAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeForKeyword: ExpressibleAsUnexpectedNodes? = nil, forKeyword: Token = Token.`for`, unexpectedBetweenForKeywordAndTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token? = nil, unexpectedBetweenTryKeywordAndAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: Token? = nil, unexpectedBetweenAwaitKeywordAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token? = nil, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInKeyword: ExpressibleAsUnexpectedNodes? = nil, inKeyword: Token = Token.`in`, unexpectedBetweenInKeywordAndSequenceExpr: ExpressibleAsUnexpectedNodes? = nil, sequenceExpr: ExpressibleAsExprBuildable, unexpectedBetweenSequenceExprAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeForKeyword = unexpectedBeforeForKeyword?.createUnexpectedNodes()
    self.forKeyword = forKeyword
    assert(forKeyword.text == #"for"#)
    self.unexpectedBetweenForKeywordAndTryKeyword = unexpectedBetweenForKeywordAndTryKeyword?.createUnexpectedNodes()
    self.tryKeyword = tryKeyword
    assert(tryKeyword == nil || tryKeyword!.text == #"try"#)
    self.unexpectedBetweenTryKeywordAndAwaitKeyword = unexpectedBetweenTryKeywordAndAwaitKeyword?.createUnexpectedNodes()
    self.awaitKeyword = awaitKeyword
    assert(awaitKeyword == nil || awaitKeyword!.text == #"await"#)
    self.unexpectedBetweenAwaitKeywordAndCaseKeyword = unexpectedBetweenAwaitKeywordAndCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword == nil || caseKeyword!.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndPattern = unexpectedBetweenCaseKeywordAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInKeyword = unexpectedBetweenTypeAnnotationAndInKeyword?.createUnexpectedNodes()
    self.inKeyword = inKeyword
    assert(inKeyword.text == #"in"#)
    self.unexpectedBetweenInKeywordAndSequenceExpr = unexpectedBetweenInKeywordAndSequenceExpr?.createUnexpectedNodes()
    self.sequenceExpr = sequenceExpr.createExprBuildable()
    self.unexpectedBetweenSequenceExprAndWhereClause = unexpectedBetweenSequenceExprAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createWhereClause()
    self.unexpectedBetweenWhereClauseAndBody = unexpectedBetweenWhereClauseAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeForKeyword: ExpressibleAsUnexpectedNodes? = nil, forKeyword: Token = Token.`for`, unexpectedBetweenForKeywordAndTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token? = nil, unexpectedBetweenTryKeywordAndAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: String?, unexpectedBetweenAwaitKeywordAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token? = nil, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInKeyword: ExpressibleAsUnexpectedNodes? = nil, inKeyword: Token = Token.`in`, unexpectedBetweenInKeywordAndSequenceExpr: ExpressibleAsUnexpectedNodes? = nil, sequenceExpr: ExpressibleAsExprBuildable, unexpectedBetweenSequenceExprAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeForKeyword: unexpectedBeforeForKeyword, forKeyword: forKeyword, unexpectedBetweenForKeywordAndTryKeyword: unexpectedBetweenForKeywordAndTryKeyword, tryKeyword: tryKeyword, unexpectedBetweenTryKeywordAndAwaitKeyword: unexpectedBetweenTryKeywordAndAwaitKeyword, awaitKeyword: awaitKeyword.map {
      Token.`identifier`($0)
    }, unexpectedBetweenAwaitKeywordAndCaseKeyword: unexpectedBetweenAwaitKeywordAndCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndPattern: unexpectedBetweenCaseKeywordAndPattern, pattern: pattern, unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation, typeAnnotation: typeAnnotation, unexpectedBetweenTypeAnnotationAndInKeyword: unexpectedBetweenTypeAnnotationAndInKeyword, inKeyword: inKeyword, unexpectedBetweenInKeywordAndSequenceExpr: unexpectedBetweenInKeywordAndSequenceExpr, sequenceExpr: sequenceExpr, unexpectedBetweenSequenceExprAndWhereClause: unexpectedBetweenSequenceExprAndWhereClause, whereClause: whereClause, unexpectedBetweenWhereClauseAndBody: unexpectedBetweenWhereClauseAndBody, body: bodyBuilder())
  }
  /// Builds a `ForInStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ForInStmtSyntax`.
  func buildForInStmt(format: Format) -> ForInStmtSyntax {
    var result = ForInStmtSyntax(unexpectedBeforeForKeyword?.buildUnexpectedNodes(format: format), forKeyword: forKeyword.buildToken(format: format), unexpectedBetweenForKeywordAndTryKeyword?.buildUnexpectedNodes(format: format), tryKeyword: tryKeyword?.buildToken(format: format), unexpectedBetweenTryKeywordAndAwaitKeyword?.buildUnexpectedNodes(format: format), awaitKeyword: awaitKeyword?.buildToken(format: format), unexpectedBetweenAwaitKeywordAndCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: caseKeyword?.buildToken(format: format), unexpectedBetweenCaseKeywordAndPattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format), unexpectedBetweenTypeAnnotationAndInKeyword?.buildUnexpectedNodes(format: format), inKeyword: inKeyword.buildToken(format: format), unexpectedBetweenInKeywordAndSequenceExpr?.buildUnexpectedNodes(format: format), sequenceExpr: sequenceExpr.buildExpr(format: format), unexpectedBetweenSequenceExprAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: whereClause?.buildWhereClause(format: format), unexpectedBetweenWhereClauseAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildForInStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsForInStmt`.
  public func createForInStmt() -> ForInStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ForInStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SwitchStmt: StmtBuildable, ExpressibleAsSwitchStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeSwitchKeyword: UnexpectedNodes?
  var switchKeyword: Token
  var unexpectedBetweenSwitchKeywordAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndLeftBrace: UnexpectedNodes?
  var leftBrace: Token
  var unexpectedBetweenLeftBraceAndCases: UnexpectedNodes?
  var cases: SwitchCaseList
  var unexpectedBetweenCasesAndRightBrace: UnexpectedNodes?
  var rightBrace: Token
  /// Creates a `SwitchStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSwitchKeyword: 
  ///   - switchKeyword: 
  ///   - unexpectedBetweenSwitchKeywordAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndCases: 
  ///   - cases: 
  ///   - unexpectedBetweenCasesAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSwitchKeyword: ExpressibleAsUnexpectedNodes? = nil, switchKeyword: Token = Token.`switch`, unexpectedBetweenSwitchKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndCases: ExpressibleAsUnexpectedNodes? = nil, cases: ExpressibleAsSwitchCaseList, unexpectedBetweenCasesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeSwitchKeyword = unexpectedBeforeSwitchKeyword?.createUnexpectedNodes()
    self.switchKeyword = switchKeyword
    assert(switchKeyword.text == #"switch"#)
    self.unexpectedBetweenSwitchKeywordAndExpression = unexpectedBetweenSwitchKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndLeftBrace = unexpectedBetweenExpressionAndLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndCases = unexpectedBetweenLeftBraceAndCases?.createUnexpectedNodes()
    self.cases = cases.createSwitchCaseList()
    self.unexpectedBetweenCasesAndRightBrace = unexpectedBetweenCasesAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSwitchKeyword: ExpressibleAsUnexpectedNodes? = nil, switchKeyword: Token = Token.`switch`, unexpectedBetweenSwitchKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndCases: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenCasesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @SwitchCaseListBuilder casesBuilder: () -> ExpressibleAsSwitchCaseList =  {
    SwitchCaseList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSwitchKeyword: unexpectedBeforeSwitchKeyword, switchKeyword: switchKeyword, unexpectedBetweenSwitchKeywordAndExpression: unexpectedBetweenSwitchKeywordAndExpression, expression: expression, unexpectedBetweenExpressionAndLeftBrace: unexpectedBetweenExpressionAndLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndCases: unexpectedBetweenLeftBraceAndCases, cases: casesBuilder(), unexpectedBetweenCasesAndRightBrace: unexpectedBetweenCasesAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `SwitchStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchStmtSyntax`.
  func buildSwitchStmt(format: Format) -> SwitchStmtSyntax {
    var result = SwitchStmtSyntax(unexpectedBeforeSwitchKeyword?.buildUnexpectedNodes(format: format), switchKeyword: switchKeyword.buildToken(format: format), unexpectedBetweenSwitchKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: leftBrace.buildToken(format: format), unexpectedBetweenLeftBraceAndCases?.buildUnexpectedNodes(format: format), cases: cases.buildSwitchCaseList(format: format), unexpectedBetweenCasesAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: rightBrace.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildSwitchStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchStmt`.
  public func createSwitchStmt() -> SwitchStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `SwitchStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DoStmt: StmtBuildable, ExpressibleAsDoStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDoKeyword: UnexpectedNodes?
  var doKeyword: Token
  var unexpectedBetweenDoKeywordAndBody: UnexpectedNodes?
  var body: CodeBlock
  var unexpectedBetweenBodyAndCatchClauses: UnexpectedNodes?
  var catchClauses: CatchClauseList?
  /// Creates a `DoStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDoKeyword: 
  ///   - doKeyword: 
  ///   - unexpectedBetweenDoKeywordAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndCatchClauses: 
  ///   - catchClauses: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDoKeyword: ExpressibleAsUnexpectedNodes? = nil, doKeyword: Token = Token.`do`, unexpectedBetweenDoKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndCatchClauses: ExpressibleAsUnexpectedNodes? = nil, catchClauses: ExpressibleAsCatchClauseList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDoKeyword = unexpectedBeforeDoKeyword?.createUnexpectedNodes()
    self.doKeyword = doKeyword
    assert(doKeyword.text == #"do"#)
    self.unexpectedBetweenDoKeywordAndBody = unexpectedBetweenDoKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
    self.unexpectedBetweenBodyAndCatchClauses = unexpectedBetweenBodyAndCatchClauses?.createUnexpectedNodes()
    self.catchClauses = catchClauses?.createCatchClauseList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDoKeyword: ExpressibleAsUnexpectedNodes? = nil, doKeyword: Token = Token.`do`, unexpectedBetweenDoKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndCatchClauses: ExpressibleAsUnexpectedNodes? = nil, catchClauses: ExpressibleAsCatchClauseList? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDoKeyword: unexpectedBeforeDoKeyword, doKeyword: doKeyword, unexpectedBetweenDoKeywordAndBody: unexpectedBetweenDoKeywordAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndCatchClauses: unexpectedBetweenBodyAndCatchClauses, catchClauses: catchClauses)
  }
  /// Builds a `DoStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DoStmtSyntax`.
  func buildDoStmt(format: Format) -> DoStmtSyntax {
    var result = DoStmtSyntax(unexpectedBeforeDoKeyword?.buildUnexpectedNodes(format: format), doKeyword: doKeyword.buildToken(format: format), unexpectedBetweenDoKeywordAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format), unexpectedBetweenBodyAndCatchClauses?.buildUnexpectedNodes(format: format), catchClauses: catchClauses?.buildCatchClauseList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildDoStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDoStmt`.
  public func createDoStmt() -> DoStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DoStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ReturnStmt: StmtBuildable, ExpressibleAsReturnStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeReturnKeyword: UnexpectedNodes?
  var returnKeyword: Token
  var unexpectedBetweenReturnKeywordAndExpression: UnexpectedNodes?
  var expression: ExprBuildable?
  /// Creates a `ReturnStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeReturnKeyword: 
  ///   - returnKeyword: 
  ///   - unexpectedBetweenReturnKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeReturnKeyword: ExpressibleAsUnexpectedNodes? = nil, returnKeyword: Token = Token.`return`, unexpectedBetweenReturnKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeReturnKeyword = unexpectedBeforeReturnKeyword?.createUnexpectedNodes()
    self.returnKeyword = returnKeyword
    assert(returnKeyword.text == #"return"#)
    self.unexpectedBetweenReturnKeywordAndExpression = unexpectedBetweenReturnKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression?.createExprBuildable()
  }
  /// Builds a `ReturnStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ReturnStmtSyntax`.
  func buildReturnStmt(format: Format) -> ReturnStmtSyntax {
    var result = ReturnStmtSyntax(unexpectedBeforeReturnKeyword?.buildUnexpectedNodes(format: format), returnKeyword: returnKeyword.buildToken(format: format), unexpectedBetweenReturnKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: expression?.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildReturnStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsReturnStmt`.
  public func createReturnStmt() -> ReturnStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ReturnStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct YieldStmt: StmtBuildable, ExpressibleAsYieldStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeYieldKeyword: UnexpectedNodes?
  var yieldKeyword: Token
  var unexpectedBetweenYieldKeywordAndYields: UnexpectedNodes?
  var yields: SyntaxBuildable
  /// Creates a `YieldStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeYieldKeyword: 
  ///   - yieldKeyword: 
  ///   - unexpectedBetweenYieldKeywordAndYields: 
  ///   - yields: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeYieldKeyword: ExpressibleAsUnexpectedNodes? = nil, yieldKeyword: Token = Token.`yield`, unexpectedBetweenYieldKeywordAndYields: ExpressibleAsUnexpectedNodes? = nil, yields: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeYieldKeyword = unexpectedBeforeYieldKeyword?.createUnexpectedNodes()
    self.yieldKeyword = yieldKeyword
    assert(yieldKeyword.text == #"yield"#)
    self.unexpectedBetweenYieldKeywordAndYields = unexpectedBetweenYieldKeywordAndYields?.createUnexpectedNodes()
    self.yields = yields.createSyntaxBuildable()
  }
  /// Builds a `YieldStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `YieldStmtSyntax`.
  func buildYieldStmt(format: Format) -> YieldStmtSyntax {
    var result = YieldStmtSyntax(unexpectedBeforeYieldKeyword?.buildUnexpectedNodes(format: format), yieldKeyword: yieldKeyword.buildToken(format: format), unexpectedBetweenYieldKeywordAndYields?.buildUnexpectedNodes(format: format), yields: yields.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildYieldStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsYieldStmt`.
  public func createYieldStmt() -> YieldStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `YieldStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct YieldList: SyntaxBuildable, ExpressibleAsYieldList {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndElementList: UnexpectedNodes?
  var elementList: ExprList
  var unexpectedBetweenElementListAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  var unexpectedBetweenTrailingCommaAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `YieldList` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElementList: 
  ///   - elementList: 
  ///   - unexpectedBetweenElementListAndTrailingComma: 
  ///   - trailingComma: 
  ///   - unexpectedBetweenTrailingCommaAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, elementList: ExpressibleAsExprList, unexpectedBetweenElementListAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil, unexpectedBetweenTrailingCommaAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElementList = unexpectedBetweenLeftParenAndElementList?.createUnexpectedNodes()
    self.elementList = elementList.createExprList()
    self.unexpectedBetweenElementListAndTrailingComma = unexpectedBetweenElementListAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.unexpectedBetweenTrailingCommaAndRightParen = unexpectedBetweenTrailingCommaAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementListAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil, unexpectedBetweenTrailingCommaAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @ExprListBuilder elementListBuilder: () -> ExpressibleAsExprList =  {
    ExprList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElementList: unexpectedBetweenLeftParenAndElementList, elementList: elementListBuilder(), unexpectedBetweenElementListAndTrailingComma: unexpectedBetweenElementListAndTrailingComma, trailingComma: trailingComma, unexpectedBetweenTrailingCommaAndRightParen: unexpectedBetweenTrailingCommaAndRightParen, rightParen: rightParen)
  }
  /// Builds a `YieldListSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `YieldListSyntax`.
  func buildYieldList(format: Format) -> YieldListSyntax {
    var result = YieldListSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndElementList?.buildUnexpectedNodes(format: format), elementList: elementList.buildExprList(format: format), unexpectedBetweenElementListAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format), unexpectedBetweenTrailingCommaAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildYieldList(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsYieldList`.
  public func createYieldList() -> YieldList {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `YieldList` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct FallthroughStmt: StmtBuildable, ExpressibleAsFallthroughStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeFallthroughKeyword: UnexpectedNodes?
  var fallthroughKeyword: Token
  /// Creates a `FallthroughStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFallthroughKeyword: 
  ///   - fallthroughKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeFallthroughKeyword: ExpressibleAsUnexpectedNodes? = nil, fallthroughKeyword: Token = Token.`fallthrough`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeFallthroughKeyword = unexpectedBeforeFallthroughKeyword?.createUnexpectedNodes()
    self.fallthroughKeyword = fallthroughKeyword
    assert(fallthroughKeyword.text == #"fallthrough"#)
  }
  /// Builds a `FallthroughStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FallthroughStmtSyntax`.
  func buildFallthroughStmt(format: Format) -> FallthroughStmtSyntax {
    var result = FallthroughStmtSyntax(unexpectedBeforeFallthroughKeyword?.buildUnexpectedNodes(format: format), fallthroughKeyword: fallthroughKeyword.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildFallthroughStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsFallthroughStmt`.
  public func createFallthroughStmt() -> FallthroughStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `FallthroughStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct BreakStmt: StmtBuildable, ExpressibleAsBreakStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBreakKeyword: UnexpectedNodes?
  var breakKeyword: Token
  var unexpectedBetweenBreakKeywordAndLabel: UnexpectedNodes?
  var label: Token?
  /// Creates a `BreakStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBreakKeyword: 
  ///   - breakKeyword: 
  ///   - unexpectedBetweenBreakKeywordAndLabel: 
  ///   - label: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBreakKeyword: ExpressibleAsUnexpectedNodes? = nil, breakKeyword: Token = Token.`break`, unexpectedBetweenBreakKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBreakKeyword = unexpectedBeforeBreakKeyword?.createUnexpectedNodes()
    self.breakKeyword = breakKeyword
    assert(breakKeyword.text == #"break"#)
    self.unexpectedBetweenBreakKeywordAndLabel = unexpectedBetweenBreakKeywordAndLabel?.createUnexpectedNodes()
    self.label = label
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBreakKeyword: ExpressibleAsUnexpectedNodes? = nil, breakKeyword: Token = Token.`break`, unexpectedBetweenBreakKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBreakKeyword: unexpectedBeforeBreakKeyword, breakKeyword: breakKeyword, unexpectedBetweenBreakKeywordAndLabel: unexpectedBetweenBreakKeywordAndLabel, label: label.map {
      Token.`identifier`($0)
    })
  }
  /// Builds a `BreakStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BreakStmtSyntax`.
  func buildBreakStmt(format: Format) -> BreakStmtSyntax {
    var result = BreakStmtSyntax(unexpectedBeforeBreakKeyword?.buildUnexpectedNodes(format: format), breakKeyword: breakKeyword.buildToken(format: format), unexpectedBetweenBreakKeywordAndLabel?.buildUnexpectedNodes(format: format), label: label?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildBreakStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsBreakStmt`.
  public func createBreakStmt() -> BreakStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `BreakStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ConditionElement: SyntaxBuildable, ExpressibleAsConditionElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeCondition: UnexpectedNodes?
  var condition: SyntaxBuildable
  var unexpectedBetweenConditionAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `ConditionElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCondition: 
  ///   - condition: 
  ///   - unexpectedBetweenConditionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsSyntaxBuildable, unexpectedBetweenConditionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeCondition = unexpectedBeforeCondition?.createUnexpectedNodes()
    self.condition = condition.createSyntaxBuildable()
    self.unexpectedBetweenConditionAndTrailingComma = unexpectedBetweenConditionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `ConditionElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConditionElementSyntax`.
  func buildConditionElement(format: Format) -> ConditionElementSyntax {
    var result = ConditionElementSyntax(unexpectedBeforeCondition?.buildUnexpectedNodes(format: format), condition: condition.buildSyntax(format: format), unexpectedBetweenConditionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConditionElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConditionElement`.
  public func createConditionElement() -> ConditionElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConditionElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AvailabilityCondition: SyntaxBuildable, ExpressibleAsAvailabilityCondition {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundAvailableKeyword: UnexpectedNodes?
  var poundAvailableKeyword: Token
  var unexpectedBetweenPoundAvailableKeywordAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndAvailabilitySpec: UnexpectedNodes?
  var availabilitySpec: AvailabilitySpecList
  var unexpectedBetweenAvailabilitySpecAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `AvailabilityCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundAvailableKeyword: 
  ///   - poundAvailableKeyword: 
  ///   - unexpectedBetweenPoundAvailableKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndAvailabilitySpec: 
  ///   - availabilitySpec: 
  ///   - unexpectedBetweenAvailabilitySpecAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundAvailableKeyword: ExpressibleAsUnexpectedNodes? = nil, poundAvailableKeyword: Token = Token.`poundAvailable`, unexpectedBetweenPoundAvailableKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndAvailabilitySpec: ExpressibleAsUnexpectedNodes? = nil, availabilitySpec: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilitySpecAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundAvailableKeyword = unexpectedBeforePoundAvailableKeyword?.createUnexpectedNodes()
    self.poundAvailableKeyword = poundAvailableKeyword
    assert(poundAvailableKeyword.text == #"#available"#)
    self.unexpectedBetweenPoundAvailableKeywordAndLeftParen = unexpectedBetweenPoundAvailableKeywordAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndAvailabilitySpec = unexpectedBetweenLeftParenAndAvailabilitySpec?.createUnexpectedNodes()
    self.availabilitySpec = availabilitySpec.createAvailabilitySpecList()
    self.unexpectedBetweenAvailabilitySpecAndRightParen = unexpectedBetweenAvailabilitySpecAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `AvailabilityConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityConditionSyntax`.
  func buildAvailabilityCondition(format: Format) -> AvailabilityConditionSyntax {
    var result = AvailabilityConditionSyntax(unexpectedBeforePoundAvailableKeyword?.buildUnexpectedNodes(format: format), poundAvailableKeyword: poundAvailableKeyword.buildToken(format: format), unexpectedBetweenPoundAvailableKeywordAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndAvailabilitySpec?.buildUnexpectedNodes(format: format), availabilitySpec: availabilitySpec.buildAvailabilitySpecList(format: format), unexpectedBetweenAvailabilitySpecAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityCondition`.
  public func createAvailabilityCondition() -> AvailabilityCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct MatchingPatternCondition: SyntaxBuildable, ExpressibleAsMatchingPatternCondition {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeCaseKeyword: UnexpectedNodes?
  var caseKeyword: Token
  var unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodes?
  var pattern: PatternBuildable
  var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  var typeAnnotation: TypeAnnotation?
  var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
  var initializer: InitializerClause
  /// Creates a `MatchingPatternCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeCaseKeyword = unexpectedBeforeCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndPattern = unexpectedBetweenCaseKeywordAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInitializer = unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer.createInitializerClause()
  }
  /// Builds a `MatchingPatternConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MatchingPatternConditionSyntax`.
  func buildMatchingPatternCondition(format: Format) -> MatchingPatternConditionSyntax {
    var result = MatchingPatternConditionSyntax(unexpectedBeforeCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: caseKeyword.buildToken(format: format), unexpectedBetweenCaseKeywordAndPattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format), unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format), initializer: initializer.buildInitializerClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMatchingPatternCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMatchingPatternCondition`.
  public func createMatchingPatternCondition() -> MatchingPatternCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MatchingPatternCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct OptionalBindingCondition: SyntaxBuildable, ExpressibleAsOptionalBindingCondition {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLetOrVarKeyword: UnexpectedNodes?
  var letOrVarKeyword: Token
  var unexpectedBetweenLetOrVarKeywordAndPattern: UnexpectedNodes?
  var pattern: PatternBuildable
  var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  var typeAnnotation: TypeAnnotation?
  var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
  var initializer: InitializerClause?
  /// Creates a `OptionalBindingCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLetOrVarKeyword = unexpectedBeforeLetOrVarKeyword?.createUnexpectedNodes()
    self.letOrVarKeyword = letOrVarKeyword
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.unexpectedBetweenLetOrVarKeywordAndPattern = unexpectedBetweenLetOrVarKeywordAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInitializer = unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createInitializerClause()
  }
  /// Builds a `OptionalBindingConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalBindingConditionSyntax`.
  func buildOptionalBindingCondition(format: Format) -> OptionalBindingConditionSyntax {
    var result = OptionalBindingConditionSyntax(unexpectedBeforeLetOrVarKeyword?.buildUnexpectedNodes(format: format), letOrVarKeyword: letOrVarKeyword.buildToken(format: format), unexpectedBetweenLetOrVarKeywordAndPattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format), unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format), initializer: initializer?.buildInitializerClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildOptionalBindingCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalBindingCondition`.
  public func createOptionalBindingCondition() -> OptionalBindingCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OptionalBindingCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct UnavailabilityCondition: SyntaxBuildable, ExpressibleAsUnavailabilityCondition {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundUnavailableKeyword: UnexpectedNodes?
  var poundUnavailableKeyword: Token
  var unexpectedBetweenPoundUnavailableKeywordAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndAvailabilitySpec: UnexpectedNodes?
  var availabilitySpec: AvailabilitySpecList
  var unexpectedBetweenAvailabilitySpecAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `UnavailabilityCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundUnavailableKeyword: 
  ///   - poundUnavailableKeyword: 
  ///   - unexpectedBetweenPoundUnavailableKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndAvailabilitySpec: 
  ///   - availabilitySpec: 
  ///   - unexpectedBetweenAvailabilitySpecAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundUnavailableKeyword: ExpressibleAsUnexpectedNodes? = nil, poundUnavailableKeyword: Token = Token.`poundUnavailable`, unexpectedBetweenPoundUnavailableKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndAvailabilitySpec: ExpressibleAsUnexpectedNodes? = nil, availabilitySpec: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilitySpecAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundUnavailableKeyword = unexpectedBeforePoundUnavailableKeyword?.createUnexpectedNodes()
    self.poundUnavailableKeyword = poundUnavailableKeyword
    assert(poundUnavailableKeyword.text == #"#unavailable"#)
    self.unexpectedBetweenPoundUnavailableKeywordAndLeftParen = unexpectedBetweenPoundUnavailableKeywordAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndAvailabilitySpec = unexpectedBetweenLeftParenAndAvailabilitySpec?.createUnexpectedNodes()
    self.availabilitySpec = availabilitySpec.createAvailabilitySpecList()
    self.unexpectedBetweenAvailabilitySpecAndRightParen = unexpectedBetweenAvailabilitySpecAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `UnavailabilityConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnavailabilityConditionSyntax`.
  func buildUnavailabilityCondition(format: Format) -> UnavailabilityConditionSyntax {
    var result = UnavailabilityConditionSyntax(unexpectedBeforePoundUnavailableKeyword?.buildUnexpectedNodes(format: format), poundUnavailableKeyword: poundUnavailableKeyword.buildToken(format: format), unexpectedBetweenPoundUnavailableKeywordAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndAvailabilitySpec?.buildUnexpectedNodes(format: format), availabilitySpec: availabilitySpec.buildAvailabilitySpecList(format: format), unexpectedBetweenAvailabilitySpecAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildUnavailabilityCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsUnavailabilityCondition`.
  public func createUnavailabilityCondition() -> UnavailabilityCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `UnavailabilityCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct HasSymbolCondition: SyntaxBuildable, ExpressibleAsHasSymbolCondition {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeHasSymbolKeyword: UnexpectedNodes?
  var hasSymbolKeyword: Token
  var unexpectedBetweenHasSymbolKeywordAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  var unexpectedBetweenExpressionAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `HasSymbolCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeHasSymbolKeyword: 
  ///   - hasSymbolKeyword: 
  ///   - unexpectedBetweenHasSymbolKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeHasSymbolKeyword: ExpressibleAsUnexpectedNodes? = nil, hasSymbolKeyword: Token, unexpectedBetweenHasSymbolKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeHasSymbolKeyword = unexpectedBeforeHasSymbolKeyword?.createUnexpectedNodes()
    self.hasSymbolKeyword = hasSymbolKeyword
    self.unexpectedBetweenHasSymbolKeywordAndLeftParen = unexpectedBetweenHasSymbolKeywordAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndExpression = unexpectedBetweenLeftParenAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndRightParen = unexpectedBetweenExpressionAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `HasSymbolConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `HasSymbolConditionSyntax`.
  func buildHasSymbolCondition(format: Format) -> HasSymbolConditionSyntax {
    var result = HasSymbolConditionSyntax(unexpectedBeforeHasSymbolKeyword?.buildUnexpectedNodes(format: format), hasSymbolKeyword: hasSymbolKeyword.buildToken(format: format), unexpectedBetweenHasSymbolKeywordAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format), unexpectedBetweenExpressionAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildHasSymbolCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsHasSymbolCondition`.
  public func createHasSymbolCondition() -> HasSymbolCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `HasSymbolCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DeclarationStmt: StmtBuildable, ExpressibleAsDeclarationStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDeclaration: UnexpectedNodes?
  var declaration: DeclBuildable
  /// Creates a `DeclarationStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeclaration: 
  ///   - declaration: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDeclaration: ExpressibleAsUnexpectedNodes? = nil, declaration: ExpressibleAsDeclBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDeclaration = unexpectedBeforeDeclaration?.createUnexpectedNodes()
    self.declaration = declaration.createDeclBuildable()
  }
  /// Builds a `DeclarationStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclarationStmtSyntax`.
  func buildDeclarationStmt(format: Format) -> DeclarationStmtSyntax {
    var result = DeclarationStmtSyntax(unexpectedBeforeDeclaration?.buildUnexpectedNodes(format: format), declaration: declaration.buildDecl(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildDeclarationStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeclarationStmt`.
  public func createDeclarationStmt() -> DeclarationStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DeclarationStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ThrowStmt: StmtBuildable, ExpressibleAsThrowStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeThrowKeyword: UnexpectedNodes?
  var throwKeyword: Token
  var unexpectedBetweenThrowKeywordAndExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `ThrowStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeThrowKeyword: 
  ///   - throwKeyword: 
  ///   - unexpectedBetweenThrowKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeThrowKeyword: ExpressibleAsUnexpectedNodes? = nil, throwKeyword: Token = Token.`throw`, unexpectedBetweenThrowKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeThrowKeyword = unexpectedBeforeThrowKeyword?.createUnexpectedNodes()
    self.throwKeyword = throwKeyword
    assert(throwKeyword.text == #"throw"#)
    self.unexpectedBetweenThrowKeywordAndExpression = unexpectedBetweenThrowKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `ThrowStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ThrowStmtSyntax`.
  func buildThrowStmt(format: Format) -> ThrowStmtSyntax {
    var result = ThrowStmtSyntax(unexpectedBeforeThrowKeyword?.buildUnexpectedNodes(format: format), throwKeyword: throwKeyword.buildToken(format: format), unexpectedBetweenThrowKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildThrowStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsThrowStmt`.
  public func createThrowStmt() -> ThrowStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ThrowStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IfStmt: StmtBuildable, ExpressibleAsIfStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIfKeyword: UnexpectedNodes?
  var ifKeyword: Token
  var unexpectedBetweenIfKeywordAndConditions: UnexpectedNodes?
  var conditions: ConditionElementList
  var unexpectedBetweenConditionsAndBody: UnexpectedNodes?
  var body: CodeBlock
  var unexpectedBetweenBodyAndElseKeyword: UnexpectedNodes?
  var elseKeyword: Token?
  var unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodes?
  var elseBody: SyntaxBuildable?
  /// Creates a `IfStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIfKeyword: 
  ///   - ifKeyword: 
  ///   - unexpectedBetweenIfKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndElseBody: 
  ///   - elseBody: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIfKeyword: ExpressibleAsUnexpectedNodes? = nil, ifKeyword: Token = Token.`if`, unexpectedBetweenIfKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token? = nil, unexpectedBetweenElseKeywordAndElseBody: ExpressibleAsUnexpectedNodes? = nil, elseBody: ExpressibleAsSyntaxBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIfKeyword = unexpectedBeforeIfKeyword?.createUnexpectedNodes()
    self.ifKeyword = ifKeyword
    assert(ifKeyword.text == #"if"#)
    self.unexpectedBetweenIfKeywordAndConditions = unexpectedBetweenIfKeywordAndConditions?.createUnexpectedNodes()
    self.conditions = conditions.createConditionElementList()
    self.unexpectedBetweenConditionsAndBody = unexpectedBetweenConditionsAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
    self.unexpectedBetweenBodyAndElseKeyword = unexpectedBetweenBodyAndElseKeyword?.createUnexpectedNodes()
    self.elseKeyword = elseKeyword
    assert(elseKeyword == nil || elseKeyword!.text == #"else"#)
    self.unexpectedBetweenElseKeywordAndElseBody = unexpectedBetweenElseKeywordAndElseBody?.createUnexpectedNodes()
    self.elseBody = elseBody?.createSyntaxBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIfKeyword: ExpressibleAsUnexpectedNodes? = nil, ifKeyword: Token = Token.`if`, unexpectedBetweenIfKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token? = nil, unexpectedBetweenElseKeywordAndElseBody: ExpressibleAsUnexpectedNodes? = nil, elseBody: ExpressibleAsSyntaxBuildable? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIfKeyword: unexpectedBeforeIfKeyword, ifKeyword: ifKeyword, unexpectedBetweenIfKeywordAndConditions: unexpectedBetweenIfKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndElseKeyword: unexpectedBetweenBodyAndElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndElseBody: unexpectedBetweenElseKeywordAndElseBody, elseBody: elseBody)
  }
  /// Builds a `IfStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfStmtSyntax`.
  func buildIfStmt(format: Format) -> IfStmtSyntax {
    var result = IfStmtSyntax(unexpectedBeforeIfKeyword?.buildUnexpectedNodes(format: format), ifKeyword: ifKeyword.buildToken(format: format), unexpectedBetweenIfKeywordAndConditions?.buildUnexpectedNodes(format: format), conditions: conditions.buildConditionElementList(format: format), unexpectedBetweenConditionsAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format), unexpectedBetweenBodyAndElseKeyword?.buildUnexpectedNodes(format: format), elseKeyword: elseKeyword?.buildToken(format: format), unexpectedBetweenElseKeywordAndElseBody?.buildUnexpectedNodes(format: format), elseBody: elseBody?.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildIfStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsIfStmt`.
  public func createIfStmt() -> IfStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `IfStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ElseIfContinuation: SyntaxBuildable, ExpressibleAsElseIfContinuation {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIfStatement: UnexpectedNodes?
  var ifStatement: IfStmt
  /// Creates a `ElseIfContinuation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIfStatement: 
  ///   - ifStatement: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIfStatement: ExpressibleAsUnexpectedNodes? = nil, ifStatement: ExpressibleAsIfStmt) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIfStatement = unexpectedBeforeIfStatement?.createUnexpectedNodes()
    self.ifStatement = ifStatement.createIfStmt()
  }
  /// Builds a `ElseIfContinuationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ElseIfContinuationSyntax`.
  func buildElseIfContinuation(format: Format) -> ElseIfContinuationSyntax {
    var result = ElseIfContinuationSyntax(unexpectedBeforeIfStatement?.buildUnexpectedNodes(format: format), ifStatement: ifStatement.buildIfStmt(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildElseIfContinuation(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsElseIfContinuation`.
  public func createElseIfContinuation() -> ElseIfContinuation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ElseIfContinuation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ElseBlock: SyntaxBuildable, ExpressibleAsElseBlock {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeElseKeyword: UnexpectedNodes?
  var elseKeyword: Token
  var unexpectedBetweenElseKeywordAndBody: UnexpectedNodes?
  var body: CodeBlock
  /// Creates a `ElseBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeElseKeyword = unexpectedBeforeElseKeyword?.createUnexpectedNodes()
    self.elseKeyword = elseKeyword
    assert(elseKeyword.text == #"else"#)
    self.unexpectedBetweenElseKeywordAndBody = unexpectedBetweenElseKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeElseKeyword: unexpectedBeforeElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `ElseBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ElseBlockSyntax`.
  func buildElseBlock(format: Format) -> ElseBlockSyntax {
    var result = ElseBlockSyntax(unexpectedBeforeElseKeyword?.buildUnexpectedNodes(format: format), elseKeyword: elseKeyword.buildToken(format: format), unexpectedBetweenElseKeywordAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildElseBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsElseBlock`.
  public func createElseBlock() -> ElseBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ElseBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SwitchCase: SyntaxBuildable, ExpressibleAsSwitchCase {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeUnknownAttr: UnexpectedNodes?
  var unknownAttr: Attribute?
  var unexpectedBetweenUnknownAttrAndLabel: UnexpectedNodes?
  var label: SyntaxBuildable
  var unexpectedBetweenLabelAndStatements: UnexpectedNodes?
  var statements: CodeBlockItemList
  /// Creates a `SwitchCase` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeUnknownAttr: 
  ///   - unknownAttr: 
  ///   - unexpectedBetweenUnknownAttrAndLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndStatements: 
  ///   - statements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeUnknownAttr: ExpressibleAsUnexpectedNodes? = nil, unknownAttr: ExpressibleAsAttribute? = nil, unexpectedBetweenUnknownAttrAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: ExpressibleAsSyntaxBuildable, unexpectedBetweenLabelAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeUnknownAttr = unexpectedBeforeUnknownAttr?.createUnexpectedNodes()
    self.unknownAttr = unknownAttr?.createAttribute()
    self.unexpectedBetweenUnknownAttrAndLabel = unexpectedBetweenUnknownAttrAndLabel?.createUnexpectedNodes()
    self.label = label.createSyntaxBuildable()
    self.unexpectedBetweenLabelAndStatements = unexpectedBetweenLabelAndStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeUnknownAttr: ExpressibleAsUnexpectedNodes? = nil, unknownAttr: ExpressibleAsAttribute? = nil, unexpectedBetweenUnknownAttrAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: ExpressibleAsSyntaxBuildable, unexpectedBetweenLabelAndStatements: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeUnknownAttr: unexpectedBeforeUnknownAttr, unknownAttr: unknownAttr, unexpectedBetweenUnknownAttrAndLabel: unexpectedBetweenUnknownAttrAndLabel, label: label, unexpectedBetweenLabelAndStatements: unexpectedBetweenLabelAndStatements, statements: statementsBuilder())
  }
  /// Builds a `SwitchCaseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchCaseSyntax`.
  func buildSwitchCase(format: Format) -> SwitchCaseSyntax {
    var result = SwitchCaseSyntax(unexpectedBeforeUnknownAttr?.buildUnexpectedNodes(format: format), unknownAttr: unknownAttr?.buildAttribute(format: format), unexpectedBetweenUnknownAttrAndLabel?.buildUnexpectedNodes(format: format), label: label.buildSyntax(format: format), unexpectedBetweenLabelAndStatements?.buildUnexpectedNodes(format: format), statements: statements.buildCodeBlockItemList(format: format._indented))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSwitchCase(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchCase`.
  public func createSwitchCase() -> SwitchCase {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchCase` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SwitchDefaultLabel: SyntaxBuildable, ExpressibleAsSwitchDefaultLabel {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeDefaultKeyword: UnexpectedNodes?
  var defaultKeyword: Token
  var unexpectedBetweenDefaultKeywordAndColon: UnexpectedNodes?
  var colon: Token
  /// Creates a `SwitchDefaultLabel` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDefaultKeyword: 
  ///   - defaultKeyword: 
  ///   - unexpectedBetweenDefaultKeywordAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDefaultKeyword: ExpressibleAsUnexpectedNodes? = nil, defaultKeyword: Token = Token.`default`, unexpectedBetweenDefaultKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeDefaultKeyword = unexpectedBeforeDefaultKeyword?.createUnexpectedNodes()
    self.defaultKeyword = defaultKeyword
    assert(defaultKeyword.text == #"default"#)
    self.unexpectedBetweenDefaultKeywordAndColon = unexpectedBetweenDefaultKeywordAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
  }
  /// Builds a `SwitchDefaultLabelSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchDefaultLabelSyntax`.
  func buildSwitchDefaultLabel(format: Format) -> SwitchDefaultLabelSyntax {
    var result = SwitchDefaultLabelSyntax(unexpectedBeforeDefaultKeyword?.buildUnexpectedNodes(format: format), defaultKeyword: defaultKeyword.buildToken(format: format), unexpectedBetweenDefaultKeywordAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSwitchDefaultLabel(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchDefaultLabel`.
  public func createSwitchDefaultLabel() -> SwitchDefaultLabel {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchDefaultLabel` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct CaseItem: SyntaxBuildable, ExpressibleAsCaseItem, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePattern: UnexpectedNodes?
  var pattern: PatternBuildable
  var unexpectedBetweenPatternAndWhereClause: UnexpectedNodes?
  var whereClause: WhereClause?
  var unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `CaseItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndWhereClause = unexpectedBetweenPatternAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createWhereClause()
    self.unexpectedBetweenWhereClauseAndTrailingComma = unexpectedBetweenWhereClauseAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `CaseItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CaseItemSyntax`.
  func buildCaseItem(format: Format) -> CaseItemSyntax {
    var result = CaseItemSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format), unexpectedBetweenPatternAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: whereClause?.buildWhereClause(format: format), unexpectedBetweenWhereClauseAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCaseItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCaseItem`.
  public func createCaseItem() -> CaseItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CaseItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct CatchItem: SyntaxBuildable, ExpressibleAsCatchItem, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePattern: UnexpectedNodes?
  var pattern: PatternBuildable?
  var unexpectedBetweenPatternAndWhereClause: UnexpectedNodes?
  var whereClause: WhereClause?
  var unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `CatchItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable? = nil, unexpectedBetweenPatternAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern?.createPatternBuildable()
    self.unexpectedBetweenPatternAndWhereClause = unexpectedBetweenPatternAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createWhereClause()
    self.unexpectedBetweenWhereClauseAndTrailingComma = unexpectedBetweenWhereClauseAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `CatchItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CatchItemSyntax`.
  func buildCatchItem(format: Format) -> CatchItemSyntax {
    var result = CatchItemSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: pattern?.buildPattern(format: format), unexpectedBetweenPatternAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: whereClause?.buildWhereClause(format: format), unexpectedBetweenWhereClauseAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCatchItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCatchItem`.
  public func createCatchItem() -> CatchItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CatchItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SwitchCaseLabel: SyntaxBuildable, ExpressibleAsSwitchCaseLabel {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeCaseKeyword: UnexpectedNodes?
  var caseKeyword: Token
  var unexpectedBetweenCaseKeywordAndCaseItems: UnexpectedNodes?
  var caseItems: CaseItemList
  var unexpectedBetweenCaseItemsAndColon: UnexpectedNodes?
  var colon: Token
  /// Creates a `SwitchCaseLabel` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndCaseItems: 
  ///   - caseItems: 
  ///   - unexpectedBetweenCaseItemsAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndCaseItems: ExpressibleAsUnexpectedNodes? = nil, caseItems: ExpressibleAsCaseItemList, unexpectedBetweenCaseItemsAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeCaseKeyword = unexpectedBeforeCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndCaseItems = unexpectedBetweenCaseKeywordAndCaseItems?.createUnexpectedNodes()
    self.caseItems = caseItems.createCaseItemList()
    self.unexpectedBetweenCaseItemsAndColon = unexpectedBetweenCaseItemsAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndCaseItems: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenCaseItemsAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, @CaseItemListBuilder caseItemsBuilder: () -> ExpressibleAsCaseItemList =  {
    CaseItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCaseKeyword: unexpectedBeforeCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndCaseItems: unexpectedBetweenCaseKeywordAndCaseItems, caseItems: caseItemsBuilder(), unexpectedBetweenCaseItemsAndColon: unexpectedBetweenCaseItemsAndColon, colon: colon)
  }
  /// Builds a `SwitchCaseLabelSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchCaseLabelSyntax`.
  func buildSwitchCaseLabel(format: Format) -> SwitchCaseLabelSyntax {
    var result = SwitchCaseLabelSyntax(unexpectedBeforeCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: caseKeyword.buildToken(format: format), unexpectedBetweenCaseKeywordAndCaseItems?.buildUnexpectedNodes(format: format), caseItems: caseItems.buildCaseItemList(format: format), unexpectedBetweenCaseItemsAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSwitchCaseLabel(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchCaseLabel`.
  public func createSwitchCaseLabel() -> SwitchCaseLabel {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchCaseLabel` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct CatchClause: SyntaxBuildable, ExpressibleAsCatchClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeCatchKeyword: UnexpectedNodes?
  var catchKeyword: Token
  var unexpectedBetweenCatchKeywordAndCatchItems: UnexpectedNodes?
  var catchItems: CatchItemList?
  var unexpectedBetweenCatchItemsAndBody: UnexpectedNodes?
  var body: CodeBlock
  /// Creates a `CatchClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCatchKeyword: 
  ///   - catchKeyword: 
  ///   - unexpectedBetweenCatchKeywordAndCatchItems: 
  ///   - catchItems: 
  ///   - unexpectedBetweenCatchItemsAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCatchKeyword: ExpressibleAsUnexpectedNodes? = nil, catchKeyword: Token = Token.`catch`, unexpectedBetweenCatchKeywordAndCatchItems: ExpressibleAsUnexpectedNodes? = nil, catchItems: ExpressibleAsCatchItemList? = nil, unexpectedBetweenCatchItemsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeCatchKeyword = unexpectedBeforeCatchKeyword?.createUnexpectedNodes()
    self.catchKeyword = catchKeyword
    assert(catchKeyword.text == #"catch"#)
    self.unexpectedBetweenCatchKeywordAndCatchItems = unexpectedBetweenCatchKeywordAndCatchItems?.createUnexpectedNodes()
    self.catchItems = catchItems?.createCatchItemList()
    self.unexpectedBetweenCatchItemsAndBody = unexpectedBetweenCatchItemsAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCatchKeyword: ExpressibleAsUnexpectedNodes? = nil, catchKeyword: Token = Token.`catch`, unexpectedBetweenCatchKeywordAndCatchItems: ExpressibleAsUnexpectedNodes? = nil, catchItems: ExpressibleAsCatchItemList? = nil, unexpectedBetweenCatchItemsAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCatchKeyword: unexpectedBeforeCatchKeyword, catchKeyword: catchKeyword, unexpectedBetweenCatchKeywordAndCatchItems: unexpectedBetweenCatchKeywordAndCatchItems, catchItems: catchItems, unexpectedBetweenCatchItemsAndBody: unexpectedBetweenCatchItemsAndBody, body: bodyBuilder())
  }
  /// Builds a `CatchClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CatchClauseSyntax`.
  func buildCatchClause(format: Format) -> CatchClauseSyntax {
    var result = CatchClauseSyntax(unexpectedBeforeCatchKeyword?.buildUnexpectedNodes(format: format), catchKeyword: catchKeyword.buildToken(format: format), unexpectedBetweenCatchKeywordAndCatchItems?.buildUnexpectedNodes(format: format), catchItems: catchItems?.buildCatchItemList(format: format), unexpectedBetweenCatchItemsAndBody?.buildUnexpectedNodes(format: format), body: body.buildCodeBlock(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCatchClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCatchClause`.
  public func createCatchClause() -> CatchClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CatchClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PoundAssertStmt: StmtBuildable, ExpressibleAsPoundAssertStmt {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePoundAssert: UnexpectedNodes?
  var poundAssert: Token
  var unexpectedBetweenPoundAssertAndLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndCondition: UnexpectedNodes?
  var condition: ExprBuildable
  var unexpectedBetweenConditionAndComma: UnexpectedNodes?
  var comma: Token?
  var unexpectedBetweenCommaAndMessage: UnexpectedNodes?
  var message: Token?
  var unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `PoundAssertStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundAssert: 
  ///   - poundAssert: 
  ///   - unexpectedBetweenPoundAssertAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndCondition: 
  ///   - condition: The assertion condition.
  ///   - unexpectedBetweenConditionAndComma: 
  ///   - comma: The comma after the assertion condition.
  ///   - unexpectedBetweenCommaAndMessage: 
  ///   - message: The assertion message.
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundAssert: ExpressibleAsUnexpectedNodes? = nil, poundAssert: Token = Token.`poundAssert`, unexpectedBetweenPoundAssertAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, unexpectedBetweenConditionAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: Token? = nil, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePoundAssert = unexpectedBeforePoundAssert?.createUnexpectedNodes()
    self.poundAssert = poundAssert
    assert(poundAssert.text == #"#assert"#)
    self.unexpectedBetweenPoundAssertAndLeftParen = unexpectedBetweenPoundAssertAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndCondition = unexpectedBetweenLeftParenAndCondition?.createUnexpectedNodes()
    self.condition = condition.createExprBuildable()
    self.unexpectedBetweenConditionAndComma = unexpectedBetweenConditionAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma == nil || comma!.text == #","#)
    self.unexpectedBetweenCommaAndMessage = unexpectedBetweenCommaAndMessage?.createUnexpectedNodes()
    self.message = message
    self.unexpectedBetweenMessageAndRightParen = unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundAssert: ExpressibleAsUnexpectedNodes? = nil, poundAssert: Token = Token.`poundAssert`, unexpectedBetweenPoundAssertAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, unexpectedBetweenConditionAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: String?, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePoundAssert: unexpectedBeforePoundAssert, poundAssert: poundAssert, unexpectedBetweenPoundAssertAndLeftParen: unexpectedBetweenPoundAssertAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndCondition: unexpectedBetweenLeftParenAndCondition, condition: condition, unexpectedBetweenConditionAndComma: unexpectedBetweenConditionAndComma, comma: comma, unexpectedBetweenCommaAndMessage: unexpectedBetweenCommaAndMessage, message: message.map {
      Token.`stringLiteral`($0)
    }, unexpectedBetweenMessageAndRightParen: unexpectedBetweenMessageAndRightParen, rightParen: rightParen)
  }
  /// Builds a `PoundAssertStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundAssertStmtSyntax`.
  func buildPoundAssertStmt(format: Format) -> PoundAssertStmtSyntax {
    var result = PoundAssertStmtSyntax(unexpectedBeforePoundAssert?.buildUnexpectedNodes(format: format), poundAssert: poundAssert.buildToken(format: format), unexpectedBetweenPoundAssertAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndCondition?.buildUnexpectedNodes(format: format), condition: condition.buildExpr(format: format), unexpectedBetweenConditionAndComma?.buildUnexpectedNodes(format: format), comma: comma?.buildToken(format: format), unexpectedBetweenCommaAndMessage?.buildUnexpectedNodes(format: format), message: message?.buildToken(format: format), unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildPoundAssertStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundAssertStmt`.
  public func createPoundAssertStmt() -> PoundAssertStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `PoundAssertStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct GenericWhereClause: SyntaxBuildable, ExpressibleAsGenericWhereClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWhereKeyword: UnexpectedNodes?
  var whereKeyword: Token
  var unexpectedBetweenWhereKeywordAndRequirementList: UnexpectedNodes?
  var requirementList: GenericRequirementList
  /// Creates a `GenericWhereClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhereKeyword: 
  ///   - whereKeyword: 
  ///   - unexpectedBetweenWhereKeywordAndRequirementList: 
  ///   - requirementList: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndRequirementList: ExpressibleAsUnexpectedNodes? = nil, requirementList: ExpressibleAsGenericRequirementList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWhereKeyword = unexpectedBeforeWhereKeyword?.createUnexpectedNodes()
    self.whereKeyword = whereKeyword
    assert(whereKeyword.text == #"where"#)
    self.unexpectedBetweenWhereKeywordAndRequirementList = unexpectedBetweenWhereKeywordAndRequirementList?.createUnexpectedNodes()
    self.requirementList = requirementList.createGenericRequirementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndRequirementList: ExpressibleAsUnexpectedNodes? = nil, @GenericRequirementListBuilder requirementListBuilder: () -> ExpressibleAsGenericRequirementList =  {
    GenericRequirementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWhereKeyword: unexpectedBeforeWhereKeyword, whereKeyword: whereKeyword, unexpectedBetweenWhereKeywordAndRequirementList: unexpectedBetweenWhereKeywordAndRequirementList, requirementList: requirementListBuilder())
  }
  /// Builds a `GenericWhereClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericWhereClauseSyntax`.
  func buildGenericWhereClause(format: Format) -> GenericWhereClauseSyntax {
    var result = GenericWhereClauseSyntax(unexpectedBeforeWhereKeyword?.buildUnexpectedNodes(format: format), whereKeyword: whereKeyword.buildToken(format: format), unexpectedBetweenWhereKeywordAndRequirementList?.buildUnexpectedNodes(format: format), requirementList: requirementList.buildGenericRequirementList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericWhereClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericWhereClause`.
  public func createGenericWhereClause() -> GenericWhereClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericWhereClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct GenericRequirement: SyntaxBuildable, ExpressibleAsGenericRequirement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBody: UnexpectedNodes?
  var body: SyntaxBuildable
  var unexpectedBetweenBodyAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `GenericRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsSyntaxBuildable, unexpectedBetweenBodyAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBody = unexpectedBeforeBody?.createUnexpectedNodes()
    self.body = body.createSyntaxBuildable()
    self.unexpectedBetweenBodyAndTrailingComma = unexpectedBetweenBodyAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `GenericRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericRequirementSyntax`.
  func buildGenericRequirement(format: Format) -> GenericRequirementSyntax {
    var result = GenericRequirementSyntax(unexpectedBeforeBody?.buildUnexpectedNodes(format: format), body: body.buildSyntax(format: format), unexpectedBetweenBodyAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericRequirement`.
  public func createGenericRequirement() -> GenericRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SameTypeRequirement: SyntaxBuildable, ExpressibleAsSameTypeRequirement {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftTypeIdentifier: UnexpectedNodes?
  var leftTypeIdentifier: TypeBuildable
  var unexpectedBetweenLeftTypeIdentifierAndEqualityToken: UnexpectedNodes?
  var equalityToken: Token
  var unexpectedBetweenEqualityTokenAndRightTypeIdentifier: UnexpectedNodes?
  var rightTypeIdentifier: TypeBuildable
  /// Creates a `SameTypeRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftTypeIdentifier: 
  ///   - leftTypeIdentifier: 
  ///   - unexpectedBetweenLeftTypeIdentifierAndEqualityToken: 
  ///   - equalityToken: 
  ///   - unexpectedBetweenEqualityTokenAndRightTypeIdentifier: 
  ///   - rightTypeIdentifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, leftTypeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenLeftTypeIdentifierAndEqualityToken: ExpressibleAsUnexpectedNodes? = nil, equalityToken: Token, unexpectedBetweenEqualityTokenAndRightTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, rightTypeIdentifier: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftTypeIdentifier = unexpectedBeforeLeftTypeIdentifier?.createUnexpectedNodes()
    self.leftTypeIdentifier = leftTypeIdentifier.createTypeBuildable()
    self.unexpectedBetweenLeftTypeIdentifierAndEqualityToken = unexpectedBetweenLeftTypeIdentifierAndEqualityToken?.createUnexpectedNodes()
    self.equalityToken = equalityToken
    self.unexpectedBetweenEqualityTokenAndRightTypeIdentifier = unexpectedBetweenEqualityTokenAndRightTypeIdentifier?.createUnexpectedNodes()
    self.rightTypeIdentifier = rightTypeIdentifier.createTypeBuildable()
  }
  /// Builds a `SameTypeRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SameTypeRequirementSyntax`.
  func buildSameTypeRequirement(format: Format) -> SameTypeRequirementSyntax {
    var result = SameTypeRequirementSyntax(unexpectedBeforeLeftTypeIdentifier?.buildUnexpectedNodes(format: format), leftTypeIdentifier: leftTypeIdentifier.buildType(format: format), unexpectedBetweenLeftTypeIdentifierAndEqualityToken?.buildUnexpectedNodes(format: format), equalityToken: equalityToken.buildToken(format: format), unexpectedBetweenEqualityTokenAndRightTypeIdentifier?.buildUnexpectedNodes(format: format), rightTypeIdentifier: rightTypeIdentifier.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSameTypeRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSameTypeRequirement`.
  public func createSameTypeRequirement() -> SameTypeRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SameTypeRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct LayoutRequirement: SyntaxBuildable, ExpressibleAsLayoutRequirement {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeTypeIdentifier: UnexpectedNodes?
  var typeIdentifier: TypeBuildable
  var unexpectedBetweenTypeIdentifierAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndLayoutConstraint: UnexpectedNodes?
  var layoutConstraint: Token
  var unexpectedBetweenLayoutConstraintAndLeftParen: UnexpectedNodes?
  var leftParen: Token?
  var unexpectedBetweenLeftParenAndSize: UnexpectedNodes?
  var size: Token?
  var unexpectedBetweenSizeAndComma: UnexpectedNodes?
  var comma: Token?
  var unexpectedBetweenCommaAndAlignment: UnexpectedNodes?
  var alignment: Token?
  var unexpectedBetweenAlignmentAndRightParen: UnexpectedNodes?
  var rightParen: Token?
  /// Creates a `LayoutRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTypeIdentifier: 
  ///   - typeIdentifier: 
  ///   - unexpectedBetweenTypeIdentifierAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndLayoutConstraint: 
  ///   - layoutConstraint: 
  ///   - unexpectedBetweenLayoutConstraintAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndSize: 
  ///   - size: 
  ///   - unexpectedBetweenSizeAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndAlignment: 
  ///   - alignment: 
  ///   - unexpectedBetweenAlignmentAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, typeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndLayoutConstraint: ExpressibleAsUnexpectedNodes? = nil, layoutConstraint: Token, unexpectedBetweenLayoutConstraintAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndSize: ExpressibleAsUnexpectedNodes? = nil, size: Token? = nil, unexpectedBetweenSizeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndAlignment: ExpressibleAsUnexpectedNodes? = nil, alignment: Token? = nil, unexpectedBetweenAlignmentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeTypeIdentifier = unexpectedBeforeTypeIdentifier?.createUnexpectedNodes()
    self.typeIdentifier = typeIdentifier.createTypeBuildable()
    self.unexpectedBetweenTypeIdentifierAndColon = unexpectedBetweenTypeIdentifierAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndLayoutConstraint = unexpectedBetweenColonAndLayoutConstraint?.createUnexpectedNodes()
    self.layoutConstraint = layoutConstraint
    self.unexpectedBetweenLayoutConstraintAndLeftParen = unexpectedBetweenLayoutConstraintAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndSize = unexpectedBetweenLeftParenAndSize?.createUnexpectedNodes()
    self.size = size
    self.unexpectedBetweenSizeAndComma = unexpectedBetweenSizeAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma == nil || comma!.text == #","#)
    self.unexpectedBetweenCommaAndAlignment = unexpectedBetweenCommaAndAlignment?.createUnexpectedNodes()
    self.alignment = alignment
    self.unexpectedBetweenAlignmentAndRightParen = unexpectedBetweenAlignmentAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, typeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndLayoutConstraint: ExpressibleAsUnexpectedNodes? = nil, layoutConstraint: String, unexpectedBetweenLayoutConstraintAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndSize: ExpressibleAsUnexpectedNodes? = nil, size: String?, unexpectedBetweenSizeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndAlignment: ExpressibleAsUnexpectedNodes? = nil, alignment: String?, unexpectedBetweenAlignmentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeTypeIdentifier: unexpectedBeforeTypeIdentifier, typeIdentifier: typeIdentifier, unexpectedBetweenTypeIdentifierAndColon: unexpectedBetweenTypeIdentifierAndColon, colon: colon, unexpectedBetweenColonAndLayoutConstraint: unexpectedBetweenColonAndLayoutConstraint, layoutConstraint: Token.`identifier`(layoutConstraint), unexpectedBetweenLayoutConstraintAndLeftParen: unexpectedBetweenLayoutConstraintAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndSize: unexpectedBetweenLeftParenAndSize, size: size.map {
      Token.`integerLiteral`($0)
    }, unexpectedBetweenSizeAndComma: unexpectedBetweenSizeAndComma, comma: comma, unexpectedBetweenCommaAndAlignment: unexpectedBetweenCommaAndAlignment, alignment: alignment.map {
      Token.`integerLiteral`($0)
    }, unexpectedBetweenAlignmentAndRightParen: unexpectedBetweenAlignmentAndRightParen, rightParen: rightParen)
  }
  /// Builds a `LayoutRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LayoutRequirementSyntax`.
  func buildLayoutRequirement(format: Format) -> LayoutRequirementSyntax {
    var result = LayoutRequirementSyntax(unexpectedBeforeTypeIdentifier?.buildUnexpectedNodes(format: format), typeIdentifier: typeIdentifier.buildType(format: format), unexpectedBetweenTypeIdentifierAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndLayoutConstraint?.buildUnexpectedNodes(format: format), layoutConstraint: layoutConstraint.buildToken(format: format), unexpectedBetweenLayoutConstraintAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen?.buildToken(format: format), unexpectedBetweenLeftParenAndSize?.buildUnexpectedNodes(format: format), size: size?.buildToken(format: format), unexpectedBetweenSizeAndComma?.buildUnexpectedNodes(format: format), comma: comma?.buildToken(format: format), unexpectedBetweenCommaAndAlignment?.buildUnexpectedNodes(format: format), alignment: alignment?.buildToken(format: format), unexpectedBetweenAlignmentAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildLayoutRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsLayoutRequirement`.
  public func createLayoutRequirement() -> LayoutRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `LayoutRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct GenericParameter: SyntaxBuildable, ExpressibleAsGenericParameter, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndColon: UnexpectedNodes?
  var colon: Token?
  var unexpectedBetweenColonAndInheritedType: UnexpectedNodes?
  var inheritedType: TypeBuildable?
  var unexpectedBetweenInheritedTypeAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `GenericParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndInheritedType: 
  ///   - inheritedType: 
  ///   - unexpectedBetweenInheritedTypeAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndInheritedType: ExpressibleAsUnexpectedNodes? = nil, inheritedType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenInheritedTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndName = unexpectedBetweenAttributesAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndColon = unexpectedBetweenNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndInheritedType = unexpectedBetweenColonAndInheritedType?.createUnexpectedNodes()
    self.inheritedType = inheritedType?.createTypeBuildable()
    self.unexpectedBetweenInheritedTypeAndTrailingComma = unexpectedBetweenInheritedTypeAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndInheritedType: ExpressibleAsUnexpectedNodes? = nil, inheritedType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenInheritedTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndName: unexpectedBetweenAttributesAndName, name: Token.`identifier`(name), unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon, colon: colon, unexpectedBetweenColonAndInheritedType: unexpectedBetweenColonAndInheritedType, inheritedType: inheritedType, unexpectedBetweenInheritedTypeAndTrailingComma: unexpectedBetweenInheritedTypeAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `GenericParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericParameterSyntax`.
  func buildGenericParameter(format: Format) -> GenericParameterSyntax {
    var result = GenericParameterSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format), colon: colon?.buildToken(format: format), unexpectedBetweenColonAndInheritedType?.buildUnexpectedNodes(format: format), inheritedType: inheritedType?.buildType(format: format), unexpectedBetweenInheritedTypeAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericParameter(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericParameter`.
  public func createGenericParameter() -> GenericParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PrimaryAssociatedType: SyntaxBuildable, ExpressibleAsPrimaryAssociatedType, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `PrimaryAssociatedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingComma = unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `PrimaryAssociatedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrimaryAssociatedTypeSyntax`.
  func buildPrimaryAssociatedType(format: Format) -> PrimaryAssociatedTypeSyntax {
    var result = PrimaryAssociatedTypeSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrimaryAssociatedType(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrimaryAssociatedType`.
  public func createPrimaryAssociatedType() -> PrimaryAssociatedType {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrimaryAssociatedType` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct GenericParameterClause: SyntaxBuildable, ExpressibleAsGenericParameterClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
  var leftAngleBracket: Token
  var unexpectedBetweenLeftAngleBracketAndGenericParameterList: UnexpectedNodes?
  var genericParameterList: GenericParameterList
  var unexpectedBetweenGenericParameterListAndRightAngleBracket: UnexpectedNodes?
  var rightAngleBracket: Token
  /// Creates a `GenericParameterClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndGenericParameterList: 
  ///   - genericParameterList: 
  ///   - unexpectedBetweenGenericParameterListAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndGenericParameterList: ExpressibleAsUnexpectedNodes? = nil, genericParameterList: ExpressibleAsGenericParameterList, unexpectedBetweenGenericParameterListAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftAngleBracket = unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes()
    self.leftAngleBracket = leftAngleBracket
    assert(leftAngleBracket.text == #"<"#)
    self.unexpectedBetweenLeftAngleBracketAndGenericParameterList = unexpectedBetweenLeftAngleBracketAndGenericParameterList?.createUnexpectedNodes()
    self.genericParameterList = genericParameterList.createGenericParameterList()
    self.unexpectedBetweenGenericParameterListAndRightAngleBracket = unexpectedBetweenGenericParameterListAndRightAngleBracket?.createUnexpectedNodes()
    self.rightAngleBracket = rightAngleBracket
    assert(rightAngleBracket.text == #">"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndGenericParameterList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenGenericParameterListAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`, @GenericParameterListBuilder genericParameterListBuilder: () -> ExpressibleAsGenericParameterList =  {
    GenericParameterList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket, leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndGenericParameterList: unexpectedBetweenLeftAngleBracketAndGenericParameterList, genericParameterList: genericParameterListBuilder(), unexpectedBetweenGenericParameterListAndRightAngleBracket: unexpectedBetweenGenericParameterListAndRightAngleBracket, rightAngleBracket: rightAngleBracket)
  }
  /// Builds a `GenericParameterClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericParameterClauseSyntax`.
  func buildGenericParameterClause(format: Format) -> GenericParameterClauseSyntax {
    var result = GenericParameterClauseSyntax(unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format), leftAngleBracket: leftAngleBracket.buildToken(format: format), unexpectedBetweenLeftAngleBracketAndGenericParameterList?.buildUnexpectedNodes(format: format), genericParameterList: genericParameterList.buildGenericParameterList(format: format), unexpectedBetweenGenericParameterListAndRightAngleBracket?.buildUnexpectedNodes(format: format), rightAngleBracket: rightAngleBracket.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericParameterClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericParameterClause`.
  public func createGenericParameterClause() -> GenericParameterClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericParameterClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ConformanceRequirement: SyntaxBuildable, ExpressibleAsConformanceRequirement {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftTypeIdentifier: UnexpectedNodes?
  var leftTypeIdentifier: TypeBuildable
  var unexpectedBetweenLeftTypeIdentifierAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndRightTypeIdentifier: UnexpectedNodes?
  var rightTypeIdentifier: TypeBuildable
  /// Creates a `ConformanceRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftTypeIdentifier: 
  ///   - leftTypeIdentifier: 
  ///   - unexpectedBetweenLeftTypeIdentifierAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndRightTypeIdentifier: 
  ///   - rightTypeIdentifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, leftTypeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenLeftTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndRightTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, rightTypeIdentifier: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftTypeIdentifier = unexpectedBeforeLeftTypeIdentifier?.createUnexpectedNodes()
    self.leftTypeIdentifier = leftTypeIdentifier.createTypeBuildable()
    self.unexpectedBetweenLeftTypeIdentifierAndColon = unexpectedBetweenLeftTypeIdentifierAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndRightTypeIdentifier = unexpectedBetweenColonAndRightTypeIdentifier?.createUnexpectedNodes()
    self.rightTypeIdentifier = rightTypeIdentifier.createTypeBuildable()
  }
  /// Builds a `ConformanceRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConformanceRequirementSyntax`.
  func buildConformanceRequirement(format: Format) -> ConformanceRequirementSyntax {
    var result = ConformanceRequirementSyntax(unexpectedBeforeLeftTypeIdentifier?.buildUnexpectedNodes(format: format), leftTypeIdentifier: leftTypeIdentifier.buildType(format: format), unexpectedBetweenLeftTypeIdentifierAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndRightTypeIdentifier?.buildUnexpectedNodes(format: format), rightTypeIdentifier: rightTypeIdentifier.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConformanceRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConformanceRequirement`.
  public func createConformanceRequirement() -> ConformanceRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConformanceRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PrimaryAssociatedTypeClause: SyntaxBuildable, ExpressibleAsPrimaryAssociatedTypeClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
  var leftAngleBracket: Token
  var unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: UnexpectedNodes?
  var primaryAssociatedTypeList: PrimaryAssociatedTypeList
  var unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: UnexpectedNodes?
  var rightAngleBracket: Token
  /// Creates a `PrimaryAssociatedTypeClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: 
  ///   - primaryAssociatedTypeList: 
  ///   - unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeList: ExpressibleAsPrimaryAssociatedTypeList, unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftAngleBracket = unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes()
    self.leftAngleBracket = leftAngleBracket
    assert(leftAngleBracket.text == #"<"#)
    self.unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList = unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList?.createUnexpectedNodes()
    self.primaryAssociatedTypeList = primaryAssociatedTypeList.createPrimaryAssociatedTypeList()
    self.unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket = unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket?.createUnexpectedNodes()
    self.rightAngleBracket = rightAngleBracket
    assert(rightAngleBracket.text == #">"#)
  }
  /// Builds a `PrimaryAssociatedTypeClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrimaryAssociatedTypeClauseSyntax`.
  func buildPrimaryAssociatedTypeClause(format: Format) -> PrimaryAssociatedTypeClauseSyntax {
    var result = PrimaryAssociatedTypeClauseSyntax(unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format), leftAngleBracket: leftAngleBracket.buildToken(format: format), unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList?.buildUnexpectedNodes(format: format), primaryAssociatedTypeList: primaryAssociatedTypeList.buildPrimaryAssociatedTypeList(format: format), unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket?.buildUnexpectedNodes(format: format), rightAngleBracket: rightAngleBracket.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrimaryAssociatedTypeClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrimaryAssociatedTypeClause`.
  public func createPrimaryAssociatedTypeClause() -> PrimaryAssociatedTypeClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrimaryAssociatedTypeClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct SimpleTypeIdentifier: TypeBuildable, ExpressibleAsSimpleTypeIdentifier {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodes?
  var genericArgumentClause: GenericArgumentClause?
  /// Creates a `SimpleTypeIdentifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndGenericArgumentClause = unexpectedBetweenNameAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause?.createGenericArgumentClause()
  }
  /// Builds a `SimpleTypeIdentifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SimpleTypeIdentifierSyntax`.
  func buildSimpleTypeIdentifier(format: Format) -> SimpleTypeIdentifierSyntax {
    var result = SimpleTypeIdentifierSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: genericArgumentClause?.buildGenericArgumentClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildSimpleTypeIdentifier(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsSimpleTypeIdentifier`.
  public func createSimpleTypeIdentifier() -> SimpleTypeIdentifier {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `SimpleTypeIdentifier` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct MemberTypeIdentifier: TypeBuildable, ExpressibleAsMemberTypeIdentifier {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBaseType: UnexpectedNodes?
  var baseType: TypeBuildable
  var unexpectedBetweenBaseTypeAndPeriod: UnexpectedNodes?
  var period: Token
  var unexpectedBetweenPeriodAndName: UnexpectedNodes?
  var name: Token
  var unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodes?
  var genericArgumentClause: GenericArgumentClause?
  /// Creates a `MemberTypeIdentifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: 
  ///   - unexpectedBetweenBaseTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token, unexpectedBetweenPeriodAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBaseType = unexpectedBeforeBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
    self.unexpectedBetweenBaseTypeAndPeriod = unexpectedBetweenBaseTypeAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."# || period.text == #"."#)
    self.unexpectedBetweenPeriodAndName = unexpectedBetweenPeriodAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndGenericArgumentClause = unexpectedBetweenNameAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause?.createGenericArgumentClause()
  }
  /// Builds a `MemberTypeIdentifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberTypeIdentifierSyntax`.
  func buildMemberTypeIdentifier(format: Format) -> MemberTypeIdentifierSyntax {
    var result = MemberTypeIdentifierSyntax(unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format), baseType: baseType.buildType(format: format), unexpectedBetweenBaseTypeAndPeriod?.buildUnexpectedNodes(format: format), period: period.buildToken(format: format), unexpectedBetweenPeriodAndName?.buildUnexpectedNodes(format: format), name: name.buildToken(format: format), unexpectedBetweenNameAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: genericArgumentClause?.buildGenericArgumentClause(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildMemberTypeIdentifier(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsMemberTypeIdentifier`.
  public func createMemberTypeIdentifier() -> MemberTypeIdentifier {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `MemberTypeIdentifier` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ClassRestrictionType: TypeBuildable, ExpressibleAsClassRestrictionType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeClassKeyword: UnexpectedNodes?
  var classKeyword: Token
  /// Creates a `ClassRestrictionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeClassKeyword: 
  ///   - classKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeClassKeyword = unexpectedBeforeClassKeyword?.createUnexpectedNodes()
    self.classKeyword = classKeyword
    assert(classKeyword.text == #"class"#)
  }
  /// Builds a `ClassRestrictionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClassRestrictionTypeSyntax`.
  func buildClassRestrictionType(format: Format) -> ClassRestrictionTypeSyntax {
    var result = ClassRestrictionTypeSyntax(unexpectedBeforeClassKeyword?.buildUnexpectedNodes(format: format), classKeyword: classKeyword.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildClassRestrictionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsClassRestrictionType`.
  public func createClassRestrictionType() -> ClassRestrictionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ClassRestrictionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ArrayType: TypeBuildable, ExpressibleAsArrayType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftSquareBracket: UnexpectedNodes?
  var leftSquareBracket: Token
  var unexpectedBetweenLeftSquareBracketAndElementType: UnexpectedNodes?
  var elementType: TypeBuildable
  var unexpectedBetweenElementTypeAndRightSquareBracket: UnexpectedNodes?
  var rightSquareBracket: Token
  /// Creates a `ArrayType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquareBracket: 
  ///   - leftSquareBracket: 
  ///   - unexpectedBetweenLeftSquareBracketAndElementType: 
  ///   - elementType: 
  ///   - unexpectedBetweenElementTypeAndRightSquareBracket: 
  ///   - rightSquareBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquareBracket: ExpressibleAsUnexpectedNodes? = nil, leftSquareBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareBracketAndElementType: ExpressibleAsUnexpectedNodes? = nil, elementType: ExpressibleAsTypeBuildable, unexpectedBetweenElementTypeAndRightSquareBracket: ExpressibleAsUnexpectedNodes? = nil, rightSquareBracket: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftSquareBracket = unexpectedBeforeLeftSquareBracket?.createUnexpectedNodes()
    self.leftSquareBracket = leftSquareBracket
    assert(leftSquareBracket.text == #"["#)
    self.unexpectedBetweenLeftSquareBracketAndElementType = unexpectedBetweenLeftSquareBracketAndElementType?.createUnexpectedNodes()
    self.elementType = elementType.createTypeBuildable()
    self.unexpectedBetweenElementTypeAndRightSquareBracket = unexpectedBetweenElementTypeAndRightSquareBracket?.createUnexpectedNodes()
    self.rightSquareBracket = rightSquareBracket
    assert(rightSquareBracket.text == #"]"#)
  }
  /// Builds a `ArrayTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayTypeSyntax`.
  func buildArrayType(format: Format) -> ArrayTypeSyntax {
    var result = ArrayTypeSyntax(unexpectedBeforeLeftSquareBracket?.buildUnexpectedNodes(format: format), leftSquareBracket: leftSquareBracket.buildToken(format: format), unexpectedBetweenLeftSquareBracketAndElementType?.buildUnexpectedNodes(format: format), elementType: elementType.buildType(format: format), unexpectedBetweenElementTypeAndRightSquareBracket?.buildUnexpectedNodes(format: format), rightSquareBracket: rightSquareBracket.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildArrayType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrayType`.
  public func createArrayType() -> ArrayType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ArrayType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct DictionaryType: TypeBuildable, ExpressibleAsDictionaryType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftSquareBracket: UnexpectedNodes?
  var leftSquareBracket: Token
  var unexpectedBetweenLeftSquareBracketAndKeyType: UnexpectedNodes?
  var keyType: TypeBuildable
  var unexpectedBetweenKeyTypeAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndValueType: UnexpectedNodes?
  var valueType: TypeBuildable
  var unexpectedBetweenValueTypeAndRightSquareBracket: UnexpectedNodes?
  var rightSquareBracket: Token
  /// Creates a `DictionaryType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquareBracket: 
  ///   - leftSquareBracket: 
  ///   - unexpectedBetweenLeftSquareBracketAndKeyType: 
  ///   - keyType: 
  ///   - unexpectedBetweenKeyTypeAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValueType: 
  ///   - valueType: 
  ///   - unexpectedBetweenValueTypeAndRightSquareBracket: 
  ///   - rightSquareBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquareBracket: ExpressibleAsUnexpectedNodes? = nil, leftSquareBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareBracketAndKeyType: ExpressibleAsUnexpectedNodes? = nil, keyType: ExpressibleAsTypeBuildable, unexpectedBetweenKeyTypeAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValueType: ExpressibleAsUnexpectedNodes? = nil, valueType: ExpressibleAsTypeBuildable, unexpectedBetweenValueTypeAndRightSquareBracket: ExpressibleAsUnexpectedNodes? = nil, rightSquareBracket: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftSquareBracket = unexpectedBeforeLeftSquareBracket?.createUnexpectedNodes()
    self.leftSquareBracket = leftSquareBracket
    assert(leftSquareBracket.text == #"["#)
    self.unexpectedBetweenLeftSquareBracketAndKeyType = unexpectedBetweenLeftSquareBracketAndKeyType?.createUnexpectedNodes()
    self.keyType = keyType.createTypeBuildable()
    self.unexpectedBetweenKeyTypeAndColon = unexpectedBetweenKeyTypeAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValueType = unexpectedBetweenColonAndValueType?.createUnexpectedNodes()
    self.valueType = valueType.createTypeBuildable()
    self.unexpectedBetweenValueTypeAndRightSquareBracket = unexpectedBetweenValueTypeAndRightSquareBracket?.createUnexpectedNodes()
    self.rightSquareBracket = rightSquareBracket
    assert(rightSquareBracket.text == #"]"#)
  }
  /// Builds a `DictionaryTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryTypeSyntax`.
  func buildDictionaryType(format: Format) -> DictionaryTypeSyntax {
    var result = DictionaryTypeSyntax(unexpectedBeforeLeftSquareBracket?.buildUnexpectedNodes(format: format), leftSquareBracket: leftSquareBracket.buildToken(format: format), unexpectedBetweenLeftSquareBracketAndKeyType?.buildUnexpectedNodes(format: format), keyType: keyType.buildType(format: format), unexpectedBetweenKeyTypeAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndValueType?.buildUnexpectedNodes(format: format), valueType: valueType.buildType(format: format), unexpectedBetweenValueTypeAndRightSquareBracket?.buildUnexpectedNodes(format: format), rightSquareBracket: rightSquareBracket.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildDictionaryType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryType`.
  public func createDictionaryType() -> DictionaryType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `DictionaryType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct MetatypeType: TypeBuildable, ExpressibleAsMetatypeType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeBaseType: UnexpectedNodes?
  var baseType: TypeBuildable
  var unexpectedBetweenBaseTypeAndPeriod: UnexpectedNodes?
  var period: Token
  var unexpectedBetweenPeriodAndTypeOrProtocol: UnexpectedNodes?
  var typeOrProtocol: Token
  /// Creates a `MetatypeType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: 
  ///   - unexpectedBetweenBaseTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndTypeOrProtocol: 
  ///   - typeOrProtocol: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndTypeOrProtocol: ExpressibleAsUnexpectedNodes? = nil, typeOrProtocol: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeBaseType = unexpectedBeforeBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
    self.unexpectedBetweenBaseTypeAndPeriod = unexpectedBetweenBaseTypeAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."#)
    self.unexpectedBetweenPeriodAndTypeOrProtocol = unexpectedBetweenPeriodAndTypeOrProtocol?.createUnexpectedNodes()
    self.typeOrProtocol = typeOrProtocol
    assert(typeOrProtocol.text == #"Type"# || typeOrProtocol.text == #"Protocol"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndTypeOrProtocol: ExpressibleAsUnexpectedNodes? = nil, typeOrProtocol: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBaseType: unexpectedBeforeBaseType, baseType: baseType, unexpectedBetweenBaseTypeAndPeriod: unexpectedBetweenBaseTypeAndPeriod, period: period, unexpectedBetweenPeriodAndTypeOrProtocol: unexpectedBetweenPeriodAndTypeOrProtocol, typeOrProtocol: Token.`identifier`(typeOrProtocol))
  }
  /// Builds a `MetatypeTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MetatypeTypeSyntax`.
  func buildMetatypeType(format: Format) -> MetatypeTypeSyntax {
    var result = MetatypeTypeSyntax(unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format), baseType: baseType.buildType(format: format), unexpectedBetweenBaseTypeAndPeriod?.buildUnexpectedNodes(format: format), period: period.buildToken(format: format), unexpectedBetweenPeriodAndTypeOrProtocol?.buildUnexpectedNodes(format: format), typeOrProtocol: typeOrProtocol.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildMetatypeType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsMetatypeType`.
  public func createMetatypeType() -> MetatypeType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `MetatypeType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct OptionalType: TypeBuildable, ExpressibleAsOptionalType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWrappedType: UnexpectedNodes?
  var wrappedType: TypeBuildable
  var unexpectedBetweenWrappedTypeAndQuestionMark: UnexpectedNodes?
  var questionMark: Token
  /// Creates a `OptionalType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrappedType: 
  ///   - wrappedType: 
  ///   - unexpectedBetweenWrappedTypeAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWrappedType: ExpressibleAsUnexpectedNodes? = nil, wrappedType: ExpressibleAsTypeBuildable, unexpectedBetweenWrappedTypeAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWrappedType = unexpectedBeforeWrappedType?.createUnexpectedNodes()
    self.wrappedType = wrappedType.createTypeBuildable()
    self.unexpectedBetweenWrappedTypeAndQuestionMark = unexpectedBetweenWrappedTypeAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
  }
  /// Builds a `OptionalTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalTypeSyntax`.
  func buildOptionalType(format: Format) -> OptionalTypeSyntax {
    var result = OptionalTypeSyntax(unexpectedBeforeWrappedType?.buildUnexpectedNodes(format: format), wrappedType: wrappedType.buildType(format: format), unexpectedBetweenWrappedTypeAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: questionMark.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildOptionalType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalType`.
  public func createOptionalType() -> OptionalType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `OptionalType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ConstrainedSugarType: TypeBuildable, ExpressibleAsConstrainedSugarType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeSomeOrAnySpecifier: UnexpectedNodes?
  var someOrAnySpecifier: Token
  var unexpectedBetweenSomeOrAnySpecifierAndBaseType: UnexpectedNodes?
  var baseType: TypeBuildable
  /// Creates a `ConstrainedSugarType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSomeOrAnySpecifier: 
  ///   - someOrAnySpecifier: 
  ///   - unexpectedBetweenSomeOrAnySpecifierAndBaseType: 
  ///   - baseType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSomeOrAnySpecifier: ExpressibleAsUnexpectedNodes? = nil, someOrAnySpecifier: Token, unexpectedBetweenSomeOrAnySpecifierAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeSomeOrAnySpecifier = unexpectedBeforeSomeOrAnySpecifier?.createUnexpectedNodes()
    self.someOrAnySpecifier = someOrAnySpecifier
    assert(someOrAnySpecifier.text == #"some"# || someOrAnySpecifier.text == #"any"#)
    self.unexpectedBetweenSomeOrAnySpecifierAndBaseType = unexpectedBetweenSomeOrAnySpecifierAndBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSomeOrAnySpecifier: ExpressibleAsUnexpectedNodes? = nil, someOrAnySpecifier: String, unexpectedBetweenSomeOrAnySpecifierAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSomeOrAnySpecifier: unexpectedBeforeSomeOrAnySpecifier, someOrAnySpecifier: Token.`identifier`(someOrAnySpecifier), unexpectedBetweenSomeOrAnySpecifierAndBaseType: unexpectedBetweenSomeOrAnySpecifierAndBaseType, baseType: baseType)
  }
  /// Builds a `ConstrainedSugarTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConstrainedSugarTypeSyntax`.
  func buildConstrainedSugarType(format: Format) -> ConstrainedSugarTypeSyntax {
    var result = ConstrainedSugarTypeSyntax(unexpectedBeforeSomeOrAnySpecifier?.buildUnexpectedNodes(format: format), someOrAnySpecifier: someOrAnySpecifier.buildToken(format: format), unexpectedBetweenSomeOrAnySpecifierAndBaseType?.buildUnexpectedNodes(format: format), baseType: baseType.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildConstrainedSugarType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsConstrainedSugarType`.
  public func createConstrainedSugarType() -> ConstrainedSugarType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ConstrainedSugarType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ImplicitlyUnwrappedOptionalType: TypeBuildable, ExpressibleAsImplicitlyUnwrappedOptionalType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWrappedType: UnexpectedNodes?
  var wrappedType: TypeBuildable
  var unexpectedBetweenWrappedTypeAndExclamationMark: UnexpectedNodes?
  var exclamationMark: Token
  /// Creates a `ImplicitlyUnwrappedOptionalType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrappedType: 
  ///   - wrappedType: 
  ///   - unexpectedBetweenWrappedTypeAndExclamationMark: 
  ///   - exclamationMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWrappedType: ExpressibleAsUnexpectedNodes? = nil, wrappedType: ExpressibleAsTypeBuildable, unexpectedBetweenWrappedTypeAndExclamationMark: ExpressibleAsUnexpectedNodes? = nil, exclamationMark: Token = Token.`exclamationMark`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWrappedType = unexpectedBeforeWrappedType?.createUnexpectedNodes()
    self.wrappedType = wrappedType.createTypeBuildable()
    self.unexpectedBetweenWrappedTypeAndExclamationMark = unexpectedBetweenWrappedTypeAndExclamationMark?.createUnexpectedNodes()
    self.exclamationMark = exclamationMark
    assert(exclamationMark.text == #"!"#)
  }
  /// Builds a `ImplicitlyUnwrappedOptionalTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImplicitlyUnwrappedOptionalTypeSyntax`.
  func buildImplicitlyUnwrappedOptionalType(format: Format) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    var result = ImplicitlyUnwrappedOptionalTypeSyntax(unexpectedBeforeWrappedType?.buildUnexpectedNodes(format: format), wrappedType: wrappedType.buildType(format: format), unexpectedBetweenWrappedTypeAndExclamationMark?.buildUnexpectedNodes(format: format), exclamationMark: exclamationMark.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildImplicitlyUnwrappedOptionalType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsImplicitlyUnwrappedOptionalType`.
  public func createImplicitlyUnwrappedOptionalType() -> ImplicitlyUnwrappedOptionalType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ImplicitlyUnwrappedOptionalType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct CompositionTypeElement: SyntaxBuildable, ExpressibleAsCompositionTypeElement {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeType: UnexpectedNodes?
  var type: TypeBuildable
  var unexpectedBetweenTypeAndAmpersand: UnexpectedNodes?
  var ampersand: Token?
  /// Creates a `CompositionTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndAmpersand: 
  ///   - ampersand: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndAmpersand: ExpressibleAsUnexpectedNodes? = nil, ampersand: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
    self.unexpectedBetweenTypeAndAmpersand = unexpectedBetweenTypeAndAmpersand?.createUnexpectedNodes()
    self.ampersand = ampersand
    assert(ampersand == nil || ampersand!.text == #"&"#)
  }
  /// Builds a `CompositionTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CompositionTypeElementSyntax`.
  func buildCompositionTypeElement(format: Format) -> CompositionTypeElementSyntax {
    var result = CompositionTypeElementSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: type.buildType(format: format), unexpectedBetweenTypeAndAmpersand?.buildUnexpectedNodes(format: format), ampersand: ampersand?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCompositionTypeElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCompositionTypeElement`.
  public func createCompositionTypeElement() -> CompositionTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CompositionTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct CompositionType: TypeBuildable, ExpressibleAsCompositionType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeElements: UnexpectedNodes?
  var elements: CompositionTypeElementList
  /// Creates a `CompositionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsCompositionTypeElementList) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeElements = unexpectedBeforeElements?.createUnexpectedNodes()
    self.elements = elements.createCompositionTypeElementList()
  }
  /// Builds a `CompositionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CompositionTypeSyntax`.
  func buildCompositionType(format: Format) -> CompositionTypeSyntax {
    var result = CompositionTypeSyntax(unexpectedBeforeElements?.buildUnexpectedNodes(format: format), elements: elements.buildCompositionTypeElementList(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildCompositionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsCompositionType`.
  public func createCompositionType() -> CompositionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `CompositionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct PackExpansionType: TypeBuildable, ExpressibleAsPackExpansionType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePatternType: UnexpectedNodes?
  var patternType: TypeBuildable
  var unexpectedBetweenPatternTypeAndEllipsis: UnexpectedNodes?
  var ellipsis: Token
  /// Creates a `PackExpansionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePatternType: 
  ///   - patternType: 
  ///   - unexpectedBetweenPatternTypeAndEllipsis: 
  ///   - ellipsis: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePatternType: ExpressibleAsUnexpectedNodes? = nil, patternType: ExpressibleAsTypeBuildable, unexpectedBetweenPatternTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token = Token.`ellipsis`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePatternType = unexpectedBeforePatternType?.createUnexpectedNodes()
    self.patternType = patternType.createTypeBuildable()
    self.unexpectedBetweenPatternTypeAndEllipsis = unexpectedBetweenPatternTypeAndEllipsis?.createUnexpectedNodes()
    self.ellipsis = ellipsis
    assert(ellipsis.text == #"..."#)
  }
  /// Builds a `PackExpansionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PackExpansionTypeSyntax`.
  func buildPackExpansionType(format: Format) -> PackExpansionTypeSyntax {
    var result = PackExpansionTypeSyntax(unexpectedBeforePatternType?.buildUnexpectedNodes(format: format), patternType: patternType.buildType(format: format), unexpectedBetweenPatternTypeAndEllipsis?.buildUnexpectedNodes(format: format), ellipsis: ellipsis.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildPackExpansionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsPackExpansionType`.
  public func createPackExpansionType() -> PackExpansionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `PackExpansionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TupleTypeElement: SyntaxBuildable, ExpressibleAsTupleTypeElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeInOut: UnexpectedNodes?
  var inOut: Token?
  var unexpectedBetweenInOutAndName: UnexpectedNodes?
  var name: Token?
  var unexpectedBetweenNameAndSecondName: UnexpectedNodes?
  var secondName: Token?
  var unexpectedBetweenSecondNameAndColon: UnexpectedNodes?
  var colon: Token?
  var unexpectedBetweenColonAndType: UnexpectedNodes?
  var type: TypeBuildable
  var unexpectedBetweenTypeAndEllipsis: UnexpectedNodes?
  var ellipsis: Token?
  var unexpectedBetweenEllipsisAndInitializer: UnexpectedNodes?
  var initializer: InitializerClause?
  var unexpectedBetweenInitializerAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `TupleTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeInOut: 
  ///   - inOut: 
  ///   - unexpectedBetweenInOutAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndSecondName: 
  ///   - secondName: 
  ///   - unexpectedBetweenSecondNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndEllipsis: 
  ///   - ellipsis: 
  ///   - unexpectedBetweenEllipsisAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeInOut: ExpressibleAsUnexpectedNodes? = nil, inOut: Token? = nil, unexpectedBetweenInOutAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndSecondName: ExpressibleAsUnexpectedNodes? = nil, secondName: Token? = nil, unexpectedBetweenSecondNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token? = nil, unexpectedBetweenEllipsisAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil, unexpectedBetweenInitializerAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeInOut = unexpectedBeforeInOut?.createUnexpectedNodes()
    self.inOut = inOut
    assert(inOut == nil || inOut!.text == #"inout"#)
    self.unexpectedBetweenInOutAndName = unexpectedBetweenInOutAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndSecondName = unexpectedBetweenNameAndSecondName?.createUnexpectedNodes()
    self.secondName = secondName
    self.unexpectedBetweenSecondNameAndColon = unexpectedBetweenSecondNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndType = unexpectedBetweenColonAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
    self.unexpectedBetweenTypeAndEllipsis = unexpectedBetweenTypeAndEllipsis?.createUnexpectedNodes()
    self.ellipsis = ellipsis
    assert(ellipsis == nil || ellipsis!.text == #"..."#)
    self.unexpectedBetweenEllipsisAndInitializer = unexpectedBetweenEllipsisAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createInitializerClause()
    self.unexpectedBetweenInitializerAndTrailingComma = unexpectedBetweenInitializerAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `TupleTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleTypeElementSyntax`.
  func buildTupleTypeElement(format: Format) -> TupleTypeElementSyntax {
    var result = TupleTypeElementSyntax(unexpectedBeforeInOut?.buildUnexpectedNodes(format: format), inOut: inOut?.buildToken(format: format), unexpectedBetweenInOutAndName?.buildUnexpectedNodes(format: format), name: name?.buildToken(format: format), unexpectedBetweenNameAndSecondName?.buildUnexpectedNodes(format: format), secondName: secondName?.buildToken(format: format), unexpectedBetweenSecondNameAndColon?.buildUnexpectedNodes(format: format), colon: colon?.buildToken(format: format), unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format), type: type.buildType(format: format), unexpectedBetweenTypeAndEllipsis?.buildUnexpectedNodes(format: format), ellipsis: ellipsis?.buildToken(format: format), unexpectedBetweenEllipsisAndInitializer?.buildUnexpectedNodes(format: format), initializer: initializer?.buildInitializerClause(format: format), unexpectedBetweenInitializerAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTupleTypeElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTupleTypeElement`.
  public func createTupleTypeElement() -> TupleTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TupleTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TupleType: TypeBuildable, ExpressibleAsTupleType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndElements: UnexpectedNodes?
  var elements: TupleTypeElementList
  var unexpectedBetweenElementsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `TupleType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsTupleTypeElementList, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElements = unexpectedBetweenLeftParenAndElements?.createUnexpectedNodes()
    self.elements = elements.createTupleTypeElementList()
    self.unexpectedBetweenElementsAndRightParen = unexpectedBetweenElementsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `TupleTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleTypeSyntax`.
  func buildTupleType(format: Format) -> TupleTypeSyntax {
    var result = TupleTypeSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndElements?.buildUnexpectedNodes(format: format), elements: elements.buildTupleTypeElementList(format: format), unexpectedBetweenElementsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildTupleType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsTupleType`.
  public func createTupleType() -> TupleType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `TupleType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct FunctionType: TypeBuildable, ExpressibleAsFunctionType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
  var arguments: TupleTypeElementList
  var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  var unexpectedBetweenRightParenAndAsyncKeyword: UnexpectedNodes?
  var asyncKeyword: Token?
  var unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: UnexpectedNodes?
  var throwsOrRethrowsKeyword: Token?
  var unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: UnexpectedNodes?
  var arrow: Token
  var unexpectedBetweenArrowAndReturnType: UnexpectedNodes?
  var returnType: TypeBuildable
  /// Creates a `FunctionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  ///   - unexpectedBetweenRightParenAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: 
  ///   - throwsOrRethrowsKeyword: 
  ///   - unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: 
  ///   - arrow: 
  ///   - unexpectedBetweenArrowAndReturnType: 
  ///   - returnType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsTupleTypeElementList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, unexpectedBetweenRightParenAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: ExpressibleAsUnexpectedNodes? = nil, arrow: Token = Token.`arrow`, unexpectedBetweenArrowAndReturnType: ExpressibleAsUnexpectedNodes? = nil, returnType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArguments = unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createTupleTypeElementList()
    self.unexpectedBetweenArgumentsAndRightParen = unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
    self.unexpectedBetweenRightParenAndAsyncKeyword = unexpectedBetweenRightParenAndAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword = unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword?.createUnexpectedNodes()
    self.throwsOrRethrowsKeyword = throwsOrRethrowsKeyword
    assert(throwsOrRethrowsKeyword == nil || throwsOrRethrowsKeyword!.text == #"throws"# || throwsOrRethrowsKeyword!.text == #"rethrows"# || throwsOrRethrowsKeyword!.text == #"throw"#)
    self.unexpectedBetweenThrowsOrRethrowsKeywordAndArrow = unexpectedBetweenThrowsOrRethrowsKeywordAndArrow?.createUnexpectedNodes()
    self.arrow = arrow
    assert(arrow.text == #"->"#)
    self.unexpectedBetweenArrowAndReturnType = unexpectedBetweenArrowAndReturnType?.createUnexpectedNodes()
    self.returnType = returnType.createTypeBuildable()
  }
  /// Builds a `FunctionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionTypeSyntax`.
  func buildFunctionType(format: Format) -> FunctionTypeSyntax {
    var result = FunctionTypeSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format), arguments: arguments.buildTupleTypeElementList(format: format), unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format), unexpectedBetweenRightParenAndAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: asyncKeyword?.buildToken(format: format), unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword?.buildUnexpectedNodes(format: format), throwsOrRethrowsKeyword: throwsOrRethrowsKeyword?.buildToken(format: format), unexpectedBetweenThrowsOrRethrowsKeywordAndArrow?.buildUnexpectedNodes(format: format), arrow: arrow.buildToken(format: format), unexpectedBetweenArrowAndReturnType?.buildUnexpectedNodes(format: format), returnType: returnType.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildFunctionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionType`.
  public func createFunctionType() -> FunctionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `FunctionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AttributedType: TypeBuildable, ExpressibleAsAttributedType {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeSpecifier: UnexpectedNodes?
  var specifier: Token?
  var unexpectedBetweenSpecifierAndAttributes: UnexpectedNodes?
  var attributes: AttributeList?
  var unexpectedBetweenAttributesAndBaseType: UnexpectedNodes?
  var baseType: TypeBuildable
  /// Creates a `AttributedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSpecifier: 
  ///   - specifier: 
  ///   - unexpectedBetweenSpecifierAndAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndBaseType: 
  ///   - baseType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: Token? = nil, unexpectedBetweenSpecifierAndAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeSpecifier = unexpectedBeforeSpecifier?.createUnexpectedNodes()
    self.specifier = specifier
    assert(specifier == nil || specifier!.text == #"inout"# || specifier!.text == #"__shared"# || specifier!.text == #"__owned"#)
    self.unexpectedBetweenSpecifierAndAttributes = unexpectedBetweenSpecifierAndAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndBaseType = unexpectedBetweenAttributesAndBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
  }
  /// Builds a `AttributedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AttributedTypeSyntax`.
  func buildAttributedType(format: Format) -> AttributedTypeSyntax {
    var result = AttributedTypeSyntax(unexpectedBeforeSpecifier?.buildUnexpectedNodes(format: format), specifier: specifier?.buildToken(format: format), unexpectedBetweenSpecifierAndAttributes?.buildUnexpectedNodes(format: format), attributes: attributes?.buildAttributeList(format: format), unexpectedBetweenAttributesAndBaseType?.buildUnexpectedNodes(format: format), baseType: baseType.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildAttributedType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsAttributedType`.
  public func createAttributedType() -> AttributedType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `AttributedType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct GenericArgument: SyntaxBuildable, ExpressibleAsGenericArgument, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeArgumentType: UnexpectedNodes?
  var argumentType: TypeBuildable
  var unexpectedBetweenArgumentTypeAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `GenericArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeArgumentType: 
  ///   - argumentType: 
  ///   - unexpectedBetweenArgumentTypeAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeArgumentType: ExpressibleAsUnexpectedNodes? = nil, argumentType: ExpressibleAsTypeBuildable, unexpectedBetweenArgumentTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeArgumentType = unexpectedBeforeArgumentType?.createUnexpectedNodes()
    self.argumentType = argumentType.createTypeBuildable()
    self.unexpectedBetweenArgumentTypeAndTrailingComma = unexpectedBetweenArgumentTypeAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `GenericArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericArgumentSyntax`.
  func buildGenericArgument(format: Format) -> GenericArgumentSyntax {
    var result = GenericArgumentSyntax(unexpectedBeforeArgumentType?.buildUnexpectedNodes(format: format), argumentType: argumentType.buildType(format: format), unexpectedBetweenArgumentTypeAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericArgument`.
  public func createGenericArgument() -> GenericArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct GenericArgumentClause: SyntaxBuildable, ExpressibleAsGenericArgumentClause {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
  var leftAngleBracket: Token
  var unexpectedBetweenLeftAngleBracketAndArguments: UnexpectedNodes?
  var arguments: GenericArgumentList
  var unexpectedBetweenArgumentsAndRightAngleBracket: UnexpectedNodes?
  var rightAngleBracket: Token
  /// Creates a `GenericArgumentClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsGenericArgumentList, unexpectedBetweenArgumentsAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftAngleBracket = unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes()
    self.leftAngleBracket = leftAngleBracket
    assert(leftAngleBracket.text == #"<"#)
    self.unexpectedBetweenLeftAngleBracketAndArguments = unexpectedBetweenLeftAngleBracketAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createGenericArgumentList()
    self.unexpectedBetweenArgumentsAndRightAngleBracket = unexpectedBetweenArgumentsAndRightAngleBracket?.createUnexpectedNodes()
    self.rightAngleBracket = rightAngleBracket
    assert(rightAngleBracket.text == #">"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndArguments: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentsAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`, @GenericArgumentListBuilder argumentsBuilder: () -> ExpressibleAsGenericArgumentList =  {
    GenericArgumentList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket, leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndArguments: unexpectedBetweenLeftAngleBracketAndArguments, arguments: argumentsBuilder(), unexpectedBetweenArgumentsAndRightAngleBracket: unexpectedBetweenArgumentsAndRightAngleBracket, rightAngleBracket: rightAngleBracket)
  }
  /// Builds a `GenericArgumentClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericArgumentClauseSyntax`.
  func buildGenericArgumentClause(format: Format) -> GenericArgumentClauseSyntax {
    var result = GenericArgumentClauseSyntax(unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format), leftAngleBracket: leftAngleBracket.buildToken(format: format), unexpectedBetweenLeftAngleBracketAndArguments?.buildUnexpectedNodes(format: format), arguments: arguments.buildGenericArgumentList(format: format), unexpectedBetweenArgumentsAndRightAngleBracket?.buildUnexpectedNodes(format: format), rightAngleBracket: rightAngleBracket.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericArgumentClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericArgumentClause`.
  public func createGenericArgumentClause() -> GenericArgumentClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericArgumentClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TypeAnnotation: SyntaxBuildable, ExpressibleAsTypeAnnotation {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndType: UnexpectedNodes?
  var type: TypeBuildable
  /// Creates a `TypeAnnotation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeColon = unexpectedBeforeColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndType = unexpectedBetweenColonAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `TypeAnnotationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeAnnotationSyntax`.
  func buildTypeAnnotation(format: Format) -> TypeAnnotationSyntax {
    var result = TypeAnnotationSyntax(unexpectedBeforeColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format), type: type.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTypeAnnotation(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeAnnotation`.
  public func createTypeAnnotation() -> TypeAnnotation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeAnnotation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct EnumCasePattern: PatternBuildable, ExpressibleAsEnumCasePattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeType: UnexpectedNodes?
  var type: TypeBuildable?
  var unexpectedBetweenTypeAndPeriod: UnexpectedNodes?
  var period: Token
  var unexpectedBetweenPeriodAndCaseName: UnexpectedNodes?
  var caseName: Token
  var unexpectedBetweenCaseNameAndAssociatedTuple: UnexpectedNodes?
  var associatedTuple: TuplePattern?
  /// Creates a `EnumCasePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndCaseName: 
  ///   - caseName: 
  ///   - unexpectedBetweenCaseNameAndAssociatedTuple: 
  ///   - associatedTuple: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndCaseName: ExpressibleAsUnexpectedNodes? = nil, caseName: Token, unexpectedBetweenCaseNameAndAssociatedTuple: ExpressibleAsUnexpectedNodes? = nil, associatedTuple: ExpressibleAsTuplePattern? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type?.createTypeBuildable()
    self.unexpectedBetweenTypeAndPeriod = unexpectedBetweenTypeAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."#)
    self.unexpectedBetweenPeriodAndCaseName = unexpectedBetweenPeriodAndCaseName?.createUnexpectedNodes()
    self.caseName = caseName
    self.unexpectedBetweenCaseNameAndAssociatedTuple = unexpectedBetweenCaseNameAndAssociatedTuple?.createUnexpectedNodes()
    self.associatedTuple = associatedTuple?.createTuplePattern()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndCaseName: ExpressibleAsUnexpectedNodes? = nil, caseName: String, unexpectedBetweenCaseNameAndAssociatedTuple: ExpressibleAsUnexpectedNodes? = nil, associatedTuple: ExpressibleAsTuplePattern? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeType: unexpectedBeforeType, type: type, unexpectedBetweenTypeAndPeriod: unexpectedBetweenTypeAndPeriod, period: period, unexpectedBetweenPeriodAndCaseName: unexpectedBetweenPeriodAndCaseName, caseName: Token.`identifier`(caseName), unexpectedBetweenCaseNameAndAssociatedTuple: unexpectedBetweenCaseNameAndAssociatedTuple, associatedTuple: associatedTuple)
  }
  /// Builds a `EnumCasePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCasePatternSyntax`.
  func buildEnumCasePattern(format: Format) -> EnumCasePatternSyntax {
    var result = EnumCasePatternSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: type?.buildType(format: format), unexpectedBetweenTypeAndPeriod?.buildUnexpectedNodes(format: format), period: period.buildToken(format: format), unexpectedBetweenPeriodAndCaseName?.buildUnexpectedNodes(format: format), caseName: caseName.buildToken(format: format), unexpectedBetweenCaseNameAndAssociatedTuple?.buildUnexpectedNodes(format: format), associatedTuple: associatedTuple?.buildTuplePattern(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildEnumCasePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCasePattern`.
  public func createEnumCasePattern() -> EnumCasePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `EnumCasePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IsTypePattern: PatternBuildable, ExpressibleAsIsTypePattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIsKeyword: UnexpectedNodes?
  var isKeyword: Token
  var unexpectedBetweenIsKeywordAndType: UnexpectedNodes?
  var type: TypeBuildable
  /// Creates a `IsTypePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIsKeyword: 
  ///   - isKeyword: 
  ///   - unexpectedBetweenIsKeywordAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIsKeyword: ExpressibleAsUnexpectedNodes? = nil, isKeyword: Token = Token.`is`, unexpectedBetweenIsKeywordAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIsKeyword = unexpectedBeforeIsKeyword?.createUnexpectedNodes()
    self.isKeyword = isKeyword
    assert(isKeyword.text == #"is"#)
    self.unexpectedBetweenIsKeywordAndType = unexpectedBetweenIsKeywordAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `IsTypePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IsTypePatternSyntax`.
  func buildIsTypePattern(format: Format) -> IsTypePatternSyntax {
    var result = IsTypePatternSyntax(unexpectedBeforeIsKeyword?.buildUnexpectedNodes(format: format), isKeyword: isKeyword.buildToken(format: format), unexpectedBetweenIsKeywordAndType?.buildUnexpectedNodes(format: format), type: type.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildIsTypePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsIsTypePattern`.
  public func createIsTypePattern() -> IsTypePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `IsTypePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct OptionalPattern: PatternBuildable, ExpressibleAsOptionalPattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeSubPattern: UnexpectedNodes?
  var subPattern: PatternBuildable
  var unexpectedBetweenSubPatternAndQuestionMark: UnexpectedNodes?
  var questionMark: Token
  /// Creates a `OptionalPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSubPattern: 
  ///   - subPattern: 
  ///   - unexpectedBetweenSubPatternAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSubPattern: ExpressibleAsUnexpectedNodes? = nil, subPattern: ExpressibleAsPatternBuildable, unexpectedBetweenSubPatternAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeSubPattern = unexpectedBeforeSubPattern?.createUnexpectedNodes()
    self.subPattern = subPattern.createPatternBuildable()
    self.unexpectedBetweenSubPatternAndQuestionMark = unexpectedBetweenSubPatternAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
  }
  /// Builds a `OptionalPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalPatternSyntax`.
  func buildOptionalPattern(format: Format) -> OptionalPatternSyntax {
    var result = OptionalPatternSyntax(unexpectedBeforeSubPattern?.buildUnexpectedNodes(format: format), subPattern: subPattern.buildPattern(format: format), unexpectedBetweenSubPatternAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: questionMark.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildOptionalPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalPattern`.
  public func createOptionalPattern() -> OptionalPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `OptionalPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct IdentifierPattern: PatternBuildable, ExpressibleAsIdentifierPattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeIdentifier: UnexpectedNodes?
  var identifier: Token
  /// Creates a `IdentifierPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
  }
  /// Builds a `IdentifierPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IdentifierPatternSyntax`.
  func buildIdentifierPattern(format: Format) -> IdentifierPatternSyntax {
    var result = IdentifierPatternSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: identifier.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildIdentifierPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsIdentifierPattern`.
  public func createIdentifierPattern() -> IdentifierPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `IdentifierPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct AsTypePattern: PatternBuildable, ExpressibleAsAsTypePattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePattern: UnexpectedNodes?
  var pattern: PatternBuildable
  var unexpectedBetweenPatternAndAsKeyword: UnexpectedNodes?
  var asKeyword: Token
  var unexpectedBetweenAsKeywordAndType: UnexpectedNodes?
  var type: TypeBuildable
  /// Creates a `AsTypePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndAsKeyword: 
  ///   - asKeyword: 
  ///   - unexpectedBetweenAsKeywordAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndAsKeyword: ExpressibleAsUnexpectedNodes? = nil, asKeyword: Token = Token.`as`, unexpectedBetweenAsKeywordAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndAsKeyword = unexpectedBetweenPatternAndAsKeyword?.createUnexpectedNodes()
    self.asKeyword = asKeyword
    assert(asKeyword.text == #"as"#)
    self.unexpectedBetweenAsKeywordAndType = unexpectedBetweenAsKeywordAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `AsTypePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AsTypePatternSyntax`.
  func buildAsTypePattern(format: Format) -> AsTypePatternSyntax {
    var result = AsTypePatternSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format), unexpectedBetweenPatternAndAsKeyword?.buildUnexpectedNodes(format: format), asKeyword: asKeyword.buildToken(format: format), unexpectedBetweenAsKeywordAndType?.buildUnexpectedNodes(format: format), type: type.buildType(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildAsTypePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsAsTypePattern`.
  public func createAsTypePattern() -> AsTypePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `AsTypePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TuplePattern: PatternBuildable, ExpressibleAsTuplePattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLeftParen: UnexpectedNodes?
  var leftParen: Token
  var unexpectedBetweenLeftParenAndElements: UnexpectedNodes?
  var elements: TuplePatternElementList
  var unexpectedBetweenElementsAndRightParen: UnexpectedNodes?
  var rightParen: Token
  /// Creates a `TuplePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsTuplePatternElementList, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElements = unexpectedBetweenLeftParenAndElements?.createUnexpectedNodes()
    self.elements = elements.createTuplePatternElementList()
    self.unexpectedBetweenElementsAndRightParen = unexpectedBetweenElementsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TuplePatternElementListBuilder elementsBuilder: () -> ExpressibleAsTuplePatternElementList =  {
    TuplePatternElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElements: unexpectedBetweenLeftParenAndElements, elements: elementsBuilder(), unexpectedBetweenElementsAndRightParen: unexpectedBetweenElementsAndRightParen, rightParen: rightParen)
  }
  /// Builds a `TuplePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TuplePatternSyntax`.
  func buildTuplePattern(format: Format) -> TuplePatternSyntax {
    var result = TuplePatternSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: leftParen.buildToken(format: format), unexpectedBetweenLeftParenAndElements?.buildUnexpectedNodes(format: format), elements: elements.buildTuplePatternElementList(format: format), unexpectedBetweenElementsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: rightParen.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildTuplePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsTuplePattern`.
  public func createTuplePattern() -> TuplePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `TuplePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct WildcardPattern: PatternBuildable, ExpressibleAsWildcardPattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeWildcard: UnexpectedNodes?
  var wildcard: Token
  var unexpectedBetweenWildcardAndTypeAnnotation: UnexpectedNodes?
  var typeAnnotation: TypeAnnotation?
  /// Creates a `WildcardPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWildcard: 
  ///   - wildcard: 
  ///   - unexpectedBetweenWildcardAndTypeAnnotation: 
  ///   - typeAnnotation: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWildcard: ExpressibleAsUnexpectedNodes? = nil, wildcard: Token = Token.`wildcard`, unexpectedBetweenWildcardAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeWildcard = unexpectedBeforeWildcard?.createUnexpectedNodes()
    self.wildcard = wildcard
    assert(wildcard.text == #"_"#)
    self.unexpectedBetweenWildcardAndTypeAnnotation = unexpectedBetweenWildcardAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
  }
  /// Builds a `WildcardPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WildcardPatternSyntax`.
  func buildWildcardPattern(format: Format) -> WildcardPatternSyntax {
    var result = WildcardPatternSyntax(unexpectedBeforeWildcard?.buildUnexpectedNodes(format: format), wildcard: wildcard.buildToken(format: format), unexpectedBetweenWildcardAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildWildcardPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsWildcardPattern`.
  public func createWildcardPattern() -> WildcardPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `WildcardPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct TuplePatternElement: SyntaxBuildable, ExpressibleAsTuplePatternElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabelName: UnexpectedNodes?
  var labelName: Token?
  var unexpectedBetweenLabelNameAndLabelColon: UnexpectedNodes?
  var labelColon: Token?
  var unexpectedBetweenLabelColonAndPattern: UnexpectedNodes?
  var pattern: PatternBuildable
  var unexpectedBetweenPatternAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `TuplePatternElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabelName: 
  ///   - labelName: 
  ///   - unexpectedBetweenLabelNameAndLabelColon: 
  ///   - labelColon: 
  ///   - unexpectedBetweenLabelColonAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: Token? = nil, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token? = nil, unexpectedBetweenLabelColonAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabelName = unexpectedBeforeLabelName?.createUnexpectedNodes()
    self.labelName = labelName
    self.unexpectedBetweenLabelNameAndLabelColon = unexpectedBetweenLabelNameAndLabelColon?.createUnexpectedNodes()
    self.labelColon = labelColon
    assert(labelColon == nil || labelColon!.text == #":"#)
    self.unexpectedBetweenLabelColonAndPattern = unexpectedBetweenLabelColonAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTrailingComma = unexpectedBetweenPatternAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: String?, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token? = nil, unexpectedBetweenLabelColonAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName, labelName: labelName.map {
      Token.`identifier`($0)
    }, unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon, labelColon: labelColon, unexpectedBetweenLabelColonAndPattern: unexpectedBetweenLabelColonAndPattern, pattern: pattern, unexpectedBetweenPatternAndTrailingComma: unexpectedBetweenPatternAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `TuplePatternElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TuplePatternElementSyntax`.
  func buildTuplePatternElement(format: Format) -> TuplePatternElementSyntax {
    var result = TuplePatternElementSyntax(unexpectedBeforeLabelName?.buildUnexpectedNodes(format: format), labelName: labelName?.buildToken(format: format), unexpectedBetweenLabelNameAndLabelColon?.buildUnexpectedNodes(format: format), labelColon: labelColon?.buildToken(format: format), unexpectedBetweenLabelColonAndPattern?.buildUnexpectedNodes(format: format), pattern: pattern.buildPattern(format: format), unexpectedBetweenPatternAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTuplePatternElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTuplePatternElement`.
  public func createTuplePatternElement() -> TuplePatternElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TuplePatternElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    var result = self
    result.trailingComma = withComma ? .comma : nil
    return result
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ExpressionPattern: PatternBuildable, ExpressibleAsExpressionPattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeExpression: UnexpectedNodes?
  var expression: ExprBuildable
  /// Creates a `ExpressionPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `ExpressionPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionPatternSyntax`.
  func buildExpressionPattern(format: Format) -> ExpressionPatternSyntax {
    var result = ExpressionPatternSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: expression.buildExpr(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildExpressionPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionPattern`.
  public func createExpressionPattern() -> ExpressionPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `ExpressionPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
public struct ValueBindingPattern: PatternBuildable, ExpressibleAsValueBindingPattern {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLetOrVarKeyword: UnexpectedNodes?
  var letOrVarKeyword: Token
  var unexpectedBetweenLetOrVarKeywordAndValuePattern: UnexpectedNodes?
  var valuePattern: PatternBuildable
  /// Creates a `ValueBindingPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndValuePattern: 
  ///   - valuePattern: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndValuePattern: ExpressibleAsUnexpectedNodes? = nil, valuePattern: ExpressibleAsPatternBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLetOrVarKeyword = unexpectedBeforeLetOrVarKeyword?.createUnexpectedNodes()
    self.letOrVarKeyword = letOrVarKeyword
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.unexpectedBetweenLetOrVarKeywordAndValuePattern = unexpectedBetweenLetOrVarKeywordAndValuePattern?.createUnexpectedNodes()
    self.valuePattern = valuePattern.createPatternBuildable()
  }
  /// Builds a `ValueBindingPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ValueBindingPatternSyntax`.
  func buildValueBindingPattern(format: Format) -> ValueBindingPatternSyntax {
    var result = ValueBindingPatternSyntax(unexpectedBeforeLetOrVarKeyword?.buildUnexpectedNodes(format: format), letOrVarKeyword: letOrVarKeyword.buildToken(format: format), unexpectedBetweenLetOrVarKeywordAndValuePattern?.buildUnexpectedNodes(format: format), valuePattern: valuePattern.buildPattern(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildValueBindingPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsValueBindingPattern`.
  public func createValueBindingPattern() -> ValueBindingPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `ValueBindingPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A single argument to an `@available` argument like `*`, `iOS 10.1`,or `message: "This has been deprecated"`.
public struct AvailabilityArgument: SyntaxBuildable, ExpressibleAsAvailabilityArgument {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeEntry: UnexpectedNodes?
  var entry: SyntaxBuildable
  var unexpectedBetweenEntryAndTrailingComma: UnexpectedNodes?
  var trailingComma: Token?
  /// Creates a `AvailabilityArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEntry: 
  ///   - entry: The actual argument
  ///   - unexpectedBetweenEntryAndTrailingComma: 
  ///   - trailingComma: A trailing comma if the argument is followed by anotherargument
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeEntry: ExpressibleAsUnexpectedNodes? = nil, entry: ExpressibleAsSyntaxBuildable, unexpectedBetweenEntryAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeEntry = unexpectedBeforeEntry?.createUnexpectedNodes()
    self.entry = entry.createSyntaxBuildable()
    self.unexpectedBetweenEntryAndTrailingComma = unexpectedBetweenEntryAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `AvailabilityArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityArgumentSyntax`.
  func buildAvailabilityArgument(format: Format) -> AvailabilityArgumentSyntax {
    var result = AvailabilityArgumentSyntax(unexpectedBeforeEntry?.buildUnexpectedNodes(format: format), entry: entry.buildSyntax(format: format), unexpectedBetweenEntryAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: trailingComma?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityArgument`.
  public func createAvailabilityArgument() -> AvailabilityArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A argument to an `@available` attribute that consists of a label anda value, e.g. `message: "This has been deprecated"`.
public struct AvailabilityLabeledArgument: SyntaxBuildable, ExpressibleAsAvailabilityLabeledArgument {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeLabel: UnexpectedNodes?
  var label: Token
  var unexpectedBetweenLabelAndColon: UnexpectedNodes?
  var colon: Token
  var unexpectedBetweenColonAndValue: UnexpectedNodes?
  var value: SyntaxBuildable
  /// Creates a `AvailabilityLabeledArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating label and value
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: The value of this labeled argument
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValue = unexpectedBetweenColonAndValue?.createUnexpectedNodes()
    self.value = value.createSyntaxBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsSyntaxBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: value)
  }
  /// Builds a `AvailabilityLabeledArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityLabeledArgumentSyntax`.
  func buildAvailabilityLabeledArgument(format: Format) -> AvailabilityLabeledArgumentSyntax {
    var result = AvailabilityLabeledArgumentSyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: label.buildToken(format: format), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: colon.buildToken(format: format), unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format), value: value.buildSyntax(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityLabeledArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityLabeledArgument`.
  public func createAvailabilityLabeledArgument() -> AvailabilityLabeledArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityLabeledArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// An argument to `@available` that restricts the availability on acertain platform to a version, e.g. `iOS 10` or `swift 3.4`.
public struct AvailabilityVersionRestriction: SyntaxBuildable, ExpressibleAsAvailabilityVersionRestriction {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforePlatform: UnexpectedNodes?
  var platform: Token
  var unexpectedBetweenPlatformAndVersion: UnexpectedNodes?
  var version: VersionTuple?
  /// Creates a `AvailabilityVersionRestriction` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePlatform: 
  ///   - platform: The name of the OS on which the availability should berestricted or 'swift' if the availability should berestricted based on a Swift version.
  ///   - unexpectedBetweenPlatformAndVersion: 
  ///   - version: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePlatform: ExpressibleAsUnexpectedNodes? = nil, platform: Token, unexpectedBetweenPlatformAndVersion: ExpressibleAsUnexpectedNodes? = nil, version: ExpressibleAsVersionTuple? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforePlatform = unexpectedBeforePlatform?.createUnexpectedNodes()
    self.platform = platform
    self.unexpectedBetweenPlatformAndVersion = unexpectedBetweenPlatformAndVersion?.createUnexpectedNodes()
    self.version = version?.createVersionTuple()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePlatform: ExpressibleAsUnexpectedNodes? = nil, platform: String, unexpectedBetweenPlatformAndVersion: ExpressibleAsUnexpectedNodes? = nil, version: ExpressibleAsVersionTuple? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePlatform: unexpectedBeforePlatform, platform: Token.`identifier`(platform), unexpectedBetweenPlatformAndVersion: unexpectedBetweenPlatformAndVersion, version: version)
  }
  /// Builds a `AvailabilityVersionRestrictionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityVersionRestrictionSyntax`.
  func buildAvailabilityVersionRestriction(format: Format) -> AvailabilityVersionRestrictionSyntax {
    var result = AvailabilityVersionRestrictionSyntax(unexpectedBeforePlatform?.buildUnexpectedNodes(format: format), platform: platform.buildToken(format: format), unexpectedBetweenPlatformAndVersion?.buildUnexpectedNodes(format: format), version: version?.buildVersionTuple(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityVersionRestriction(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityVersionRestriction`.
  public func createAvailabilityVersionRestriction() -> AvailabilityVersionRestriction {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityVersionRestriction` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
/// A version number of the form major.minor.patch in which the minorand patch part may be omitted.
public struct VersionTuple: SyntaxBuildable, ExpressibleAsVersionTuple {
  /// The leading trivia attached to this syntax node once built.
  var leadingTrivia: Trivia
  /// The trailing trivia attached to this syntax node once built.
  var trailingTrivia: Trivia
  var unexpectedBeforeMajorMinor: UnexpectedNodes?
  var majorMinor: SyntaxBuildable
  var unexpectedBetweenMajorMinorAndPatchPeriod: UnexpectedNodes?
  var patchPeriod: Token?
  var unexpectedBetweenPatchPeriodAndPatchVersion: UnexpectedNodes?
  var patchVersion: Token?
  /// Creates a `VersionTuple` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMajorMinor: 
  ///   - majorMinor: In case the version consists only of the major version, aninteger literal that specifies the major version. In casethe version consists of major and minor version number, afloating literal in which the decimal part is interpretedas the minor version.
  ///   - unexpectedBetweenMajorMinorAndPatchPeriod: 
  ///   - patchPeriod: If the version contains a patch number, the periodseparating the minor from the patch number.
  ///   - unexpectedBetweenPatchPeriodAndPatchVersion: 
  ///   - patchVersion: The patch version if specified.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeMajorMinor: ExpressibleAsUnexpectedNodes? = nil, majorMinor: ExpressibleAsSyntaxBuildable, unexpectedBetweenMajorMinorAndPatchPeriod: ExpressibleAsUnexpectedNodes? = nil, patchPeriod: Token? = nil, unexpectedBetweenPatchPeriodAndPatchVersion: ExpressibleAsUnexpectedNodes? = nil, patchVersion: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.trailingTrivia = trailingTrivia
    self.unexpectedBeforeMajorMinor = unexpectedBeforeMajorMinor?.createUnexpectedNodes()
    self.majorMinor = majorMinor.createSyntaxBuildable()
    self.unexpectedBetweenMajorMinorAndPatchPeriod = unexpectedBetweenMajorMinorAndPatchPeriod?.createUnexpectedNodes()
    self.patchPeriod = patchPeriod
    assert(patchPeriod == nil || patchPeriod!.text == #"."#)
    self.unexpectedBetweenPatchPeriodAndPatchVersion = unexpectedBetweenPatchPeriodAndPatchVersion?.createUnexpectedNodes()
    self.patchVersion = patchVersion
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMajorMinor: ExpressibleAsUnexpectedNodes? = nil, majorMinor: ExpressibleAsSyntaxBuildable, unexpectedBetweenMajorMinorAndPatchPeriod: ExpressibleAsUnexpectedNodes? = nil, patchPeriod: Token? = nil, unexpectedBetweenPatchPeriodAndPatchVersion: ExpressibleAsUnexpectedNodes? = nil, patchVersion: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMajorMinor: unexpectedBeforeMajorMinor, majorMinor: majorMinor, unexpectedBetweenMajorMinorAndPatchPeriod: unexpectedBetweenMajorMinorAndPatchPeriod, patchPeriod: patchPeriod, unexpectedBetweenPatchPeriodAndPatchVersion: unexpectedBetweenPatchPeriodAndPatchVersion, patchVersion: patchVersion.map {
      Token.`integerLiteral`($0)
    })
  }
  /// Builds a `VersionTupleSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `VersionTupleSyntax`.
  func buildVersionTuple(format: Format) -> VersionTupleSyntax {
    var result = VersionTupleSyntax(unexpectedBeforeMajorMinor?.buildUnexpectedNodes(format: format), majorMinor: majorMinor.buildSyntax(format: format), unexpectedBetweenMajorMinorAndPatchPeriod?.buildUnexpectedNodes(format: format), patchPeriod: patchPeriod?.buildToken(format: format), unexpectedBetweenPatchPeriodAndPatchVersion?.buildUnexpectedNodes(format: format), patchVersion: patchVersion?.buildToken(format: format))
    if !leadingTrivia.isEmpty {
      result = result.withLeadingTrivia(leadingTrivia + (result.leadingTrivia ?? []))
    }
    if !trailingTrivia.isEmpty {
      result = result.withTrailingTrivia(trailingTrivia + (result.trailingTrivia ?? []))
    }
    return format.format(syntax: result)
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildVersionTuple(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsVersionTuple`.
  public func createVersionTuple() -> VersionTuple {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `VersionTuple` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    var result = self
    result.leadingTrivia = leadingTrivia
    return result
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    var result = self
    result.trailingTrivia = trailingTrivia
    return result
  }
}
