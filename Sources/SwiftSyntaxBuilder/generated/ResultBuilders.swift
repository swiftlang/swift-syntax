
//// Automatically Generated by generate-swiftsyntaxbuilder
//// Do Not Edit Directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftSyntax

@resultBuilder
public struct AccessPathBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = AccessPathComponent
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = AccessPath
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension AccessPath {
  init(@AccessPathBuilder itemsBuilder: () -> AccessPath) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct AccessorListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = AccessorDecl
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = AccessorList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension AccessorList {
  init(@AccessorListBuilder itemsBuilder: () -> AccessorList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct ArrayElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = ArrayElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = ArrayElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension ArrayElementList {
  init(@ArrayElementListBuilder itemsBuilder: () -> ArrayElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct AttributeListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = AttributeList.Element
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = AttributeList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Attribute) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: CustomAttribute) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: IfConfigDecl) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension AttributeList {
  init(@AttributeListBuilder itemsBuilder: () -> AttributeList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct AvailabilitySpecListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = AvailabilityArgument
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = AvailabilitySpecList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension AvailabilitySpecList {
  init(@AvailabilitySpecListBuilder itemsBuilder: () -> AvailabilitySpecList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct BackDeployVersionListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = BackDeployVersionArgument
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = BackDeployVersionList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension BackDeployVersionList {
  init(@BackDeployVersionListBuilder itemsBuilder: () -> BackDeployVersionList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct CaseItemListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = CaseItem
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = CaseItemList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension CaseItemList {
  init(@CaseItemListBuilder itemsBuilder: () -> CaseItemList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct CatchClauseListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = CatchClause
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = CatchClauseList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension CatchClauseList {
  init(@CatchClauseListBuilder itemsBuilder: () -> CatchClauseList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct CatchItemListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = CatchItem
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = CatchItemList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension CatchItemList {
  init(@CatchItemListBuilder itemsBuilder: () -> CatchItemList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct ClosureCaptureItemListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = ClosureCaptureItem
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = ClosureCaptureItemList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension ClosureCaptureItemList {
  init(@ClosureCaptureItemListBuilder itemsBuilder: () -> ClosureCaptureItemList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct ClosureParamListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = ClosureParam
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = ClosureParamList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension ClosureParamList {
  init(@ClosureParamListBuilder itemsBuilder: () -> ClosureParamList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct CodeBlockItemListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = CodeBlockItem
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = CodeBlockItemList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension CodeBlockItemList {
  init(@CodeBlockItemListBuilder itemsBuilder: () -> CodeBlockItemList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct CompositionTypeElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = CompositionTypeElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = CompositionTypeElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension CompositionTypeElementList {
  init(@CompositionTypeElementListBuilder itemsBuilder: () -> CompositionTypeElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct ConditionElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = ConditionElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = ConditionElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension ConditionElementList {
  init(@ConditionElementListBuilder itemsBuilder: () -> ConditionElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct DeclNameArgumentListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = DeclNameArgument
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = DeclNameArgumentList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension DeclNameArgumentList {
  init(@DeclNameArgumentListBuilder itemsBuilder: () -> DeclNameArgumentList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct DesignatedTypeListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = DesignatedTypeElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = DesignatedTypeList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension DesignatedTypeList {
  init(@DesignatedTypeListBuilder itemsBuilder: () -> DesignatedTypeList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct DictionaryElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = DictionaryElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = DictionaryElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension DictionaryElementList {
  init(@DictionaryElementListBuilder itemsBuilder: () -> DictionaryElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct DifferentiabilityParamListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = DifferentiabilityParam
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = DifferentiabilityParamList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension DifferentiabilityParamList {
  init(@DifferentiabilityParamListBuilder itemsBuilder: () -> DifferentiabilityParamList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct EnumCaseElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = EnumCaseElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = EnumCaseElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension EnumCaseElementList {
  init(@EnumCaseElementListBuilder itemsBuilder: () -> EnumCaseElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct ExprListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = ExprSyntaxProtocol
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = ExprList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension ExprList {
  init(@ExprListBuilder itemsBuilder: () -> ExprList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct FunctionParameterListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = FunctionParameter
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = FunctionParameterList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension FunctionParameterList {
  init(@FunctionParameterListBuilder itemsBuilder: () -> FunctionParameterList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct GenericArgumentListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = GenericArgument
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = GenericArgumentList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension GenericArgumentList {
  init(@GenericArgumentListBuilder itemsBuilder: () -> GenericArgumentList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct GenericParameterListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = GenericParameter
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = GenericParameterList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension GenericParameterList {
  init(@GenericParameterListBuilder itemsBuilder: () -> GenericParameterList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct GenericRequirementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = GenericRequirement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = GenericRequirementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension GenericRequirementList {
  init(@GenericRequirementListBuilder itemsBuilder: () -> GenericRequirementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct IfConfigClauseListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = IfConfigClause
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = IfConfigClauseList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension IfConfigClauseList {
  init(@IfConfigClauseListBuilder itemsBuilder: () -> IfConfigClauseList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct InheritedTypeListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = InheritedType
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = InheritedTypeList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension InheritedTypeList {
  init(@InheritedTypeListBuilder itemsBuilder: () -> InheritedTypeList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct KeyPathComponentListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = KeyPathComponent
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = KeyPathComponentList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension KeyPathComponentList {
  init(@KeyPathComponentListBuilder itemsBuilder: () -> KeyPathComponentList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct MemberDeclListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = MemberDeclListItem
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = MemberDeclList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension MemberDeclList {
  init(@MemberDeclListBuilder itemsBuilder: () -> MemberDeclList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct ModifierListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = DeclModifier
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = ModifierList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension ModifierList {
  init(@ModifierListBuilder itemsBuilder: () -> ModifierList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct MultipleTrailingClosureElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = MultipleTrailingClosureElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = MultipleTrailingClosureElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension MultipleTrailingClosureElementList {
  init(@MultipleTrailingClosureElementListBuilder itemsBuilder: () -> MultipleTrailingClosureElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct NonEmptyTokenListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = Token
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = NonEmptyTokenList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension NonEmptyTokenList {
  init(@NonEmptyTokenListBuilder itemsBuilder: () -> NonEmptyTokenList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct ObjCSelectorBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = ObjCSelectorPiece
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = ObjCSelector
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension ObjCSelector {
  init(@ObjCSelectorBuilder itemsBuilder: () -> ObjCSelector) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct PatternBindingListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = PatternBinding
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = PatternBindingList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension PatternBindingList {
  init(@PatternBindingListBuilder itemsBuilder: () -> PatternBindingList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct PrecedenceGroupAttributeListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = PrecedenceGroupAttributeList.Element
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = PrecedenceGroupAttributeList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: PrecedenceGroupRelation) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: PrecedenceGroupAssignment) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: PrecedenceGroupAssociativity) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension PrecedenceGroupAttributeList {
  init(@PrecedenceGroupAttributeListBuilder itemsBuilder: () -> PrecedenceGroupAttributeList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct PrecedenceGroupNameListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = PrecedenceGroupNameElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = PrecedenceGroupNameList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension PrecedenceGroupNameList {
  init(@PrecedenceGroupNameListBuilder itemsBuilder: () -> PrecedenceGroupNameList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct PrimaryAssociatedTypeListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = PrimaryAssociatedType
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = PrimaryAssociatedTypeList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension PrimaryAssociatedTypeList {
  init(@PrimaryAssociatedTypeListBuilder itemsBuilder: () -> PrimaryAssociatedTypeList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct SpecializeAttributeSpecListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = SpecializeAttributeSpecList.Element
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = SpecializeAttributeSpecList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: LabeledSpecializeEntry) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: AvailabilityEntry) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: TargetFunctionEntry) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: GenericWhereClause) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension SpecializeAttributeSpecList {
  init(@SpecializeAttributeSpecListBuilder itemsBuilder: () -> SpecializeAttributeSpecList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct StringLiteralSegmentsBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = StringLiteralSegments.Element
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = StringLiteralSegments
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: StringSegment) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: ExpressionSegment) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension StringLiteralSegments {
  init(@StringLiteralSegmentsBuilder itemsBuilder: () -> StringLiteralSegments) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct SwitchCaseListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = SwitchCaseList.Element
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = SwitchCaseList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: SwitchCase) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: IfConfigDecl) -> Self.Component {
    return buildExpression(.init(expression))
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension SwitchCaseList {
  init(@SwitchCaseListBuilder itemsBuilder: () -> SwitchCaseList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct TokenListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = Token
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = TokenList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension TokenList {
  init(@TokenListBuilder itemsBuilder: () -> TokenList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct TupleExprElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = TupleExprElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = TupleExprElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension TupleExprElementList {
  init(@TupleExprElementListBuilder itemsBuilder: () -> TupleExprElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct TuplePatternElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = TuplePatternElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = TuplePatternElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension TuplePatternElementList {
  init(@TuplePatternElementListBuilder itemsBuilder: () -> TuplePatternElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct TupleTypeElementListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = TupleTypeElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = TupleTypeElementList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    let lastIndex = component.count - 1
    return .init(component.enumerated().map { index, source in 
        return index < lastIndex ? source.ensuringTrailingComma() : source
      })
  }
}

public extension TupleTypeElementList {
  init(@TupleTypeElementListBuilder itemsBuilder: () -> TupleTypeElementList) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct UnexpectedNodesBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = SyntaxProtocol
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = UnexpectedNodes
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension UnexpectedNodes {
  init(@UnexpectedNodesBuilder itemsBuilder: () -> UnexpectedNodes) {
    self = itemsBuilder()
  }
}

@resultBuilder
public struct YieldExprListBuilder {
  /// The type of individual statement expressions in the transformed function,
  /// which defaults to Component if buildExpression() is not provided.
  public typealias Expression = YieldExprListElement
  
  /// The type of a partial result, which will be carried through all of the
  /// build methods.
  public typealias Component = [Expression]
  
  /// The type of the final returned result, which defaults to Component if
  /// buildFinalResult() is not provided.
  public typealias FinalResult = YieldExprList
  
  /// Required by every result builder to build combined results from
  /// statement blocks.
  public static func buildBlock(_ components: Self.Component...) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, provides contextual type information for statement
  /// expressions to translate them into partial results.
  public static func buildExpression(_ expression: Self.Expression) -> Self.Component {
    return [expression]
  }
  
  /// Add all the elements of `expression` to this result builder, effectively flattening them.
  public static func buildExpression(_ expression: Self.FinalResult) -> Self.Component {
    return expression.map { 
      $0 
    }
  }
  
  /// Enables support for `if` statements that do not have an `else`.
  public static func buildOptional(_ component: Self.Component?) -> Self.Component {
    return component ?? []
  }
  
  /// With buildEither(second:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(first component: Self.Component) -> Self.Component {
    return component
  }
  
  /// With buildEither(first:), enables support for 'if-else' and 'switch'
  /// statements by folding conditional results into a single result.
  public static func buildEither(second component: Self.Component) -> Self.Component {
    return component
  }
  
  /// Enables support for 'for..in' loops by combining the
  /// results of all iterations into a single result.
  public static func buildArray(_ components: [Self.Component]) -> Self.Component {
    return components.flatMap { 
      $0 
    }
  }
  
  /// If declared, this will be called on the partial result of an 'if'
  /// #available' block to allow the result builder to erase type
  /// information.
  public static func buildLimitedAvailability(_ component: Self.Component) -> Self.Component {
    return component
  }
  
  /// If declared, this will be called on the partial result from the outermost
  /// block statement to produce the final returned result.
  public static func buildFinalResult(_ component: Component) -> FinalResult {
    return .init(component)
  }
}

public extension YieldExprList {
  init(@YieldExprListBuilder itemsBuilder: () -> YieldExprList) {
    self = itemsBuilder()
  }
}
