//// Automatically generated by generate-swiftsyntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - ArrayExprSyntax



/// ### Children
/// 
///  - `leftSquare`: `'['`
///  - `elements`: ``ArrayElementListSyntax``
///  - `rightSquare`: `']'`
public struct ArrayExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .arrayExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `ArrayExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .arrayExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareBracketToken(),
      _ unexpectedBetweenLeftSquareAndElements: UnexpectedNodesSyntax? = nil,
      elements: ArrayElementListSyntax,
      _ unexpectedBetweenElementsAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareBracketToken(),
      _ unexpectedAfterRightSquare: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndElements, 
            elements, 
            unexpectedBetweenElementsAndRightSquare, 
            rightSquare, 
            unexpectedAfterRightSquare
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndElements?.raw, 
          elements.raw, 
          unexpectedBetweenElementsAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedAfterRightSquare?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.arrayExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elements: ArrayElementListSyntax {
    get {
      return ArrayElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: ArrayElementSyntax) -> ArrayExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.arrayElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 3, with: collection, arena: arena)
    return ArrayExprSyntax(newData)
  }
  
  public var unexpectedBetweenElementsAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndElements, 
          \Self.elements, 
          \Self.unexpectedBetweenElementsAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedAfterRightSquare
        ])
  }
}

// MARK: - ArrowExprSyntax



/// ### Children
/// 
///  - `effectSpecifiers`: ``TypeEffectSpecifiersSyntax``?
///  - `arrowToken`: `'->'`
public struct ArrowExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .arrowExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `ArrowExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .arrowExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: TypeEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndArrowToken: UnexpectedNodesSyntax? = nil,
      arrowToken: TokenSyntax = .arrowToken(),
      _ unexpectedAfterArrowToken: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndArrowToken, 
            arrowToken, 
            unexpectedAfterArrowToken
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndArrowToken?.raw, 
          arrowToken.raw, 
          unexpectedAfterArrowToken?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.arrowExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: TypeEffectSpecifiersSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TypeEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndArrowToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arrowToken: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterArrowToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndArrowToken, 
          \Self.arrowToken, 
          \Self.unexpectedAfterArrowToken
        ])
  }
}

// MARK: - AsExprSyntax



/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `asTok`: `'as'`
///  - `questionOrExclamationMark`: (`'?'` | `'!'`)?
///  - `typeName`: ``TypeSyntax``
public struct AsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .asExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `AsExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .asExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol, T: TypeSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedBetweenExpressionAndAsTok: UnexpectedNodesSyntax? = nil,
      asTok: TokenSyntax = .keyword(.as),
      _ unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedBetweenQuestionOrExclamationMarkAndTypeName: UnexpectedNodesSyntax? = nil,
      typeName: T,
      _ unexpectedAfterTypeName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndAsTok, 
            asTok, 
            unexpectedBetweenAsTokAndQuestionOrExclamationMark, 
            questionOrExclamationMark, 
            unexpectedBetweenQuestionOrExclamationMarkAndTypeName, 
            typeName, 
            unexpectedAfterTypeName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndAsTok?.raw, 
          asTok.raw, 
          unexpectedBetweenAsTokAndQuestionOrExclamationMark?.raw, 
          questionOrExclamationMark?.raw, 
          unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.raw, 
          typeName.raw, 
          unexpectedAfterTypeName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.asExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndAsTok: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var asTok: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionOrExclamationMarkAndTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var typeName: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndAsTok, 
          \Self.asTok, 
          \Self.unexpectedBetweenAsTokAndQuestionOrExclamationMark, 
          \Self.questionOrExclamationMark, 
          \Self.unexpectedBetweenQuestionOrExclamationMarkAndTypeName, 
          \Self.typeName, 
          \Self.unexpectedAfterTypeName
        ])
  }
}

// MARK: - AssignmentExprSyntax



/// ### Children
/// 
///  - `assignToken`: `'='`
public struct AssignmentExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .assignmentExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `AssignmentExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .assignmentExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAssignToken: UnexpectedNodesSyntax? = nil,
      assignToken: TokenSyntax = .equalToken(),
      _ unexpectedAfterAssignToken: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeAssignToken, assignToken, unexpectedAfterAssignToken))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeAssignToken?.raw, assignToken.raw, unexpectedAfterAssignToken?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.assignmentExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAssignToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssignmentExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var assignToken: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = AssignmentExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterAssignToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssignmentExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeAssignToken, \Self.assignToken, \Self.unexpectedAfterAssignToken])
  }
}

// MARK: - AwaitExprSyntax



/// ### Children
/// 
///  - `awaitKeyword`: `'await'`
///  - `expression`: ``ExprSyntax``
public struct AwaitExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .awaitExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `AwaitExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .awaitExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAwaitKeyword: UnexpectedNodesSyntax? = nil,
      awaitKeyword: TokenSyntax = .keyword(.await),
      _ unexpectedBetweenAwaitKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAwaitKeyword, 
            awaitKeyword, 
            unexpectedBetweenAwaitKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAwaitKeyword?.raw, 
          awaitKeyword.raw, 
          unexpectedBetweenAwaitKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.awaitExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAwaitKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var awaitKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAwaitKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAwaitKeyword, 
          \Self.awaitKeyword, 
          \Self.unexpectedBetweenAwaitKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - BinaryOperatorExprSyntax



/// ### Children
/// 
///  - `operatorToken`: `<binaryOperator>`
public struct BinaryOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .binaryOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `BinaryOperatorExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .binaryOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOperatorToken: UnexpectedNodesSyntax? = nil,
      operatorToken: TokenSyntax,
      _ unexpectedAfterOperatorToken: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeOperatorToken, operatorToken, unexpectedAfterOperatorToken))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeOperatorToken?.raw, operatorToken.raw, unexpectedAfterOperatorToken?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.binaryOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOperatorToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BinaryOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var operatorToken: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = BinaryOperatorExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOperatorToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BinaryOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeOperatorToken, \Self.operatorToken, \Self.unexpectedAfterOperatorToken])
  }
}

// MARK: - BooleanLiteralExprSyntax



/// ### Children
/// 
///  - `booleanLiteral`: (`'true'` | `'false'`)
public struct BooleanLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .booleanLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `BooleanLiteralExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .booleanLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBooleanLiteral: UnexpectedNodesSyntax? = nil,
      booleanLiteral: TokenSyntax,
      _ unexpectedAfterBooleanLiteral: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeBooleanLiteral, booleanLiteral, unexpectedAfterBooleanLiteral))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeBooleanLiteral?.raw, booleanLiteral.raw, unexpectedAfterBooleanLiteral?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.booleanLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBooleanLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BooleanLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var booleanLiteral: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = BooleanLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBooleanLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BooleanLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeBooleanLiteral, \Self.booleanLiteral, \Self.unexpectedAfterBooleanLiteral])
  }
}

// MARK: - BorrowExprSyntax



/// ### Children
/// 
///  - `borrowKeyword`: `'_borrow'`
///  - `expression`: ``ExprSyntax``
public struct BorrowExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .borrowExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `BorrowExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .borrowExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBorrowKeyword: UnexpectedNodesSyntax? = nil,
      borrowKeyword: TokenSyntax = .keyword(._borrow),
      _ unexpectedBetweenBorrowKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBorrowKeyword, 
            borrowKeyword, 
            unexpectedBetweenBorrowKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBorrowKeyword?.raw, 
          borrowKeyword.raw, 
          unexpectedBetweenBorrowKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.borrowExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBorrowKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var borrowKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBorrowKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBorrowKeyword, 
          \Self.borrowKeyword, 
          \Self.unexpectedBetweenBorrowKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - ClosureExprSyntax



/// ### Children
/// 
///  - `leftBrace`: `'{'`
///  - `signature`: ``ClosureSignatureSyntax``?
///  - `statements`: ``CodeBlockItemListSyntax``
///  - `rightBrace`: `'}'`
public struct ClosureExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .closureExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `ClosureExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndSignature: UnexpectedNodesSyntax? = nil,
      signature: ClosureSignatureSyntax? = nil,
      _ unexpectedBetweenSignatureAndStatements: UnexpectedNodesSyntax? = nil,
      statements: CodeBlockItemListSyntax,
      _ unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndStatements, 
            statements, 
            unexpectedBetweenStatementsAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndSignature?.raw, 
          signature?.raw, 
          unexpectedBetweenSignatureAndStatements?.raw, 
          statements.raw, 
          unexpectedBetweenStatementsAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var signature: ClosureSignatureSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(ClosureSignatureSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndStatements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var statements: CodeBlockItemListSyntax {
    get {
      return CodeBlockItemListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Statement` to the node's `statements`
  /// collection.
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  public func addStatement(_ element: CodeBlockItemSyntax) -> ClosureExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.codeBlockItemList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 5, with: collection, arena: arena)
    return ClosureExprSyntax(newData)
  }
  
  public var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndStatements, 
          \Self.statements, 
          \Self.unexpectedBetweenStatementsAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - CopyExprSyntax



/// ### Children
/// 
///  - `copyKeyword`: `'copy'`
///  - `expression`: ``ExprSyntax``
public struct CopyExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .copyExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `CopyExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .copyExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCopyKeyword: UnexpectedNodesSyntax? = nil,
      copyKeyword: TokenSyntax = .keyword(.copy),
      _ unexpectedBetweenCopyKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCopyKeyword, 
            copyKeyword, 
            unexpectedBetweenCopyKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCopyKeyword?.raw, 
          copyKeyword.raw, 
          unexpectedBetweenCopyKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.copyExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCopyKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var copyKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCopyKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCopyKeyword, 
          \Self.copyKeyword, 
          \Self.unexpectedBetweenCopyKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - DictionaryExprSyntax



/// ### Children
/// 
///  - `leftSquare`: `'['`
///  - `content`: (`':'` | ``DictionaryElementListSyntax``)
///  - `rightSquare`: `']'`
public struct DictionaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public enum Content: SyntaxChildChoices {
    case `colon`(TokenSyntax)
    case `elements`(DictionaryElementListSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .colon(let node):
        return node._syntaxNode
      case .elements(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: TokenSyntax) {
      self = .colon(node)
    }
    
    public init(_ node: DictionaryElementListSyntax) {
      self = .elements(node)
    }
    
    public init?<S: SyntaxProtocol>(_ node: S) {
      if let node = node.as(TokenSyntax.self) {
        self = .colon(node)
        return
      }
      if let node = node.as(DictionaryElementListSyntax.self) {
        self = .elements(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(TokenSyntax.self), .node(DictionaryElementListSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .dictionaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `DictionaryExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .dictionaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareBracketToken(),
      _ unexpectedBetweenLeftSquareAndContent: UnexpectedNodesSyntax? = nil,
      content: Content,
      _ unexpectedBetweenContentAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareBracketToken(),
      _ unexpectedAfterRightSquare: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndContent, 
            content, 
            unexpectedBetweenContentAndRightSquare, 
            rightSquare, 
            unexpectedAfterRightSquare
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndContent?.raw, 
          content.raw, 
          unexpectedBetweenContentAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedAfterRightSquare?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.dictionaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndContent: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var content: Content {
    get {
      return Content(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenContentAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndContent, 
          \Self.content, 
          \Self.unexpectedBetweenContentAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedAfterRightSquare
        ])
  }
}

// MARK: - DiscardAssignmentExprSyntax



/// ### Children
/// 
///  - `wildcard`: `'_'`
public struct DiscardAssignmentExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .discardAssignmentExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `DiscardAssignmentExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .discardAssignmentExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWildcard: UnexpectedNodesSyntax? = nil,
      wildcard: TokenSyntax = .wildcardToken(),
      _ unexpectedAfterWildcard: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeWildcard, wildcard, unexpectedAfterWildcard))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeWildcard?.raw, wildcard.raw, unexpectedAfterWildcard?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.discardAssignmentExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWildcard: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var wildcard: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterWildcard: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeWildcard, \Self.wildcard, \Self.unexpectedAfterWildcard])
  }
}

// MARK: - EditorPlaceholderExprSyntax



/// ### Children
/// 
///  - `identifier`: `<identifier>`
public struct EditorPlaceholderExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .editorPlaceholderExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `EditorPlaceholderExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .editorPlaceholderExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIdentifier: UnexpectedNodesSyntax? = nil,
      identifier: TokenSyntax,
      _ unexpectedAfterIdentifier: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeIdentifier, identifier, unexpectedAfterIdentifier))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeIdentifier?.raw, identifier.raw, unexpectedAfterIdentifier?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.editorPlaceholderExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var identifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeIdentifier, \Self.identifier, \Self.unexpectedAfterIdentifier])
  }
}

// MARK: - FloatLiteralExprSyntax



/// ### Children
/// 
///  - `floatingDigits`: `<floatingLiteral>`
public struct FloatLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .floatLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `FloatLiteralExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .floatLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeFloatingDigits: UnexpectedNodesSyntax? = nil,
      floatingDigits: TokenSyntax,
      _ unexpectedAfterFloatingDigits: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeFloatingDigits, floatingDigits, unexpectedAfterFloatingDigits))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeFloatingDigits?.raw, floatingDigits.raw, unexpectedAfterFloatingDigits?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.floatLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeFloatingDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var floatingDigits: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterFloatingDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeFloatingDigits, \Self.floatingDigits, \Self.unexpectedAfterFloatingDigits])
  }
}

// MARK: - ForcedValueExprSyntax



/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `exclamationMark`: `'!'`
public struct ForcedValueExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .forcedValueExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `ForcedValueExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .forcedValueExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodesSyntax? = nil,
      exclamationMark: TokenSyntax = .exclamationMarkToken(),
      _ unexpectedAfterExclamationMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndExclamationMark, 
            exclamationMark, 
            unexpectedAfterExclamationMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndExclamationMark?.raw, 
          exclamationMark.raw, 
          unexpectedAfterExclamationMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.forcedValueExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var exclamationMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndExclamationMark, 
          \Self.exclamationMark, 
          \Self.unexpectedAfterExclamationMark
        ])
  }
}

// MARK: - FunctionCallExprSyntax



/// ### Children
/// 
///  - `calledExpression`: ``ExprSyntax``
///  - `leftParen`: `'('`?
///  - `argumentList`: ``TupleExprElementListSyntax``
///  - `rightParen`: `')'`?
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct FunctionCallExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .functionCallExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `FunctionCallExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionCallExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<C: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? = nil,
      calledExpression: C,
      _ unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? = nil,
      argumentList: TupleExprElementListSyntax,
      _ unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? = nil,
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCalledExpression, 
            calledExpression, 
            unexpectedBetweenCalledExpressionAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArgumentList, 
            argumentList, 
            unexpectedBetweenArgumentListAndRightParen, 
            rightParen, 
            unexpectedBetweenRightParenAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCalledExpression?.raw, 
          calledExpression.raw, 
          unexpectedBetweenCalledExpressionAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndArgumentList?.raw, 
          argumentList.raw, 
          unexpectedBetweenArgumentListAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedBetweenRightParenAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures?.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionCallExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var calledExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argumentList: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Argument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 5, with: collection, arena: arena)
    return FunctionCallExprSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(MultipleTrailingClosureElementListSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `AdditionalTrailingClosure` to the node's `additionalTrailingClosures`
  /// collection.
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[11] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 11, with: collection, arena: arena)
    return FunctionCallExprSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCalledExpression, 
          \Self.calledExpression, 
          \Self.unexpectedBetweenCalledExpressionAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArgumentList, 
          \Self.argumentList, 
          \Self.unexpectedBetweenArgumentListAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedBetweenRightParenAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - IdentifierExprSyntax



/// ### Children
/// 
///  - `identifier`: (`<identifier>` | `<keyword>` | `<dollarIdentifier>` | `<binaryOperator>`)
///  - `declNameArguments`: ``DeclNameArgumentsSyntax``?
public struct IdentifierExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .identifierExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `IdentifierExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .identifierExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIdentifier: UnexpectedNodesSyntax? = nil,
      identifier: TokenSyntax,
      _ unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodesSyntax? = nil,
      declNameArguments: DeclNameArgumentsSyntax? = nil,
      _ unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeIdentifier, 
            identifier, 
            unexpectedBetweenIdentifierAndDeclNameArguments, 
            declNameArguments, 
            unexpectedAfterDeclNameArguments
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeIdentifier?.raw, 
          identifier.raw, 
          unexpectedBetweenIdentifierAndDeclNameArguments?.raw, 
          declNameArguments?.raw, 
          unexpectedAfterDeclNameArguments?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.identifierExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var identifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclNameArgumentsSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeIdentifier, 
          \Self.identifier, 
          \Self.unexpectedBetweenIdentifierAndDeclNameArguments, 
          \Self.declNameArguments, 
          \Self.unexpectedAfterDeclNameArguments
        ])
  }
}

// MARK: - IfExprSyntax



/// ### Children
/// 
///  - `ifKeyword`: `'if'`
///  - `conditions`: ``ConditionElementListSyntax``
///  - `body`: ``CodeBlockSyntax``
///  - `elseKeyword`: ``ElseTokenSyntax``?
///  - `elseBody`: (``IfExprSyntax`` | ``CodeBlockSyntax``)?
public struct IfExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public enum ElseBody: SyntaxChildChoices {
    case `ifExpr`(IfExprSyntax)
    case `codeBlock`(CodeBlockSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .ifExpr(let node):
        return node._syntaxNode
      case .codeBlock(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: IfExprSyntax) {
      self = .ifExpr(node)
    }
    
    public init(_ node: CodeBlockSyntax) {
      self = .codeBlock(node)
    }
    
    public init?<S: SyntaxProtocol>(_ node: S) {
      if let node = node.as(IfExprSyntax.self) {
        self = .ifExpr(node)
        return
      }
      if let node = node.as(CodeBlockSyntax.self) {
        self = .codeBlock(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(IfExprSyntax.self), .node(CodeBlockSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .ifExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `IfExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ifExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIfKeyword: UnexpectedNodesSyntax? = nil,
      ifKeyword: TokenSyntax = .keyword(.if),
      _ unexpectedBetweenIfKeywordAndConditions: UnexpectedNodesSyntax? = nil,
      conditions: ConditionElementListSyntax,
      _ unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedBetweenBodyAndElseKeyword: UnexpectedNodesSyntax? = nil,
      elseKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodesSyntax? = nil,
      elseBody: ElseBody? = nil,
      _ unexpectedAfterElseBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeIfKeyword, 
            ifKeyword, 
            unexpectedBetweenIfKeywordAndConditions, 
            conditions, 
            unexpectedBetweenConditionsAndBody, 
            body, 
            unexpectedBetweenBodyAndElseKeyword, 
            elseKeyword, 
            unexpectedBetweenElseKeywordAndElseBody, 
            elseBody, 
            unexpectedAfterElseBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeIfKeyword?.raw, 
          ifKeyword.raw, 
          unexpectedBetweenIfKeywordAndConditions?.raw, 
          conditions.raw, 
          unexpectedBetweenConditionsAndBody?.raw, 
          body.raw, 
          unexpectedBetweenBodyAndElseKeyword?.raw, 
          elseKeyword?.raw, 
          unexpectedBetweenElseKeywordAndElseBody?.raw, 
          elseBody?.raw, 
          unexpectedAfterElseBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ifExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIfKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ifKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIfKeywordAndConditions: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var conditions: ConditionElementListSyntax {
    get {
      return ConditionElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Condition` to the node's `conditions`
  /// collection.
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  public func addCondition(_ element: ConditionElementSyntax) -> IfExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.conditionElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 3, with: collection, arena: arena)
    return IfExprSyntax(newData)
  }
  
  public var unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBodyAndElseKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elseKeyword: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elseBody: ElseBody? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ElseBody.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterElseBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeIfKeyword, 
          \Self.ifKeyword, 
          \Self.unexpectedBetweenIfKeywordAndConditions, 
          \Self.conditions, 
          \Self.unexpectedBetweenConditionsAndBody, 
          \Self.body, 
          \Self.unexpectedBetweenBodyAndElseKeyword, 
          \Self.elseKeyword, 
          \Self.unexpectedBetweenElseKeywordAndElseBody, 
          \Self.elseBody, 
          \Self.unexpectedAfterElseBody
        ])
  }
}

// MARK: - InOutExprSyntax



/// ### Children
/// 
///  - `ampersand`: `'&'`
///  - `expression`: ``ExprSyntax``
public struct InOutExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .inOutExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `InOutExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .inOutExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAmpersand: UnexpectedNodesSyntax? = nil,
      ampersand: TokenSyntax = .prefixAmpersandToken(),
      _ unexpectedBetweenAmpersandAndExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAmpersand, 
            ampersand, 
            unexpectedBetweenAmpersandAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAmpersand?.raw, 
          ampersand.raw, 
          unexpectedBetweenAmpersandAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.inOutExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAmpersand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ampersand: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAmpersandAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAmpersand, 
          \Self.ampersand, 
          \Self.unexpectedBetweenAmpersandAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - InfixOperatorExprSyntax



/// ### Children
/// 
///  - `leftOperand`: ``ExprSyntax``
///  - `operatorOperand`: ``ExprSyntax``
///  - `rightOperand`: ``ExprSyntax``
public struct InfixOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .infixOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `InfixOperatorExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .infixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<L: ExprSyntaxProtocol, O: ExprSyntaxProtocol, R: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftOperand: UnexpectedNodesSyntax? = nil,
      leftOperand: L,
      _ unexpectedBetweenLeftOperandAndOperatorOperand: UnexpectedNodesSyntax? = nil,
      operatorOperand: O,
      _ unexpectedBetweenOperatorOperandAndRightOperand: UnexpectedNodesSyntax? = nil,
      rightOperand: R,
      _ unexpectedAfterRightOperand: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftOperand, 
            leftOperand, 
            unexpectedBetweenLeftOperandAndOperatorOperand, 
            operatorOperand, 
            unexpectedBetweenOperatorOperandAndRightOperand, 
            rightOperand, 
            unexpectedAfterRightOperand
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftOperand?.raw, 
          leftOperand.raw, 
          unexpectedBetweenLeftOperandAndOperatorOperand?.raw, 
          operatorOperand.raw, 
          unexpectedBetweenOperatorOperandAndRightOperand?.raw, 
          rightOperand.raw, 
          unexpectedAfterRightOperand?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.infixOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftOperandAndOperatorOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var operatorOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorOperandAndRightOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftOperand, 
          \Self.leftOperand, 
          \Self.unexpectedBetweenLeftOperandAndOperatorOperand, 
          \Self.operatorOperand, 
          \Self.unexpectedBetweenOperatorOperandAndRightOperand, 
          \Self.rightOperand, 
          \Self.unexpectedAfterRightOperand
        ])
  }
}

// MARK: - IntegerLiteralExprSyntax



/// ### Children
/// 
///  - `digits`: `<integerLiteral>`
public struct IntegerLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .integerLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `IntegerLiteralExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .integerLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeDigits: UnexpectedNodesSyntax? = nil,
      digits: TokenSyntax,
      _ unexpectedAfterDigits: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeDigits, digits, unexpectedAfterDigits))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeDigits?.raw, digits.raw, unexpectedAfterDigits?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.integerLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var digits: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeDigits, \Self.digits, \Self.unexpectedAfterDigits])
  }
}

// MARK: - IsExprSyntax



/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `isTok`: `'is'`
///  - `typeName`: ``TypeSyntax``
public struct IsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .isExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `IsExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .isExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol, T: TypeSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedBetweenExpressionAndIsTok: UnexpectedNodesSyntax? = nil,
      isTok: TokenSyntax = .keyword(.is),
      _ unexpectedBetweenIsTokAndTypeName: UnexpectedNodesSyntax? = nil,
      typeName: T,
      _ unexpectedAfterTypeName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndIsTok, 
            isTok, 
            unexpectedBetweenIsTokAndTypeName, 
            typeName, 
            unexpectedAfterTypeName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndIsTok?.raw, 
          isTok.raw, 
          unexpectedBetweenIsTokAndTypeName?.raw, 
          typeName.raw, 
          unexpectedAfterTypeName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.isExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndIsTok: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var isTok: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIsTokAndTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var typeName: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndIsTok, 
          \Self.isTok, 
          \Self.unexpectedBetweenIsTokAndTypeName, 
          \Self.typeName, 
          \Self.unexpectedAfterTypeName
        ])
  }
}

// MARK: - KeyPathExprSyntax



/// ### Children
/// 
///  - `backslash`: `'\'`
///  - `root`: ``TypeSyntax``?
///  - `components`: ``KeyPathComponentListSyntax``
public struct KeyPathExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .keyPathExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `KeyPathExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .keyPathExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<R: TypeSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBackslash: UnexpectedNodesSyntax? = nil,
      backslash: TokenSyntax = .backslashToken(),
      _ unexpectedBetweenBackslashAndRoot: UnexpectedNodesSyntax? = nil,
      root: R? = nil,
      _ unexpectedBetweenRootAndComponents: UnexpectedNodesSyntax? = nil,
      components: KeyPathComponentListSyntax,
      _ unexpectedAfterComponents: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBackslash, 
            backslash, 
            unexpectedBetweenBackslashAndRoot, 
            root, 
            unexpectedBetweenRootAndComponents, 
            components, 
            unexpectedAfterComponents
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBackslash?.raw, 
          backslash.raw, 
          unexpectedBetweenBackslashAndRoot?.raw, 
          root?.raw, 
          unexpectedBetweenRootAndComponents?.raw, 
          components.raw, 
          unexpectedAfterComponents?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.keyPathExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// This initializer exists solely because Swift 5.6 does not support
  /// `Optional<ConcreteType>.none` as a default value of a generic parameter.
  /// The above initializer thus defaults to `nil` instead, but that means it
  /// is not actually callable when either not passing the defaulted parameter,
  /// or passing `nil`.
  ///
  /// Hack around that limitation using this initializer, which takes a
  /// `Missing*` syntax node instead. `Missing*` is used over the base type as
  /// the base type would allow implicit conversion from a string literal,
  /// which the above initializer doesn't support.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBackslash: UnexpectedNodesSyntax? = nil,
      backslash: TokenSyntax = .backslashToken(),
      _ unexpectedBetweenBackslashAndRoot: UnexpectedNodesSyntax? = nil,
      root: MissingTypeSyntax? = nil,
      _ unexpectedBetweenRootAndComponents: UnexpectedNodesSyntax? = nil,
      components: KeyPathComponentListSyntax,
      _ unexpectedAfterComponents: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    self.init(
        leadingTrivia: leadingTrivia,
        unexpectedBeforeBackslash,
        backslash: backslash,
        unexpectedBetweenBackslashAndRoot,
        root: Optional<TypeSyntax> .none,
        unexpectedBetweenRootAndComponents,
        components: components,
        unexpectedAfterComponents, 
        trailingTrivia: trailingTrivia
      )
  }
  
  public var unexpectedBeforeBackslash: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var backslash: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBackslashAndRoot: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var root: TypeSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TypeSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRootAndComponents: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var components: KeyPathComponentListSyntax {
    get {
      return KeyPathComponentListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `KeyPathComponent` to the node's `components`
  /// collection.
  /// - param element: The new `KeyPathComponent` to add to the node's
  ///                  `components` collection.
  /// - returns: A copy of the receiver with the provided `KeyPathComponent`
  ///            appended to its `components` collection.
  public func addKeyPathComponent(_ element: KeyPathComponentSyntax) -> KeyPathExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.keyPathComponentList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 5, with: collection, arena: arena)
    return KeyPathExprSyntax(newData)
  }
  
  public var unexpectedAfterComponents: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBackslash, 
          \Self.backslash, 
          \Self.unexpectedBetweenBackslashAndRoot, 
          \Self.root, 
          \Self.unexpectedBetweenRootAndComponents, 
          \Self.components, 
          \Self.unexpectedAfterComponents
        ])
  }
}

// MARK: - MacroExpansionExprSyntax



/// ### Children
/// 
///  - `poundToken`: `'#'`
///  - `macro`: `<identifier>`
///  - `genericArguments`: ``GenericArgumentClauseSyntax``?
///  - `leftParen`: `'('`?
///  - `argumentList`: ``TupleExprElementListSyntax``
///  - `rightParen`: `')'`?
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct MacroExpansionExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .macroExpansionExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `MacroExpansionExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .macroExpansionExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePoundToken: UnexpectedNodesSyntax? = nil,
      poundToken: TokenSyntax = .poundToken(),
      _ unexpectedBetweenPoundTokenAndMacro: UnexpectedNodesSyntax? = nil,
      macro: TokenSyntax,
      _ unexpectedBetweenMacroAndGenericArguments: UnexpectedNodesSyntax? = nil,
      genericArguments: GenericArgumentClauseSyntax? = nil,
      _ unexpectedBetweenGenericArgumentsAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? = nil,
      argumentList: TupleExprElementListSyntax,
      _ unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? = nil,
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePoundToken, 
            poundToken, 
            unexpectedBetweenPoundTokenAndMacro, 
            macro, 
            unexpectedBetweenMacroAndGenericArguments, 
            genericArguments, 
            unexpectedBetweenGenericArgumentsAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArgumentList, 
            argumentList, 
            unexpectedBetweenArgumentListAndRightParen, 
            rightParen, 
            unexpectedBetweenRightParenAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePoundToken?.raw, 
          poundToken.raw, 
          unexpectedBetweenPoundTokenAndMacro?.raw, 
          macro.raw, 
          unexpectedBetweenMacroAndGenericArguments?.raw, 
          genericArguments?.raw, 
          unexpectedBetweenGenericArgumentsAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndArgumentList?.raw, 
          argumentList.raw, 
          unexpectedBetweenArgumentListAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedBetweenRightParenAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures?.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.macroExpansionExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePoundToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `#` sign.
  public var poundToken: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPoundTokenAndMacro: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var macro: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenMacroAndGenericArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var genericArguments: GenericArgumentClauseSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(GenericArgumentClauseSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericArgumentsAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argumentList: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Argument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> MacroExpansionExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[9] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 9, with: collection, arena: arena)
    return MacroExpansionExprSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(MultipleTrailingClosureElementListSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `AdditionalTrailingClosure` to the node's `additionalTrailingClosures`
  /// collection.
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> MacroExpansionExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[15] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 15, with: collection, arena: arena)
    return MacroExpansionExprSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePoundToken, 
          \Self.poundToken, 
          \Self.unexpectedBetweenPoundTokenAndMacro, 
          \Self.macro, 
          \Self.unexpectedBetweenMacroAndGenericArguments, 
          \Self.genericArguments, 
          \Self.unexpectedBetweenGenericArgumentsAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArgumentList, 
          \Self.argumentList, 
          \Self.unexpectedBetweenArgumentListAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedBetweenRightParenAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - MemberAccessExprSyntax



/// ### Children
/// 
///  - `base`: ``ExprSyntax``?
///  - `dot`: `'.'`
///  - `name`: ``TokenSyntax``
///  - `declNameArguments`: ``DeclNameArgumentsSyntax``?
public struct MemberAccessExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .memberAccessExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `MemberAccessExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .memberAccessExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<B: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBase: UnexpectedNodesSyntax? = nil,
      base: B? = nil,
      _ unexpectedBetweenBaseAndDot: UnexpectedNodesSyntax? = nil,
      dot: TokenSyntax = .periodToken(),
      _ unexpectedBetweenDotAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodesSyntax? = nil,
      declNameArguments: DeclNameArgumentsSyntax? = nil,
      _ unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBase, 
            base, 
            unexpectedBetweenBaseAndDot, 
            dot, 
            unexpectedBetweenDotAndName, 
            name, 
            unexpectedBetweenNameAndDeclNameArguments, 
            declNameArguments, 
            unexpectedAfterDeclNameArguments
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBase?.raw, 
          base?.raw, 
          unexpectedBetweenBaseAndDot?.raw, 
          dot.raw, 
          unexpectedBetweenDotAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndDeclNameArguments?.raw, 
          declNameArguments?.raw, 
          unexpectedAfterDeclNameArguments?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.memberAccessExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// This initializer exists solely because Swift 5.6 does not support
  /// `Optional<ConcreteType>.none` as a default value of a generic parameter.
  /// The above initializer thus defaults to `nil` instead, but that means it
  /// is not actually callable when either not passing the defaulted parameter,
  /// or passing `nil`.
  ///
  /// Hack around that limitation using this initializer, which takes a
  /// `Missing*` syntax node instead. `Missing*` is used over the base type as
  /// the base type would allow implicit conversion from a string literal,
  /// which the above initializer doesn't support.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBase: UnexpectedNodesSyntax? = nil,
      base: MissingExprSyntax? = nil,
      _ unexpectedBetweenBaseAndDot: UnexpectedNodesSyntax? = nil,
      dot: TokenSyntax = .periodToken(),
      _ unexpectedBetweenDotAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodesSyntax? = nil,
      declNameArguments: DeclNameArgumentsSyntax? = nil,
      _ unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    self.init(
        leadingTrivia: leadingTrivia,
        unexpectedBeforeBase,
        base: Optional<ExprSyntax> .none,
        unexpectedBetweenBaseAndDot,
        dot: dot,
        unexpectedBetweenDotAndName,
        name: name,
        unexpectedBetweenNameAndDeclNameArguments,
        declNameArguments: declNameArguments,
        unexpectedAfterDeclNameArguments, 
        trailingTrivia: trailingTrivia
      )
  }
  
  public var unexpectedBeforeBase: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var base: ExprSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(ExprSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBaseAndDot: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var dot: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDotAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(DeclNameArgumentsSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBase, 
          \Self.base, 
          \Self.unexpectedBetweenBaseAndDot, 
          \Self.dot, 
          \Self.unexpectedBetweenDotAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndDeclNameArguments, 
          \Self.declNameArguments, 
          \Self.unexpectedAfterDeclNameArguments
        ])
  }
}

// MARK: - MissingExprSyntax

/// In case the source code is missing a expression, this node stands in place of the missing expression.
///
/// ### Children
/// 
///  - `placeholder`: `<identifier>`
public struct MissingExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .missingExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `MissingExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .missingExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePlaceholder: UnexpectedNodesSyntax? = nil,
      placeholder: TokenSyntax,
      _ unexpectedAfterPlaceholder: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforePlaceholder, placeholder, unexpectedAfterPlaceholder))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforePlaceholder?.raw, placeholder.raw, unexpectedAfterPlaceholder?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.missingExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A placeholder, i.e. `<#expression#>` that can be inserted into the source code to represent the missing expression./// This token should always have `presence = .missing`.
  public var placeholder: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = MissingExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforePlaceholder, \Self.placeholder, \Self.unexpectedAfterPlaceholder])
  }
}

// MARK: - MoveExprSyntax



/// ### Children
/// 
///  - `moveKeyword`: (`'_move'` | `'consume'`)
///  - `expression`: ``ExprSyntax``
public struct MoveExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .moveExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `MoveExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .moveExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeMoveKeyword: UnexpectedNodesSyntax? = nil,
      moveKeyword: TokenSyntax,
      _ unexpectedBetweenMoveKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeMoveKeyword, 
            moveKeyword, 
            unexpectedBetweenMoveKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeMoveKeyword?.raw, 
          moveKeyword.raw, 
          unexpectedBetweenMoveKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.moveExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeMoveKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var moveKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenMoveKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeMoveKeyword, 
          \Self.moveKeyword, 
          \Self.unexpectedBetweenMoveKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - NilLiteralExprSyntax



/// ### Children
/// 
///  - `nilKeyword`: `'nil'`
public struct NilLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .nilLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `NilLiteralExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .nilLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeNilKeyword: UnexpectedNodesSyntax? = nil,
      nilKeyword: TokenSyntax = .keyword(.nil),
      _ unexpectedAfterNilKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeNilKeyword, nilKeyword, unexpectedAfterNilKeyword))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeNilKeyword?.raw, nilKeyword.raw, unexpectedAfterNilKeyword?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.nilLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeNilKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = NilLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var nilKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = NilLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterNilKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = NilLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeNilKeyword, \Self.nilKeyword, \Self.unexpectedAfterNilKeyword])
  }
}

// MARK: - OptionalChainingExprSyntax



/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `questionMark`: `'?'`
public struct OptionalChainingExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .optionalChainingExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `OptionalChainingExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .optionalChainingExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .postfixQuestionMarkToken(),
      _ unexpectedAfterQuestionMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndQuestionMark, 
            questionMark, 
            unexpectedAfterQuestionMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedAfterQuestionMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.optionalChainingExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedAfterQuestionMark
        ])
  }
}

// MARK: - PackElementExprSyntax



/// ### Children
/// 
///  - `eachKeyword`: `'each'`
///  - `packRefExpr`: ``ExprSyntax``
public struct PackElementExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .packElementExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `PackElementExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packElementExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<P: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? = nil,
      eachKeyword: TokenSyntax = .keyword(.each),
      _ unexpectedBetweenEachKeywordAndPackRefExpr: UnexpectedNodesSyntax? = nil,
      packRefExpr: P,
      _ unexpectedAfterPackRefExpr: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeEachKeyword, 
            eachKeyword, 
            unexpectedBetweenEachKeywordAndPackRefExpr, 
            packRefExpr, 
            unexpectedAfterPackRefExpr
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeEachKeyword?.raw, 
          eachKeyword.raw, 
          unexpectedBetweenEachKeywordAndPackRefExpr?.raw, 
          packRefExpr.raw, 
          unexpectedAfterPackRefExpr?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packElementExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var eachKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEachKeywordAndPackRefExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var packRefExpr: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPackRefExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeEachKeyword, 
          \Self.eachKeyword, 
          \Self.unexpectedBetweenEachKeywordAndPackRefExpr, 
          \Self.packRefExpr, 
          \Self.unexpectedAfterPackRefExpr
        ])
  }
}

// MARK: - PackExpansionExprSyntax



/// ### Children
/// 
///  - `repeatKeyword`: `'repeat'`
///  - `patternExpr`: ``ExprSyntax``
public struct PackExpansionExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .packExpansionExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `PackExpansionExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packExpansionExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<P: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? = nil,
      repeatKeyword: TokenSyntax = .keyword(.repeat),
      _ unexpectedBetweenRepeatKeywordAndPatternExpr: UnexpectedNodesSyntax? = nil,
      patternExpr: P,
      _ unexpectedAfterPatternExpr: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeRepeatKeyword, 
            repeatKeyword, 
            unexpectedBetweenRepeatKeywordAndPatternExpr, 
            patternExpr, 
            unexpectedAfterPatternExpr
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeRepeatKeyword?.raw, 
          repeatKeyword.raw, 
          unexpectedBetweenRepeatKeywordAndPatternExpr?.raw, 
          patternExpr.raw, 
          unexpectedAfterPatternExpr?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packExpansionExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var repeatKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRepeatKeywordAndPatternExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var patternExpr: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPatternExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeRepeatKeyword, 
          \Self.repeatKeyword, 
          \Self.unexpectedBetweenRepeatKeywordAndPatternExpr, 
          \Self.patternExpr, 
          \Self.unexpectedAfterPatternExpr
        ])
  }
}

// MARK: - PostfixIfConfigExprSyntax



/// ### Children
/// 
///  - `base`: ``ExprSyntax``?
///  - `config`: ``IfConfigDeclSyntax``
public struct PostfixIfConfigExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .postfixIfConfigExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `PostfixIfConfigExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .postfixIfConfigExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<B: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBase: UnexpectedNodesSyntax? = nil,
      base: B? = nil,
      _ unexpectedBetweenBaseAndConfig: UnexpectedNodesSyntax? = nil,
      config: IfConfigDeclSyntax,
      _ unexpectedAfterConfig: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBase, 
            base, 
            unexpectedBetweenBaseAndConfig, 
            config, 
            unexpectedAfterConfig
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBase?.raw, 
          base?.raw, 
          unexpectedBetweenBaseAndConfig?.raw, 
          config.raw, 
          unexpectedAfterConfig?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.postfixIfConfigExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  /// This initializer exists solely because Swift 5.6 does not support
  /// `Optional<ConcreteType>.none` as a default value of a generic parameter.
  /// The above initializer thus defaults to `nil` instead, but that means it
  /// is not actually callable when either not passing the defaulted parameter,
  /// or passing `nil`.
  ///
  /// Hack around that limitation using this initializer, which takes a
  /// `Missing*` syntax node instead. `Missing*` is used over the base type as
  /// the base type would allow implicit conversion from a string literal,
  /// which the above initializer doesn't support.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBase: UnexpectedNodesSyntax? = nil,
      base: MissingExprSyntax? = nil,
      _ unexpectedBetweenBaseAndConfig: UnexpectedNodesSyntax? = nil,
      config: IfConfigDeclSyntax,
      _ unexpectedAfterConfig: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    self.init(
        leadingTrivia: leadingTrivia,
        unexpectedBeforeBase,
        base: Optional<ExprSyntax> .none,
        unexpectedBetweenBaseAndConfig,
        config: config,
        unexpectedAfterConfig, 
        trailingTrivia: trailingTrivia
      )
  }
  
  public var unexpectedBeforeBase: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var base: ExprSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(ExprSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBaseAndConfig: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var config: IfConfigDeclSyntax {
    get {
      return IfConfigDeclSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterConfig: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBase, 
          \Self.base, 
          \Self.unexpectedBetweenBaseAndConfig, 
          \Self.config, 
          \Self.unexpectedAfterConfig
        ])
  }
}

// MARK: - PostfixUnaryExprSyntax



/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `operatorToken`: `<postfixOperator>`
public struct PostfixUnaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .postfixUnaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `PostfixUnaryExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .postfixUnaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedBetweenExpressionAndOperatorToken: UnexpectedNodesSyntax? = nil,
      operatorToken: TokenSyntax,
      _ unexpectedAfterOperatorToken: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndOperatorToken, 
            operatorToken, 
            unexpectedAfterOperatorToken
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndOperatorToken?.raw, 
          operatorToken.raw, 
          unexpectedAfterOperatorToken?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.postfixUnaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndOperatorToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var operatorToken: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOperatorToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndOperatorToken, 
          \Self.operatorToken, 
          \Self.unexpectedAfterOperatorToken
        ])
  }
}

// MARK: - PrefixOperatorExprSyntax



/// ### Children
/// 
///  - `operatorToken`: `<prefixOperator>`?
///  - `postfixExpression`: ``ExprSyntax``
public struct PrefixOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .prefixOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `PrefixOperatorExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .prefixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<P: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOperatorToken: UnexpectedNodesSyntax? = nil,
      operatorToken: TokenSyntax? = nil,
      _ unexpectedBetweenOperatorTokenAndPostfixExpression: UnexpectedNodesSyntax? = nil,
      postfixExpression: P,
      _ unexpectedAfterPostfixExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOperatorToken, 
            operatorToken, 
            unexpectedBetweenOperatorTokenAndPostfixExpression, 
            postfixExpression, 
            unexpectedAfterPostfixExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOperatorToken?.raw, 
          operatorToken?.raw, 
          unexpectedBetweenOperatorTokenAndPostfixExpression?.raw, 
          postfixExpression.raw, 
          unexpectedAfterPostfixExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.prefixOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOperatorToken: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var operatorToken: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorTokenAndPostfixExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var postfixExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPostfixExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOperatorToken, 
          \Self.operatorToken, 
          \Self.unexpectedBetweenOperatorTokenAndPostfixExpression, 
          \Self.postfixExpression, 
          \Self.unexpectedAfterPostfixExpression
        ])
  }
}

// MARK: - RegexLiteralExprSyntax



/// ### Children
/// 
///  - `openingPounds`: `<extendedRegexDelimiter>`?
///  - `openSlash`: `'/'`
///  - `regexPattern`: `<regexLiteralPattern>`
///  - `closeSlash`: `'/'`
///  - `closingPounds`: `<extendedRegexDelimiter>`?
public struct RegexLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .regexLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `RegexLiteralExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .regexLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOpeningPounds: UnexpectedNodesSyntax? = nil,
      openingPounds: TokenSyntax? = nil,
      _ unexpectedBetweenOpeningPoundsAndOpenSlash: UnexpectedNodesSyntax? = nil,
      openSlash: TokenSyntax = .regexSlashToken(),
      _ unexpectedBetweenOpenSlashAndRegexPattern: UnexpectedNodesSyntax? = nil,
      regexPattern: TokenSyntax,
      _ unexpectedBetweenRegexPatternAndCloseSlash: UnexpectedNodesSyntax? = nil,
      closeSlash: TokenSyntax = .regexSlashToken(),
      _ unexpectedBetweenCloseSlashAndClosingPounds: UnexpectedNodesSyntax? = nil,
      closingPounds: TokenSyntax? = nil,
      _ unexpectedAfterClosingPounds: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOpeningPounds, 
            openingPounds, 
            unexpectedBetweenOpeningPoundsAndOpenSlash, 
            openSlash, 
            unexpectedBetweenOpenSlashAndRegexPattern, 
            regexPattern, 
            unexpectedBetweenRegexPatternAndCloseSlash, 
            closeSlash, 
            unexpectedBetweenCloseSlashAndClosingPounds, 
            closingPounds, 
            unexpectedAfterClosingPounds
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOpeningPounds?.raw, 
          openingPounds?.raw, 
          unexpectedBetweenOpeningPoundsAndOpenSlash?.raw, 
          openSlash.raw, 
          unexpectedBetweenOpenSlashAndRegexPattern?.raw, 
          regexPattern.raw, 
          unexpectedBetweenRegexPatternAndCloseSlash?.raw, 
          closeSlash.raw, 
          unexpectedBetweenCloseSlashAndClosingPounds?.raw, 
          closingPounds?.raw, 
          unexpectedAfterClosingPounds?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.regexLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOpeningPounds: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openingPounds: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpeningPoundsAndOpenSlash: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openSlash: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpenSlashAndRegexPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var regexPattern: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRegexPatternAndCloseSlash: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closeSlash: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCloseSlashAndClosingPounds: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closingPounds: TokenSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterClosingPounds: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOpeningPounds, 
          \Self.openingPounds, 
          \Self.unexpectedBetweenOpeningPoundsAndOpenSlash, 
          \Self.openSlash, 
          \Self.unexpectedBetweenOpenSlashAndRegexPattern, 
          \Self.regexPattern, 
          \Self.unexpectedBetweenRegexPatternAndCloseSlash, 
          \Self.closeSlash, 
          \Self.unexpectedBetweenCloseSlashAndClosingPounds, 
          \Self.closingPounds, 
          \Self.unexpectedAfterClosingPounds
        ])
  }
}

// MARK: - SequenceExprSyntax



/// ### Children
/// 
///  - `elements`: ``ExprListSyntax``
public struct SequenceExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .sequenceExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `SequenceExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .sequenceExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeElements: UnexpectedNodesSyntax? = nil,
      elements: ExprListSyntax,
      _ unexpectedAfterElements: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeElements, elements, unexpectedAfterElements))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeElements?.raw, elements.raw, unexpectedAfterElements?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.sequenceExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SequenceExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elements: ExprListSyntax {
    get {
      return ExprListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SequenceExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: ExprSyntax) -> SequenceExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.exprList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 1, with: collection, arena: arena)
    return SequenceExprSyntax(newData)
  }
  
  public var unexpectedAfterElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SequenceExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeElements, \Self.elements, \Self.unexpectedAfterElements])
  }
}

// MARK: - SpecializeExprSyntax



/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `genericArgumentClause`: ``GenericArgumentClauseSyntax``
public struct SpecializeExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .specializeExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `SpecializeExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .specializeExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      genericArgumentClause: GenericArgumentClauseSyntax,
      _ unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndGenericArgumentClause, 
            genericArgumentClause, 
            unexpectedAfterGenericArgumentClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndGenericArgumentClause?.raw, 
          genericArgumentClause.raw, 
          unexpectedAfterGenericArgumentClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.specializeExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var genericArgumentClause: GenericArgumentClauseSyntax {
    get {
      return GenericArgumentClauseSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndGenericArgumentClause, 
          \Self.genericArgumentClause, 
          \Self.unexpectedAfterGenericArgumentClause
        ])
  }
}

// MARK: - StringLiteralExprSyntax



/// ### Children
/// 
///  - `openDelimiter`: `<rawStringDelimiter>`?
///  - `openQuote`: (`'"'` | `'"""'` | `'''`)
///  - `segments`: ``StringLiteralSegmentsSyntax``
///  - `closeQuote`: (`'"'` | `'"""'` | `'''`)
///  - `closeDelimiter`: `<rawStringDelimiter>`?
public struct StringLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .stringLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `StringLiteralExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .stringLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOpenDelimiter: UnexpectedNodesSyntax? = nil,
      openDelimiter: TokenSyntax? = nil,
      _ unexpectedBetweenOpenDelimiterAndOpenQuote: UnexpectedNodesSyntax? = nil,
      openQuote: TokenSyntax,
      _ unexpectedBetweenOpenQuoteAndSegments: UnexpectedNodesSyntax? = nil,
      segments: StringLiteralSegmentsSyntax,
      _ unexpectedBetweenSegmentsAndCloseQuote: UnexpectedNodesSyntax? = nil,
      closeQuote: TokenSyntax,
      _ unexpectedBetweenCloseQuoteAndCloseDelimiter: UnexpectedNodesSyntax? = nil,
      closeDelimiter: TokenSyntax? = nil,
      _ unexpectedAfterCloseDelimiter: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOpenDelimiter, 
            openDelimiter, 
            unexpectedBetweenOpenDelimiterAndOpenQuote, 
            openQuote, 
            unexpectedBetweenOpenQuoteAndSegments, 
            segments, 
            unexpectedBetweenSegmentsAndCloseQuote, 
            closeQuote, 
            unexpectedBetweenCloseQuoteAndCloseDelimiter, 
            closeDelimiter, 
            unexpectedAfterCloseDelimiter
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOpenDelimiter?.raw, 
          openDelimiter?.raw, 
          unexpectedBetweenOpenDelimiterAndOpenQuote?.raw, 
          openQuote.raw, 
          unexpectedBetweenOpenQuoteAndSegments?.raw, 
          segments.raw, 
          unexpectedBetweenSegmentsAndCloseQuote?.raw, 
          closeQuote.raw, 
          unexpectedBetweenCloseQuoteAndCloseDelimiter?.raw, 
          closeDelimiter?.raw, 
          unexpectedAfterCloseDelimiter?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.stringLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOpenDelimiter: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openDelimiter: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpenDelimiterAndOpenQuote: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openQuote: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpenQuoteAndSegments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var segments: StringLiteralSegmentsSyntax {
    get {
      return StringLiteralSegmentsSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Segment` to the node's `segments`
  /// collection.
  /// - param element: The new `Segment` to add to the node's
  ///                  `segments` collection.
  /// - returns: A copy of the receiver with the provided `Segment`
  ///            appended to its `segments` collection.
  public func addSegment(_ element: Syntax) -> StringLiteralExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.stringLiteralSegments,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 5, with: collection, arena: arena)
    return StringLiteralExprSyntax(newData)
  }
  
  public var unexpectedBetweenSegmentsAndCloseQuote: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closeQuote: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCloseQuoteAndCloseDelimiter: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closeDelimiter: TokenSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterCloseDelimiter: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOpenDelimiter, 
          \Self.openDelimiter, 
          \Self.unexpectedBetweenOpenDelimiterAndOpenQuote, 
          \Self.openQuote, 
          \Self.unexpectedBetweenOpenQuoteAndSegments, 
          \Self.segments, 
          \Self.unexpectedBetweenSegmentsAndCloseQuote, 
          \Self.closeQuote, 
          \Self.unexpectedBetweenCloseQuoteAndCloseDelimiter, 
          \Self.closeDelimiter, 
          \Self.unexpectedAfterCloseDelimiter
        ])
  }
}

// MARK: - SubscriptExprSyntax



/// ### Children
/// 
///  - `calledExpression`: ``ExprSyntax``
///  - `leftBracket`: `'['`
///  - `argumentList`: ``TupleExprElementListSyntax``
///  - `rightBracket`: `']'`
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct SubscriptExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .subscriptExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `SubscriptExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .subscriptExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<C: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? = nil,
      calledExpression: C,
      _ unexpectedBetweenCalledExpressionAndLeftBracket: UnexpectedNodesSyntax? = nil,
      leftBracket: TokenSyntax = .leftSquareBracketToken(),
      _ unexpectedBetweenLeftBracketAndArgumentList: UnexpectedNodesSyntax? = nil,
      argumentList: TupleExprElementListSyntax,
      _ unexpectedBetweenArgumentListAndRightBracket: UnexpectedNodesSyntax? = nil,
      rightBracket: TokenSyntax = .rightSquareBracketToken(),
      _ unexpectedBetweenRightBracketAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? = nil,
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCalledExpression, 
            calledExpression, 
            unexpectedBetweenCalledExpressionAndLeftBracket, 
            leftBracket, 
            unexpectedBetweenLeftBracketAndArgumentList, 
            argumentList, 
            unexpectedBetweenArgumentListAndRightBracket, 
            rightBracket, 
            unexpectedBetweenRightBracketAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCalledExpression?.raw, 
          calledExpression.raw, 
          unexpectedBetweenCalledExpressionAndLeftBracket?.raw, 
          leftBracket.raw, 
          unexpectedBetweenLeftBracketAndArgumentList?.raw, 
          argumentList.raw, 
          unexpectedBetweenArgumentListAndRightBracket?.raw, 
          rightBracket.raw, 
          unexpectedBetweenRightBracketAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures?.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.subscriptExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var calledExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCalledExpressionAndLeftBracket: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBracket: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBracketAndArgumentList: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argumentList: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Argument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> SubscriptExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 5, with: collection, arena: arena)
    return SubscriptExprSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentListAndRightBracket: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBracket: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightBracketAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(MultipleTrailingClosureElementListSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `AdditionalTrailingClosure` to the node's `additionalTrailingClosures`
  /// collection.
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> SubscriptExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[11] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 11, with: collection, arena: arena)
    return SubscriptExprSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCalledExpression, 
          \Self.calledExpression, 
          \Self.unexpectedBetweenCalledExpressionAndLeftBracket, 
          \Self.leftBracket, 
          \Self.unexpectedBetweenLeftBracketAndArgumentList, 
          \Self.argumentList, 
          \Self.unexpectedBetweenArgumentListAndRightBracket, 
          \Self.rightBracket, 
          \Self.unexpectedBetweenRightBracketAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - SuperRefExprSyntax



/// ### Children
/// 
///  - `superKeyword`: `'super'`
public struct SuperRefExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .superRefExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `SuperRefExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .superRefExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeSuperKeyword: UnexpectedNodesSyntax? = nil,
      superKeyword: TokenSyntax = .keyword(.super),
      _ unexpectedAfterSuperKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeSuperKeyword, superKeyword, unexpectedAfterSuperKeyword))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeSuperKeyword?.raw, superKeyword.raw, unexpectedAfterSuperKeyword?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.superRefExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeSuperKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SuperRefExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var superKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SuperRefExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterSuperKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SuperRefExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeSuperKeyword, \Self.superKeyword, \Self.unexpectedAfterSuperKeyword])
  }
}

// MARK: - SwitchExprSyntax



/// ### Children
/// 
///  - `switchKeyword`: `'switch'`
///  - `expression`: ``ExprSyntax``
///  - `leftBrace`: `'{'`
///  - `cases`: ``SwitchCaseListSyntax``
///  - `rightBrace`: `'}'`
public struct SwitchExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .switchExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `SwitchExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .switchExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeSwitchKeyword: UnexpectedNodesSyntax? = nil,
      switchKeyword: TokenSyntax = .keyword(.switch),
      _ unexpectedBetweenSwitchKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedBetweenExpressionAndLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndCases: UnexpectedNodesSyntax? = nil,
      cases: SwitchCaseListSyntax,
      _ unexpectedBetweenCasesAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeSwitchKeyword, 
            switchKeyword, 
            unexpectedBetweenSwitchKeywordAndExpression, 
            expression, 
            unexpectedBetweenExpressionAndLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndCases, 
            cases, 
            unexpectedBetweenCasesAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeSwitchKeyword?.raw, 
          switchKeyword.raw, 
          unexpectedBetweenSwitchKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndCases?.raw, 
          cases.raw, 
          unexpectedBetweenCasesAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.switchExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeSwitchKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var switchKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSwitchKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndCases: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var cases: SwitchCaseListSyntax {
    get {
      return SwitchCaseListSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Case` to the node's `cases`
  /// collection.
  /// - param element: The new `Case` to add to the node's
  ///                  `cases` collection.
  /// - returns: A copy of the receiver with the provided `Case`
  ///            appended to its `cases` collection.
  public func addCase(_ element: Syntax) -> SwitchExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[7] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.switchCaseList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 7, with: collection, arena: arena)
    return SwitchExprSyntax(newData)
  }
  
  public var unexpectedBetweenCasesAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeSwitchKeyword, 
          \Self.switchKeyword, 
          \Self.unexpectedBetweenSwitchKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndCases, 
          \Self.cases, 
          \Self.unexpectedBetweenCasesAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - TernaryExprSyntax



/// ### Children
/// 
///  - `conditionExpression`: ``ExprSyntax``
///  - `questionMark`: `'?'`
///  - `firstChoice`: ``ExprSyntax``
///  - `colonMark`: `':'`
///  - `secondChoice`: ``ExprSyntax``
public struct TernaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .ternaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `TernaryExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ternaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<C: ExprSyntaxProtocol, F: ExprSyntaxProtocol, S: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeConditionExpression: UnexpectedNodesSyntax? = nil,
      conditionExpression: C,
      _ unexpectedBetweenConditionExpressionAndQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .infixQuestionMarkToken(),
      _ unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? = nil,
      firstChoice: F,
      _ unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodesSyntax? = nil,
      colonMark: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonMarkAndSecondChoice: UnexpectedNodesSyntax? = nil,
      secondChoice: S,
      _ unexpectedAfterSecondChoice: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeConditionExpression, 
            conditionExpression, 
            unexpectedBetweenConditionExpressionAndQuestionMark, 
            questionMark, 
            unexpectedBetweenQuestionMarkAndFirstChoice, 
            firstChoice, 
            unexpectedBetweenFirstChoiceAndColonMark, 
            colonMark, 
            unexpectedBetweenColonMarkAndSecondChoice, 
            secondChoice, 
            unexpectedAfterSecondChoice
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeConditionExpression?.raw, 
          conditionExpression.raw, 
          unexpectedBetweenConditionExpressionAndQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedBetweenQuestionMarkAndFirstChoice?.raw, 
          firstChoice.raw, 
          unexpectedBetweenFirstChoiceAndColonMark?.raw, 
          colonMark.raw, 
          unexpectedBetweenColonMarkAndSecondChoice?.raw, 
          secondChoice.raw, 
          unexpectedAfterSecondChoice?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ternaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeConditionExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var conditionExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenConditionExpressionAndQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var firstChoice: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colonMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonMarkAndSecondChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var secondChoice: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterSecondChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeConditionExpression, 
          \Self.conditionExpression, 
          \Self.unexpectedBetweenConditionExpressionAndQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedBetweenQuestionMarkAndFirstChoice, 
          \Self.firstChoice, 
          \Self.unexpectedBetweenFirstChoiceAndColonMark, 
          \Self.colonMark, 
          \Self.unexpectedBetweenColonMarkAndSecondChoice, 
          \Self.secondChoice, 
          \Self.unexpectedAfterSecondChoice
        ])
  }
}

// MARK: - TryExprSyntax



/// ### Children
/// 
///  - `tryKeyword`: `'try'`
///  - `questionOrExclamationMark`: (`'?'` | `'!'`)?
///  - `expression`: ``ExprSyntax``
public struct TryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .tryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `TryExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .tryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<E: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeTryKeyword: UnexpectedNodesSyntax? = nil,
      tryKeyword: TokenSyntax = .keyword(.try),
      _ unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodesSyntax? = nil,
      expression: E,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeTryKeyword, 
            tryKeyword, 
            unexpectedBetweenTryKeywordAndQuestionOrExclamationMark, 
            questionOrExclamationMark, 
            unexpectedBetweenQuestionOrExclamationMarkAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeTryKeyword?.raw, 
          tryKeyword.raw, 
          unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.raw, 
          questionOrExclamationMark?.raw, 
          unexpectedBetweenQuestionOrExclamationMarkAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeTryKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var tryKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeTryKeyword, 
          \Self.tryKeyword, 
          \Self.unexpectedBetweenTryKeywordAndQuestionOrExclamationMark, 
          \Self.questionOrExclamationMark, 
          \Self.unexpectedBetweenQuestionOrExclamationMarkAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - TupleExprSyntax



/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `elementList`: ``TupleExprElementListSyntax``
///  - `rightParen`: `')'`
public struct TupleExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .tupleExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `TupleExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .tupleExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndElementList: UnexpectedNodesSyntax? = nil,
      elementList: TupleExprElementListSyntax,
      _ unexpectedBetweenElementListAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndElementList, 
            elementList, 
            unexpectedBetweenElementListAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndElementList?.raw, 
          elementList.raw, 
          unexpectedBetweenElementListAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tupleExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndElementList: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elementList: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `Element` to the node's `elementList`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elementList` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elementList` collection.
  public func addElement(_ element: TupleExprElementSyntax) -> TupleExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(at: 3, with: collection, arena: arena)
    return TupleExprSyntax(newData)
  }
  
  public var unexpectedBetweenElementListAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndElementList, 
          \Self.elementList, 
          \Self.unexpectedBetweenElementListAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - TypeExprSyntax



/// ### Children
/// 
///  - `type`: ``TypeSyntax``
public struct TypeExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .typeExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `TypeExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .typeExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<T: TypeSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeType: UnexpectedNodesSyntax? = nil,
      type: T,
      _ unexpectedAfterType: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeType, type, unexpectedAfterType))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeType?.raw, type.raw, unexpectedAfterType?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TypeExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeType, \Self.type, \Self.unexpectedAfterType])
  }
}

// MARK: - UnresolvedAsExprSyntax



/// ### Children
/// 
///  - `asTok`: `'as'`
///  - `questionOrExclamationMark`: (`'?'` | `'!'`)?
public struct UnresolvedAsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .unresolvedAsExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `UnresolvedAsExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedAsExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAsTok: UnexpectedNodesSyntax? = nil,
      asTok: TokenSyntax = .keyword(.as),
      _ unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedAfterQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAsTok, 
            asTok, 
            unexpectedBetweenAsTokAndQuestionOrExclamationMark, 
            questionOrExclamationMark, 
            unexpectedAfterQuestionOrExclamationMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAsTok?.raw, 
          asTok.raw, 
          unexpectedBetweenAsTokAndQuestionOrExclamationMark?.raw, 
          questionOrExclamationMark?.raw, 
          unexpectedAfterQuestionOrExclamationMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedAsExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAsTok: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var asTok: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAsTok, 
          \Self.asTok, 
          \Self.unexpectedBetweenAsTokAndQuestionOrExclamationMark, 
          \Self.questionOrExclamationMark, 
          \Self.unexpectedAfterQuestionOrExclamationMark
        ])
  }
}

// MARK: - UnresolvedIsExprSyntax



/// ### Children
/// 
///  - `isTok`: `'is'`
public struct UnresolvedIsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .unresolvedIsExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `UnresolvedIsExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedIsExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIsTok: UnexpectedNodesSyntax? = nil,
      isTok: TokenSyntax = .keyword(.is),
      _ unexpectedAfterIsTok: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeIsTok, isTok, unexpectedAfterIsTok))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeIsTok?.raw, isTok.raw, unexpectedAfterIsTok?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedIsExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIsTok: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedIsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var isTok: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedIsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterIsTok: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedIsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeIsTok, \Self.isTok, \Self.unexpectedAfterIsTok])
  }
}

// MARK: - UnresolvedPatternExprSyntax



/// ### Children
/// 
///  - `pattern`: ``PatternSyntax``
public struct UnresolvedPatternExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .unresolvedPatternExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `UnresolvedPatternExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedPatternExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<P: PatternSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePattern: UnexpectedNodesSyntax? = nil,
      pattern: P,
      _ unexpectedAfterPattern: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforePattern, pattern, unexpectedAfterPattern))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforePattern?.raw, pattern.raw, unexpectedAfterPattern?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedPatternExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedPatternExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pattern: PatternSyntax {
    get {
      return PatternSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedPatternExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedPatternExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforePattern, \Self.pattern, \Self.unexpectedAfterPattern])
  }
}

// MARK: - UnresolvedTernaryExprSyntax



/// ### Children
/// 
///  - `questionMark`: `'?'`
///  - `firstChoice`: ``ExprSyntax``
///  - `colonMark`: `':'`
public struct UnresolvedTernaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?<S: SyntaxProtocol>(_ node: S) {
    guard node.raw.kind == .unresolvedTernaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a `UnresolvedTernaryExprSyntax` node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedTernaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  public init<F: ExprSyntaxProtocol>(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .infixQuestionMarkToken(),
      _ unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? = nil,
      firstChoice: F,
      _ unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodesSyntax? = nil,
      colonMark: TokenSyntax = .colonToken(),
      _ unexpectedAfterColonMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeQuestionMark, 
            questionMark, 
            unexpectedBetweenQuestionMarkAndFirstChoice, 
            firstChoice, 
            unexpectedBetweenFirstChoiceAndColonMark, 
            colonMark, 
            unexpectedAfterColonMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedBetweenQuestionMarkAndFirstChoice?.raw, 
          firstChoice.raw, 
          unexpectedBetweenFirstChoiceAndColonMark?.raw, 
          colonMark.raw, 
          unexpectedAfterColonMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedTernaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var firstChoice: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colonMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterColonMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedBetweenQuestionMarkAndFirstChoice, 
          \Self.firstChoice, 
          \Self.unexpectedBetweenFirstChoiceAndColonMark, 
          \Self.colonMark, 
          \Self.unexpectedAfterColonMark
        ])
  }
}
